<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Bell inequalities ¬∑ NCTSSoS.jl</title><meta name="title" content="Bell inequalities ¬∑ NCTSSoS.jl"/><meta property="og:title" content="Bell inequalities ¬∑ NCTSSoS.jl"/><meta property="twitter:title" content="Bell inequalities ¬∑ NCTSSoS.jl"/><meta name="description" content="Documentation for NCTSSoS.jl."/><meta property="og:description" content="Documentation for NCTSSoS.jl."/><meta property="twitter:description" content="Documentation for NCTSSoS.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">NCTSSoS.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><a class="tocitem" href="../../../quick_start/">Quick Start</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../../manual/polynomials/">Polynomials</a></li><li><a class="tocitem" href="../../../manual/monomials/">Monomials</a></li><li><a class="tocitem" href="../../../manual/polynomial_optimization/">Polynomial Optimization</a></li><li><a class="tocitem" href="../../../manual/sparsities/">Sparsities</a></li><li><a class="tocitem" href="../../../manual/sdp_relaxation/">SDP Relaxation</a></li><li><a class="tocitem" href="../../../manual/optimizers/">Optimizers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Bell inequalities</a><ul class="internal"><li><a class="tocitem" href="#Setup"><span>Setup</span></a></li><li><a class="tocitem" href="#Key-Concepts:-Unipotent-and-Projector-Variables"><span>Key Concepts: Unipotent and Projector Variables</span></a></li><li><a class="tocitem" href="#Linear-Bell-Inequalities"><span>Linear Bell Inequalities</span></a></li><li><a class="tocitem" href="#Nonlinear-Bell-Inequalities"><span>Nonlinear Bell Inequalities</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li><li><a class="tocitem" href="../trace_poly/">Trace Polynomial</a></li><li><a class="tocitem" href="../monoid_algebras_showcase/">Monoid Algebra Showcase</a></li><li><a class="tocitem" href="../ground_state_energy/">Ground State Energy</a></li><li><a class="tocitem" href="../pauli_algebra_interface/">Pauli Algebra Interface</a></li><li><a class="tocitem" href="../certify_ground_state_property/">Certifying Ground State Property</a></li></ul></li><li><a class="tocitem" href="../../../reference/">References</a></li><li><span class="tocitem">APIs</span><ul><li><a class="tocitem" href="../../../apis/interface/">User interface</a></li><li><a class="tocitem" href="../../../apis/polynomials/">Polynomials</a></li><li><a class="tocitem" href="../../../apis/sparsities/">Sparsities</a></li><li><a class="tocitem" href="../../../apis/relaxations/">SDP Relaxation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Bell inequalities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Bell inequalities</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumSOS/NCTSSoS.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/main/docs/src/examples/generated/bell.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Bell-inequalities"><a class="docs-heading-anchor" href="#Bell-inequalities">Bell inequalities</a><a id="Bell-inequalities-1"></a><a class="docs-heading-anchor-permalink" href="#Bell-inequalities" title="Permalink"></a></h1><p>Bell inequalities test whether quantum mechanics can be explained by local hidden variable theories. They are linear combinations of expectation values with bounds that differ between classical and quantum theories.</p><p>The general form of a Bell inequality is:</p><p class="math-container">\[\sum_{i,j} c_{ij} \langle A_i B_j \rangle \leq C\]</p><p>where <span>$A_i$</span> and <span>$B_j$</span> are observables measured by Alice and Bob, <span>$c_{ij}$</span> are coefficients, and <span>$C$</span> is the classical bound. Quantum mechanics can exceed this bound.</p><h2 id="Setup"><a class="docs-heading-anchor" href="#Setup">Setup</a><a id="Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Setup" title="Permalink"></a></h2><p>We use <code>NCTSSoS.jl</code> for polynomial optimization and <code>COSMO</code> as the SDP solver backend.</p><pre><code class="language-julia hljs">using NCTSSoS, COSMO</code></pre><h2 id="Key-Concepts:-Unipotent-and-Projector-Variables"><a class="docs-heading-anchor" href="#Key-Concepts:-Unipotent-and-Projector-Variables">Key Concepts: Unipotent and Projector Variables</a><a id="Key-Concepts:-Unipotent-and-Projector-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Concepts:-Unipotent-and-Projector-Variables" title="Permalink"></a></h2><p>Bell inequalities use two types of measurement operators:</p><ol><li><strong>Unipotent operators</strong> (<span>$U^2 = I$</span>): Model ¬±1-valued observables like Pauli matrices</li><li><strong>Projector operators</strong> (<span>$P^2 = P$</span>): Model projection measurements like <span>$|0\rangle\langle 0|$</span></li></ol><p>Let&#39;s demonstrate both:</p><h3 id="Unipotent-Variables-(U-I)"><a class="docs-heading-anchor" href="#Unipotent-Variables-(U-I)">Unipotent Variables (U¬≤ = I)</a><a id="Unipotent-Variables-(U-I)-1"></a><a class="docs-heading-anchor-permalink" href="#Unipotent-Variables-(U-I)" title="Permalink"></a></h3><p>Create operators that square to identity:</p><pre><code class="language-julia hljs">reg_unip, (A, B) = create_unipotent_variables([(&quot;A&quot;, 1:2), (&quot;B&quot;, 1:2)])</code></pre><p>reg_unip: registry storing variable names and algebra type A: Alice&#39;s measurement operators [A‚ÇÅ, A‚ÇÇ] on site 1 B: Bob&#39;s measurement operators [B‚ÇÅ, B‚ÇÇ] on site 2</p><p>Verify the unipotent property (U¬≤ = I):</p><pre><code class="language-julia hljs">A[1] * A[1]  # should simplify to identity</code></pre><p>Check that operators on different sites commute:</p><pre><code class="language-julia hljs">A[1] * B[1] == B[1] * A[1]  # true: different sites commute</code></pre><h3 id="Projector-Variables-(P-P)"><a class="docs-heading-anchor" href="#Projector-Variables-(P-P)">Projector Variables (P¬≤ = P)</a><a id="Projector-Variables-(P-P)-1"></a><a class="docs-heading-anchor-permalink" href="#Projector-Variables-(P-P)" title="Permalink"></a></h3><p>Create operators that are idempotent:</p><pre><code class="language-julia hljs">reg_proj, (P, Q) = create_projector_variables([(&quot;P&quot;, 1:2), (&quot;Q&quot;, 1:2)])</code></pre><p>reg_proj: registry for projector algebra P: Alice&#39;s projectors [P‚ÇÅ, P‚ÇÇ] on site 1 Q: Bob&#39;s projectors [Q‚ÇÅ, Q‚ÇÇ] on site 2</p><p>Verify the idempotent property (P¬≤ = P):</p><pre><code class="language-julia hljs">monomials(P[1] * P[1])  # should be [P[1]]</code></pre><hr/><h2 id="Linear-Bell-Inequalities"><a class="docs-heading-anchor" href="#Linear-Bell-Inequalities">Linear Bell Inequalities</a><a id="Linear-Bell-Inequalities-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Bell-Inequalities" title="Permalink"></a></h2><hr/><h3 id="CHSH-Inequality"><a class="docs-heading-anchor" href="#CHSH-Inequality">CHSH Inequality</a><a id="CHSH-Inequality-1"></a><a class="docs-heading-anchor-permalink" href="#CHSH-Inequality" title="Permalink"></a></h3><p>The CHSH inequality involves two parties with two ¬±1-valued observables each. The objective function is:</p><p class="math-container">\[f(A_1, A_2, B_1, B_2) = \langle A_1 B_1 \rangle + \langle A_1 B_2 \rangle + \langle A_2 B_1 \rangle - \langle A_2 B_2 \rangle\]</p><p>Classical bound: <span>$f \leq 2$</span>. Quantum bound (Tsirelson): <span>$f \leq 2\sqrt{2} \approx 2.828$</span>.</p><h4 id="Step-1:-Create-unipotent-variables-for-CHSH"><a class="docs-heading-anchor" href="#Step-1:-Create-unipotent-variables-for-CHSH">Step 1: Create unipotent variables for CHSH</a><a id="Step-1:-Create-unipotent-variables-for-CHSH-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Create-unipotent-variables-for-CHSH" title="Permalink"></a></h4><pre><code class="language-julia hljs">registry, (x, y) = create_unipotent_variables([(&quot;x&quot;, 1:2), (&quot;y&quot;, 1:2)])</code></pre><p>registry: variable registry encoding U¬≤ = I constraint x: Alice&#39;s observables [x‚ÇÅ, x‚ÇÇ] = [A‚ÇÅ, A‚ÇÇ] y: Bob&#39;s observables [y‚ÇÅ, y‚ÇÇ] = [B‚ÇÅ, B‚ÇÇ]</p><h4 id="Step-2:-Define-the-CHSH-objective-function"><a class="docs-heading-anchor" href="#Step-2:-Define-the-CHSH-objective-function">Step 2: Define the CHSH objective function</a><a id="Step-2:-Define-the-CHSH-objective-function-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Define-the-CHSH-objective-function" title="Permalink"></a></h4><pre><code class="language-julia hljs">f = 1.0 * x[1] * y[1] +  # ‚ü®A‚ÇÅB‚ÇÅ‚ü© term
    1.0 * x[1] * y[2] +  # ‚ü®A‚ÇÅB‚ÇÇ‚ü© term
    1.0 * x[2] * y[1] -  # ‚ü®A‚ÇÇB‚ÇÅ‚ü© term
    1.0 * x[2] * y[2]    # -‚ü®A‚ÇÇB‚ÇÇ‚ü© term</code></pre><p>f: polynomial representing the CHSH Bell operator</p><p>Inspect the polynomial structure:</p><pre><code class="language-julia hljs">(monomials(f),      # list of monomials in f
 coefficients(f))   # corresponding coefficients</code></pre><h4 id="Step-3:-Create-the-optimization-problem"><a class="docs-heading-anchor" href="#Step-3:-Create-the-optimization-problem">Step 3: Create the optimization problem</a><a id="Step-3:-Create-the-optimization-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Create-the-optimization-problem" title="Permalink"></a></h4><pre><code class="language-julia hljs">pop = polyopt(f, registry)</code></pre><p>pop: polynomial optimization problem maximizing f      subject to the algebraic constraints in registry (U¬≤ = I)</p><h4 id="Step-4:-Configure-and-run-the-SDP-solver"><a class="docs-heading-anchor" href="#Step-4:-Configure-and-run-the-SDP-solver">Step 4: Configure and run the SDP solver</a><a id="Step-4:-Configure-and-run-the-SDP-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-Configure-and-run-the-SDP-solver" title="Permalink"></a></h4><pre><code class="language-julia hljs">solver_config = SolverConfig(
    optimizer = COSMO.Optimizer,  # SDP solver backend
    order = 1                      # relaxation order (hierarchy level)
)</code></pre><p>solver_config: specifies solver and relaxation parameters</p><pre><code class="language-julia hljs">result = cs_nctssos(pop, solver_config)</code></pre><p>result: optimization result containing objective value and solver info</p><h4 id="Step-5:-Extract-the-upper-bound"><a class="docs-heading-anchor" href="#Step-5:-Extract-the-upper-bound">Step 5: Extract the upper bound</a><a id="Step-5:-Extract-the-upper-bound-1"></a><a class="docs-heading-anchor-permalink" href="#Step-5:-Extract-the-upper-bound" title="Permalink"></a></h4><pre><code class="language-julia hljs">chsh_bound = result.objective</code></pre><p>chsh_bound: upper bound on maximal quantum violation</p><p>Compare with Tsirelson&#39;s bound:</p><pre><code class="language-julia hljs">tsirelson_bound = 2 * sqrt(2)</code></pre><p>tsirelson_bound: theoretical maximum = 2‚àö2 ‚âà 2.828</p><pre><code class="language-julia hljs">abs(chsh_bound - tsirelson_bound)  # difference (should be ~1e-7)</code></pre><hr/><h3 id="I_{3322}-Inequality"><a class="docs-heading-anchor" href="#I_{3322}-Inequality"><span>$I_{3322}$</span> Inequality</a><a id="I_{3322}-Inequality-1"></a><a class="docs-heading-anchor-permalink" href="#I_{3322}-Inequality" title="Permalink"></a></h3><p>The <span>$I_{3322}$</span> inequality uses <strong>projector</strong> observables (P¬≤ = P) with three measurements per party (<a href="../../../reference/#pal2010maximal">P√°l and V√©rtesi, 2010</a>).</p><p class="math-container">\[f = \langle A_1(B_1+B_2+B_3) \rangle + \langle A_2(B_1+B_2-B_3) \rangle + \langle A_3(B_1-B_2) \rangle - \langle A_1 \rangle - 2\langle B_1 \rangle - \langle B_2 \rangle\]</p><p>Classical bound: <span>$f \leq 0$</span>. Quantum bound: <span>$f \leq 0.25$</span>.</p><h4 id="Step-1:-Create-projector-variables"><a class="docs-heading-anchor" href="#Step-1:-Create-projector-variables">Step 1: Create projector variables</a><a id="Step-1:-Create-projector-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Create-projector-variables" title="Permalink"></a></h4><pre><code class="language-julia hljs">registry, (x, y) = create_projector_variables([(&quot;x&quot;, 1:3), (&quot;y&quot;, 1:3)])</code></pre><p>registry: variable registry encoding P¬≤ = P constraint x: Alice&#39;s projectors [x‚ÇÅ, x‚ÇÇ, x‚ÇÉ] = [A‚ÇÅ, A‚ÇÇ, A‚ÇÉ] y: Bob&#39;s projectors [y‚ÇÅ, y‚ÇÇ, y‚ÇÉ] = [B‚ÇÅ, B‚ÇÇ, B‚ÇÉ]</p><h4 id="Step-2:-Define-the-I-objective-function"><a class="docs-heading-anchor" href="#Step-2:-Define-the-I-objective-function">Step 2: Define the I‚ÇÉ‚ÇÉ‚ÇÇ‚ÇÇ objective function</a><a id="Step-2:-Define-the-I-objective-function-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Define-the-I-objective-function" title="Permalink"></a></h4><pre><code class="language-julia hljs">f = 1.0 * x[1] * (y[1] + y[2] + y[3]) +  # A‚ÇÅ(B‚ÇÅ+B‚ÇÇ+B‚ÇÉ)
    1.0 * x[2] * (y[1] + y[2] - y[3]) +  # A‚ÇÇ(B‚ÇÅ+B‚ÇÇ-B‚ÇÉ)
    1.0 * x[3] * (y[1] - y[2]) -         # A‚ÇÉ(B‚ÇÅ-B‚ÇÇ)
    1.0 * x[1] -                          # -A‚ÇÅ
    2.0 * y[1] -                          # -2B‚ÇÅ
    1.0 * y[2]                            # -B‚ÇÇ</code></pre><p>f: I‚ÇÉ‚ÇÉ‚ÇÇ‚ÇÇ Bell polynomial</p><p>Check the number of terms:</p><pre><code class="language-julia hljs">length(monomials(f))  # number of monomials</code></pre><h4 id="Step-3:-Solve-(minimizing-f-to-find-maximum-of-f)"><a class="docs-heading-anchor" href="#Step-3:-Solve-(minimizing-f-to-find-maximum-of-f)">Step 3: Solve (minimizing -f to find maximum of f)</a><a id="Step-3:-Solve-(minimizing-f-to-find-maximum-of-f)-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Solve-(minimizing-f-to-find-maximum-of-f)" title="Permalink"></a></h4><pre><code class="language-julia hljs">pop = polyopt(-f, registry)</code></pre><p>pop: minimize -f (equivalent to maximize f)</p><pre><code class="language-julia hljs">solver_config = SolverConfig(optimizer=COSMO.Optimizer, order=2)</code></pre><p>order=2: second level of the moment hierarchy</p><pre><code class="language-julia hljs">result = cs_nctssos(pop, solver_config)
i3322_bound = -result.objective</code></pre><p>i3322_bound: upper bound on I‚ÇÉ‚ÇÉ‚ÇÇ‚ÇÇ violation (negate since we minimized -f)</p><pre><code class="language-julia hljs">i3322_bound  # should be close to 0.25</code></pre><hr/><h3 id="Exploiting-Sparsity-for-Larger-Problems"><a class="docs-heading-anchor" href="#Exploiting-Sparsity-for-Larger-Problems">Exploiting Sparsity for Larger Problems</a><a id="Exploiting-Sparsity-for-Larger-Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Exploiting-Sparsity-for-Larger-Problems" title="Permalink"></a></h3><p>Higher relaxation orders improve bounds but increase SDP size. <strong>Sparsity exploitation</strong> reduces computational cost:</p><ol><li><strong>Correlative Sparsity (CS)</strong>: Decomposes problem by variable interactions</li><li><strong>Term Sparsity (TS)</strong>: Removes unnecessary monomials from moment matrices</li></ol><p>Let&#39;s solve I‚ÇÉ‚ÇÉ‚ÇÇ‚ÇÇ at order=6 using correlative sparsity:</p><h4 id="Without-sparsity-(for-comparison,-order3)"><a class="docs-heading-anchor" href="#Without-sparsity-(for-comparison,-order3)">Without sparsity (for comparison, order=3)</a><a id="Without-sparsity-(for-comparison,-order3)-1"></a><a class="docs-heading-anchor-permalink" href="#Without-sparsity-(for-comparison,-order3)" title="Permalink"></a></h4><pre><code class="language-julia hljs">registry, (x, y) = create_projector_variables([(&quot;x&quot;, 1:3), (&quot;y&quot;, 1:3)])
f = 1.0 * x[1] * (y[1] + y[2] + y[3]) + x[2] * (y[1] + y[2] - y[3]) +
    x[3] * (y[1] - y[2]) - x[1] - 2 * y[1] - y[2]
pop = polyopt(-f, registry)

solver_config_dense = SolverConfig(optimizer=COSMO.Optimizer, order=3)</code></pre><p>solver<em>config</em>dense: no sparsity exploitation</p><pre><code class="language-julia hljs">@time result_dense = cs_nctssos(pop, solver_config_dense)
bound_dense = -result_dense.objective</code></pre><p>bound_dense: bound without sparsity</p><pre><code class="language-julia hljs">bound_dense</code></pre><h4 id="With-correlative-sparsity-(order6)"><a class="docs-heading-anchor" href="#With-correlative-sparsity-(order6)">With correlative sparsity (order=6)</a><a id="With-correlative-sparsity-(order6)-1"></a><a class="docs-heading-anchor-permalink" href="#With-correlative-sparsity-(order6)" title="Permalink"></a></h4><pre><code class="language-julia hljs">solver_config_sparse = SolverConfig(
    optimizer = COSMO.Optimizer,
    order = 6,             # higher order for better bound
    cs_algo = MF()         # use MaxFlow algorithm for correlative sparsity
)</code></pre><p>cs_algo=MF(): enables correlative sparsity via chordal graph decomposition</p><pre><code class="language-julia hljs">@time result_sparse = cs_nctssos(pop, solver_config_sparse)
bound_sparse = -result_sparse.objective</code></pre><p>bound_sparse: improved bound using sparsity</p><pre><code class="language-julia hljs">bound_sparse  # closer to theoretical 0.25</code></pre><p>Improvement in bound:</p><pre><code class="language-julia hljs">bound_dense - bound_sparse  # positive = improvement</code></pre><hr/><h2 id="Nonlinear-Bell-Inequalities"><a class="docs-heading-anchor" href="#Nonlinear-Bell-Inequalities">Nonlinear Bell Inequalities</a><a id="Nonlinear-Bell-Inequalities-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Bell-Inequalities" title="Permalink"></a></h2><p>Nonlinear Bell inequalities involve polynomial functions of expectation values, not just linear combinations. They can detect non-locality where linear inequalities fail.</p><h3 id="Covariance-Bell-Inequality"><a class="docs-heading-anchor" href="#Covariance-Bell-Inequality">Covariance Bell Inequality</a><a id="Covariance-Bell-Inequality-1"></a><a class="docs-heading-anchor-permalink" href="#Covariance-Bell-Inequality" title="Permalink"></a></h3><p>The covariance between observables A and B is:</p><p class="math-container">\[\text{Cov}(A, B) = \langle AB \rangle - \langle A \rangle \langle B \rangle\]</p><p>This is <strong>nonlinear</strong> because it involves products of expectation values.</p><p>The covariance Bell inequality (<a href="../../../reference/#pozsgay2017Covariance">Pozsgay <em>et al.</em>, 2017</a>):</p><p class="math-container">\[f = \sum_{i,j} s_{ij} \text{Cov}(A_i, B_j)\]</p><p>with signs <span>$s_{ij} \in \{+1, -1\}$</span>. Classical bound: <span>$f \leq 4.5$</span>. Quantum bound: <span>$f = 5$</span>.</p><h4 id="Step-1:-Create-unipotent-variables"><a class="docs-heading-anchor" href="#Step-1:-Create-unipotent-variables">Step 1: Create unipotent variables</a><a id="Step-1:-Create-unipotent-variables-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Create-unipotent-variables" title="Permalink"></a></h4><pre><code class="language-julia hljs">registry, (x, y) = create_unipotent_variables([(&quot;x&quot;, 1:3), (&quot;y&quot;, 1:3)])</code></pre><p>x: Alice&#39;s observables [A‚ÇÅ, A‚ÇÇ, A‚ÇÉ] y: Bob&#39;s observables [B‚ÇÅ, B‚ÇÇ, B‚ÇÉ]</p><h4 id="Step-2:-Define-the-identity-monomial"><a class="docs-heading-anchor" href="#Step-2:-Define-the-identity-monomial">Step 2: Define the identity monomial</a><a id="Step-2:-Define-the-identity-monomial-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Define-the-identity-monomial" title="Permalink"></a></h4><pre><code class="language-julia hljs">ID = one(NormalMonomial{UnipotentAlgebra, UInt8})</code></pre><p>ID: identity element (ùüô) needed for state polynomial arithmetic</p><pre><code class="language-julia hljs">ID  # display the identity</code></pre><h4 id="Step-3:-Define-the-covariance-function-using-state-polynomials"><a class="docs-heading-anchor" href="#Step-3:-Define-the-covariance-function-using-state-polynomials">Step 3: Define the covariance function using state polynomials</a><a id="Step-3:-Define-the-covariance-function-using-state-polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Define-the-covariance-function-using-state-polynomials" title="Permalink"></a></h4><p>State polynomials use <code>œÇ(¬∑)</code> to denote expectation values ‚ü®¬∑‚ü©.</p><pre><code class="language-julia hljs">cov(a, b) = 1.0 * œÇ(x[a] * y[b]) * ID -  # ‚ü®A·µ¢B‚±º‚ü©
            1.0 * œÇ(x[a]) * œÇ(y[b]) * ID  # -‚ü®A·µ¢‚ü©‚ü®B‚±º‚ü©</code></pre><p>cov(a,b): covariance Cov(A‚Çê, B·µ¶) as a state polynomial œÇ (varsigma): expectation value operator, type \varsigma + Tab</p><p>Example: Cov(A‚ÇÅ, B‚ÇÅ)</p><pre><code class="language-julia hljs">cov(1, 1)</code></pre><h4 id="Step-4:-Build-the-objective-function"><a class="docs-heading-anchor" href="#Step-4:-Build-the-objective-function">Step 4: Build the objective function</a><a id="Step-4:-Build-the-objective-function-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-Build-the-objective-function" title="Permalink"></a></h4><pre><code class="language-julia hljs">sp = cov(1,1) + cov(1,2) + cov(1,3) +  # Cov(A‚ÇÅ, B‚ÇÅ) + Cov(A‚ÇÅ, B‚ÇÇ) + Cov(A‚ÇÅ, B‚ÇÉ)
     cov(2,1) + cov(2,2) - cov(2,3) +  # Cov(A‚ÇÇ, B‚ÇÅ) + Cov(A‚ÇÇ, B‚ÇÇ) - Cov(A‚ÇÇ, B‚ÇÉ)
     cov(3,1) - cov(3,2)               # Cov(A‚ÇÉ, B‚ÇÅ) - Cov(A‚ÇÉ, B‚ÇÇ)</code></pre><p>sp: state polynomial for covariance Bell inequality</p><h4 id="Step-5:-Create-optimization-problem-and-solve"><a class="docs-heading-anchor" href="#Step-5:-Create-optimization-problem-and-solve">Step 5: Create optimization problem and solve</a><a id="Step-5:-Create-optimization-problem-and-solve-1"></a><a class="docs-heading-anchor-permalink" href="#Step-5:-Create-optimization-problem-and-solve" title="Permalink"></a></h4><pre><code class="language-julia hljs">spop = polyopt(sp, registry)</code></pre><p>spop: state polynomial optimization problem</p><pre><code class="language-julia hljs">solver_config = SolverConfig(
    optimizer = COSMO.Optimizer,
    order = 2
)

result = cs_nctssos(spop, solver_config)
cov_bound = -result.objective</code></pre><p>cov_bound: upper bound on covariance Bell violation</p><pre><code class="language-julia hljs">cov_bound  # should be close to 5.0</code></pre><p>Compare with known quantum value:</p><pre><code class="language-julia hljs">abs(cov_bound - 5.0)  # difference from theoretical value</code></pre><h4 id="Step-6:-Improve-bound-using-term-sparsity-and-higher-order-iteration"><a class="docs-heading-anchor" href="#Step-6:-Improve-bound-using-term-sparsity-and-higher-order-iteration">Step 6: Improve bound using term sparsity and higher-order iteration</a><a id="Step-6:-Improve-bound-using-term-sparsity-and-higher-order-iteration-1"></a><a class="docs-heading-anchor-permalink" href="#Step-6:-Improve-bound-using-term-sparsity-and-higher-order-iteration" title="Permalink"></a></h4><pre><code class="language-julia hljs">solver_config_ts = SolverConfig(
    optimizer = COSMO.Optimizer,
    order = 3,
    ts_algo = MF()  # term sparsity
)</code></pre><p>ts_algo=MF(): enables term sparsity exploitation</p><pre><code class="language-julia hljs">result_ts = cs_nctssos(spop, solver_config_ts)</code></pre><p>result_ts: first iteration with term sparsity</p><pre><code class="language-julia hljs">result_higher = cs_nctssos_higher(spop, result_ts, solver_config_ts)</code></pre><p>result_higher: higher-order iteration refining the bound</p><pre><code class="language-julia hljs">improved_bound = -result_higher.objective</code></pre><p>improved_bound: refined upper bound</p><pre><code class="language-julia hljs">(improved_bound,               # closer to 5.0
 abs(improved_bound - 5.0))    # very small difference from theoretical value</code></pre><hr/><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><table><tr><th style="text-align: left">Inequality</th><th style="text-align: left">Operator Type</th><th style="text-align: left">Classical Bound</th><th style="text-align: left">Quantum Bound</th><th style="text-align: left">API</th></tr><tr><td style="text-align: left">CHSH</td><td style="text-align: left">Unipotent (U¬≤=I)</td><td style="text-align: left">2</td><td style="text-align: left">2‚àö2 ‚âà 2.828</td><td style="text-align: left"><code>create_unipotent_variables</code></td></tr><tr><td style="text-align: left">I‚ÇÉ‚ÇÉ‚ÇÇ‚ÇÇ</td><td style="text-align: left">Projector (P¬≤=P)</td><td style="text-align: left">0</td><td style="text-align: left">0.25</td><td style="text-align: left"><code>create_projector_variables</code></td></tr><tr><td style="text-align: left">Covariance</td><td style="text-align: left">Unipotent + State</td><td style="text-align: left">4.5</td><td style="text-align: left">5</td><td style="text-align: left"><code>œÇ(¬∑)</code> state polynomials</td></tr></table><p>Key functions:</p><ul><li><code>create_unipotent_variables</code>: Create U¬≤ = I operators</li><li><code>create_projector_variables</code>: Create P¬≤ = P operators</li><li><code>polyopt</code>: Create optimization problem</li><li><code>SolverConfig</code>: Configure solver and sparsity options</li><li><code>cs_nctssos</code>: Solve using moment-SOS hierarchy</li><li><code>œÇ(¬∑)</code>: Expectation value for state polynomials</li></ul><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../../manual/optimizers/">¬´ Optimizers</a><a class="docs-footer-nextpage" href="../trace_poly/">Trace Polynomial ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 18 February 2026 11:48">Wednesday 18 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
