<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Bell inequalities · NCTSSoS.jl</title><meta name="title" content="Bell inequalities · NCTSSoS.jl"/><meta property="og:title" content="Bell inequalities · NCTSSoS.jl"/><meta property="twitter:title" content="Bell inequalities · NCTSSoS.jl"/><meta name="description" content="Documentation for NCTSSoS.jl."/><meta property="og:description" content="Documentation for NCTSSoS.jl."/><meta property="twitter:description" content="Documentation for NCTSSoS.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">NCTSSoS.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><a class="tocitem" href="../../../quick_start/">Quick Start</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../../manual/polynomials/">Polynomials</a></li><li><a class="tocitem" href="../../../manual/polynomial_optimization/">Polynomial Optimization</a></li><li><a class="tocitem" href="../../../manual/sparsities/">Sparsities</a></li><li><a class="tocitem" href="../../../manual/sdp_relaxation/">SDP Relaxation</a></li><li><a class="tocitem" href="../../../manual/optimizers/">Optimizers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>Bell inequalities</a><ul class="internal"><li><a class="tocitem" href="#Linear-Bell-inequalities"><span>Linear Bell inequalities</span></a></li><li><a class="tocitem" href="#Nonlinear-Bell-Inequalities"><span>Nonlinear Bell Inequalities</span></a></li></ul></li><li><a class="tocitem" href="../trace_poly/">Trace Polynomial</a></li><li><a class="tocitem" href="../ground_state_energy/">Ground State Energy</a></li><li><a class="tocitem" href="../certify_ground_state_property/">Certifying Ground State Property</a></li></ul></li><li><a class="tocitem" href="../../../reference/">References</a></li><li><span class="tocitem">APIs</span><ul><li><a class="tocitem" href="../../../apis/interface/">User interface</a></li><li><a class="tocitem" href="../../../apis/polynomials/">Polynomials</a></li><li><a class="tocitem" href="../../../apis/sparsities/">Sparsities</a></li><li><a class="tocitem" href="../../../apis/relaxations/">SDP Relaxation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Bell inequalities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Bell inequalities</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumSOS/NCTSSoS.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/main/docs/src/examples/literate/bell.jl" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="bell-inequalities"><a class="docs-heading-anchor" href="#bell-inequalities">Bell inequalities</a><a id="bell-inequalities-1"></a><a class="docs-heading-anchor-permalink" href="#bell-inequalities" title="Permalink"></a></h1><p>Bell inequalities are mathematical expressions that test whether the predictions of quantum mechanics can be explained by local hidden variable theories. They were first introduced by John Stewart Bell in 1964 and have since become fundamental tools in quantum information theory and quantum foundations. A Bell inequality is typically expressed as a linear combination of expectation values of observables, with bounds that differ between classical and quantum theories. In the classical case, these inequalities must be satisfied if the system can be described by local hidden variables. However, quantum mechanics can violate these inequalities, demonstrating the non-local nature of quantum correlations. The general form of a Bell inequality can be written as:</p><p class="math-container">\[\sum_{i,j} c_{ij} \langle A_i B_j \rangle \leq C\]</p><p>where <span>$A_i$</span> and <span>$B_j$</span> are observables measured by two parties (traditionally called Alice and Bob), <span>$c_{ij}$</span> are real coefficients, and <span>$C$</span> is the classical bound. Quantum mechanics can violate this inequality, with the maximum violation known as the quantum bound.</p><h2 id="Linear-Bell-inequalities"><a class="docs-heading-anchor" href="#Linear-Bell-inequalities">Linear Bell inequalities</a><a id="Linear-Bell-inequalities-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Bell-inequalities" title="Permalink"></a></h2><h3 id="CHSH-inequality"><a class="docs-heading-anchor" href="#CHSH-inequality">CHSH inequality</a><a id="CHSH-inequality-1"></a><a class="docs-heading-anchor-permalink" href="#CHSH-inequality" title="Permalink"></a></h3><p>The most famous Bell inequality is the CHSH (Clauser-Horne-Shimony-Holt) inequality, which involves two parties, each measuring two observables. For unipotent (squared to 1) observables <span>$A_1, A_2$</span> measured by Alice and <span>$B_1, B_2$</span> measured by Bob. We define the objective function as:</p><p class="math-container">\[f(A_1, A_2, B_1, B_2) = \langle A_1B_1 \rangle + \langle A_1B_2 \rangle + \langle A_2B_1 \rangle - \langle A_2B_2 \rangle\]</p><p>The CHSH inequality is then given by <span>$f(A_1, A_2, B_1, B_2) \leq 2,$</span> which must be satisfied by any local hidden variable theory. However, quantum mechanics can violate this inequality up to the value <span>$2\sqrt{2}$</span>, known as Tsirelson&#39;s bound. This violation demonstrates that quantum mechanics cannot be described by any local hidden variable theory. The CHSH inequality is particularly important because it is the simplest non-trivial Bell inequality and has been experimentally verified numerous times, providing strong evidence for the non-local nature of quantum mechanics.</p><p>An upper bound on the maximal quantum violation of the CHSH inequality can be computed using the following code:</p><pre><code class="language-julia hljs">using NCTSSoS, MosekTools

@ncpolyvar x[1:2]  # x = (A_1, A_2)
@ncpolyvar y[1:2]  # y = (B_1, B_2)
f = 1.0 * x[1] * y[1] + x[1] * y[2] + x[2] * y[1] - x[2] * y[2]  # objective function

pop = polyopt(             # optimization problem
        f,
        comm_gps=[x, y],   # commutative group
        is_unipotent=true  # unipotent variables
    )

solver_config = SolverConfig(optimizer=Mosek.Optimizer,  # solver backend
    order=1                    # relaxation order
)
result = cs_nctssos(pop, solver_config)
result.objective  # upper bound on the maximal quantum violation</code></pre><pre><code class="nohighlight hljs">-2.8284271321623207</code></pre><p>The resulting upper bound is very close to the theoretical exact value <span>$2\sqrt{2} \approx 2.8284271247461903$</span> (accurate up to 7 decimals!!).</p><p>Here, we first declare some operators as non-commutative variables, and then construct the optimization problem. In <code>polyopt</code> constructor,</p><ul><li><code>comm_gps</code> argument specifies the commutative group of the variables, which means that variables in different commutative groups commute with each other.</li><li><code>is_unipotent</code> argument specifies that the variables are unipotent, which means that they are squared to 1 (e.g. Pauli operators).</li></ul><p>Here, since the variables on different qubits commute with each other, we can group them into different commutative groups.</p><p>In the solver configuration, we use <a href="https://github.com/oxfordcontrol/Clarabel.jl">Clarabel</a> as the SDP solver backend. It is an open-source solver for conic programs with quadratic objectives, and it uses the interior-point method to solve the problem (<a href="../../../reference/#Clarabel_2024">Goulart and Chen, 2024</a>).</p><h3 id="I_{3322}-inequality"><a class="docs-heading-anchor" href="#I_{3322}-inequality"><span>$I_{3322}$</span> inequality</a><a id="I_{3322}-inequality-1"></a><a class="docs-heading-anchor-permalink" href="#I_{3322}-inequality" title="Permalink"></a></h3><p>The <span>$I_{3322}$</span> inequality is a more complex inequality that involves two parties, each measuring three observables. Let <span>$A_1, A_2, A_3$</span> be the projective (squared to itself) observables measured by Alice and <span>$B_1, B_2, B_3$</span> be the projective observables measured by Bob. We define the objective function as (<a href="../../../reference/#pal2010maximal">Pál and Vértesi, 2010</a>):</p><p class="math-container">\[f(A_1, A_2, A_3, B_1, B_2, B_3) = \langle A_1(B_1+B_2+B_3) \rangle + \langle A_2(B_1+B_2-B_3) \rangle\\
+ \langle A_3(B_1-B_2) \rangle
- \langle A_1 \rangle - 2\langle B_1 \rangle - \langle B_2 \rangle.\]</p><p>In classical mechanics, the inequality <span>$f(A_1, A_2, A_3, B_1, B_2, B_3) \leq 0$</span> must be satisfied. However, quantum mechanics can violate this inequality up to the value <span>$0.25$</span>. This violation demonstrates that quantum mechanics cannot be described by any local hidden variable theory.</p><p>An upper bound on the maximal quantum violation of the <span>$I_{3322}$</span> inequality can be computed using the following code:</p><pre><code class="language-julia hljs">using NCTSSoS, MosekTools

@ncpolyvar x[1:3]
@ncpolyvar y[1:3]
f = 1.0 * x[1] * (y[1] + y[2] + y[3]) + x[2] * (y[1] + y[2] - y[3]) +
    x[3] * (y[1] - y[2]) - x[1] - 2 * y[1] - y[2]

pop = polyopt(-f, comm_gps= [x, y], is_projective=true)

solver_config = SolverConfig(optimizer=Mosek.Optimizer, order=2)

result = cs_nctssos(pop, solver_config)
result.objective</code></pre><pre><code class="nohighlight hljs">-0.25093972222115607</code></pre><p>Here, the <code>is_projective</code> argument specifies that the variables are projective, which means they are squared to themselves (e.g. <span>$|0\rangle\langle 0|$</span> and <span>$|1\rangle\langle 1|$</span>).</p><p>The resulting upper bound is close to the theoretically exact value <span>$0.25$</span>. By increasing the relaxation order, this upper bound could be further improved.</p><h4 id="Reducing-the-SDP-Size-by-exploiting-sparsity"><a class="docs-heading-anchor" href="#Reducing-the-SDP-Size-by-exploiting-sparsity">Reducing the SDP Size by exploiting sparsity</a><a id="Reducing-the-SDP-Size-by-exploiting-sparsity-1"></a><a class="docs-heading-anchor-permalink" href="#Reducing-the-SDP-Size-by-exploiting-sparsity" title="Permalink"></a></h4><p>To reach the theoretically exact value <span>$0.25$</span>, one may increase the relaxation order (<a href="../../../reference/#magronSparsePolynomialOptimization2023">Magron and Wang, 2023</a>).</p><pre><code class="language-julia hljs">using NCTSSoS, MosekTools

@ncpolyvar x[1:3]
@ncpolyvar y[1:3]
f = 1.0 * x[1] * (y[1] + y[2] + y[3]) + x[2] * (y[1] + y[2] - y[3]) +
    x[3] * (y[1] - y[2]) - x[1] - 2 * y[1] - y[2]

pop = polyopt(-f, comm_gps= [x, y], is_projective=true)

solver_config = SolverConfig(optimizer=Mosek.Optimizer, order=3)

@time result = cs_nctssos(pop, solver_config)
@show result.objective</code></pre><pre><code class="nohighlight hljs">-0.25087555008536233</code></pre><p>Indeed, by increasing the relaxation order to 3, we have improved the upper bound from <span>$-0.25093972222278366$</span> to <span>$-0.2508755502587585$</span>.</p><p>However, keep increasing the order leads to large-scale SDPs that are computationally expensive. To reduce the SDP size, we may exploit the sparsity of the problem (<a href="../../../reference/#magronSparsePolynomialOptimization2023">Magron and Wang, 2023</a>). There are two types of sparsities:</p><ol><li><p><strong>Correlative Sparsity</strong>: exploiting the fact that few variable products appear in the objective function. Therefore, we could break down the objective function into smaller parts, each involving fewer variables. This reduces the matrix size and the number of constraints of the SDP, making it more tractable.</p></li><li><p><strong>Term Sparsity</strong>: exploiting the fact that few monomials appear in the objective function. By identifying and removing unnecessary monomials, we can further reduce the matrix size and the number of constraints of the SDP.</p></li></ol><p>To take advantage of these sparsity patterns:</p><pre><code class="language-julia hljs">using NCTSSoS, MosekTools

@ncpolyvar x[1:3]
@ncpolyvar y[1:3]
f = 1.0 * x[1] * (y[1] + y[2] + y[3]) + x[2] * (y[1] + y[2] - y[3]) +
    x[3] * (y[1] - y[2]) - x[1] - 2 * y[1] - y[2]

pop = polyopt(-f, comm_gps= [x, y], is_projective=true)

solver_config = SolverConfig(optimizer=Mosek.Optimizer, order=6, cs_algo=MF())

@time result = cs_nctssos(pop, solver_config)
result.objective</code></pre><pre><code class="nohighlight hljs">-0.2508744934134293</code></pre><p>Using almost half of the time, we are able to improve the <span>$7$</span>-th digit of the upper bound!</p><h2 id="Nonlinear-Bell-Inequalities"><a class="docs-heading-anchor" href="#Nonlinear-Bell-Inequalities">Nonlinear Bell Inequalities</a><a id="Nonlinear-Bell-Inequalities-1"></a><a class="docs-heading-anchor-permalink" href="#Nonlinear-Bell-Inequalities" title="Permalink"></a></h2><p>Nonlinear Bell inequalities are extensions of the standard linear Bell inequalities. Instead of being linear combinations of expectation values, they involve polynomial functions of these expectation values. These inequalities arise naturally when considering more complex scenarios, such as multi-party settings or when the parties can perform sequences of measurements.</p><p>The significance of nonlinear Bell inequalities in quantum information lies in their ability to detect non-locality in situations where linear inequalities might fail. They can provide tighter bounds on classical correlations and reveal quantum non-locality in a broader range of experimental setups. Furthermore, studying nonlinear Bell inequalities helps in understanding the structure of quantum correlations and the boundary between classical and quantum physics more deeply. They are also relevant in the context of quantum cryptography and communication complexity, where understanding the limits of classical and quantum correlations is crucial.</p><h3 id="Covariance-Bell-Inequality"><a class="docs-heading-anchor" href="#Covariance-Bell-Inequality">Covariance Bell Inequality</a><a id="Covariance-Bell-Inequality-1"></a><a class="docs-heading-anchor-permalink" href="#Covariance-Bell-Inequality" title="Permalink"></a></h3><p>The covariance Bell inequality is a nonlinear Bell inequality that involves the covariance of measurements. It can be expressed as:</p><p class="math-container">\[\text{Cov}(A, B) = \langle A B \rangle - \langle A \rangle \langle B \rangle,\]</p><p>where <span>$A$</span> and <span>$B$</span> are observables measured by two parties. The covariance Bell inequality is nonlinear because it involves the product of expectation values of two observables.</p><p>Let us define the objective function as:</p><p class="math-container">\[f(A_1,A_2,A_3, B_1,B_2,B_3) = \text{Cov}(A_1, B_1) + \text{Cov}(A_1, B_2) + \text{Cov}(A_1,B_3)  + \\ \text{Cov}(A_2, B_1) + \text{Cov}(A_2, B_2) - \text{Cov}(A_2, B_3) + \text{Cov}(A_3, B_1) - \text{Cov}(A_3,B_2).\]</p><p>It was shown that <span>$f(A_1,A_2,A_3,B_1,B_2,B_3) \leq \frac{9}{2}$</span> in classical models, while it attains the quantum violation <span>$5$</span> with a maximally entangled state in a spatial quantum model (<a href="../../../reference/#pozsgay2017Covariance">Pozsgay <em>et al.</em>, 2017</a>).</p><p>An <em>open question</em> is: what is the maximal quantum violation that the covariance Bell inequality can attain in spatial quantum models. We can tackle this question using state polynomial optimization (<a href="../../../reference/#klep2024State">Klep <em>et al.</em>, 2024</a>).</p><pre><code class="language-julia hljs">using NCTSSoS, MosekTools, NCTSSoS.FastPolynomials

@ncpolyvar x[1:3] y[1:3]  # x = (A_1, A_2, A_3), y = (B_1, B_2, B_3)</code></pre><pre><code class="nohighlight hljs">(NCTSSoS.FastPolynomials.Variable[x₁, x₂, x₃], NCTSSoS.FastPolynomials.Variable[y₁, y₂, y₃])</code></pre><p>covariance function</p><pre><code class="language-julia hljs">cov(a, b) = 1.0 * ς(x[a] * y[b]) * one(Monomial) -
            1.0 * ς(x[a]) * ς(y[b]) * one(Monomial)</code></pre><pre><code class="nohighlight hljs">cov (generic function with 1 method)</code></pre><p>objective function</p><pre><code class="language-julia hljs">sp = cov(1,1) + cov(1,2) + cov(1,3) + cov(2,1) + cov(2,2) - cov(2,3) + cov(3,1) - cov(3,2)


spop = polyopt(
        sp,
        is_unipotent=true,
        comm_gps=[x[1:3], y[1:3]]
        )

solver_config = SolverConfig(
    optimizer=Mosek.Optimizer,          # solver backend
    order=2                             # relaxation order
)

result = cs_nctssos(spop, solver_config)
result.objective</code></pre><pre><code class="nohighlight hljs">-5.0002715409977965</code></pre><div class="admonition is-info" id="Typing-Unicodes-98aadf157bcb1df5"><header class="admonition-header">Typing Unicodes<a class="admonition-anchor" href="#Typing-Unicodes-98aadf157bcb1df5" title="Permalink"></a></header><div class="admonition-body"><p>You can type the unicode characters in the code by using <code>\varsigma</code> and pressing <code>Tab</code> to get the unicode character <code>ς</code>.</p></div></div><pre><code class="language-julia hljs">-5.000271541108556</code></pre><p>The resulting upper bound is very close to the previously known best value <span>$5$</span> (accurate up to 3 decimals!!).</p><p>We can use sparsity to further improve the bound.</p><pre><code class="language-julia hljs">using NCTSSoS, MosekTools, NCTSSoS.FastPolynomials

@ncpolyvar x[1:3] y[1:3]  # x = (A_1, A_2, A_3), y = (B_1, B_2, B_3)</code></pre><pre><code class="nohighlight hljs">(NCTSSoS.FastPolynomials.Variable[x₁, x₂, x₃], NCTSSoS.FastPolynomials.Variable[y₁, y₂, y₃])</code></pre><p>covariance function</p><pre><code class="language-julia hljs">cov(a, b) = 1.0 * ς(x[a] * y[b]) * one(Monomial) -
            1.0 * ς(x[a]) * ς(y[b]) * one(Monomial)</code></pre><pre><code class="nohighlight hljs">cov (generic function with 1 method)</code></pre><p>objective function</p><pre><code class="language-julia hljs">sp = cov(1,1) + cov(1,2) + cov(1,3) + cov(2,1) + cov(2,2) - cov(2,3) + cov(3,1) - cov(3,2)


spop = polyopt(
        sp,
        is_unipotent=true,
        comm_gps=[x[1:3], y[1:3]]
        )

solver_config = SolverConfig(
    optimizer=Mosek.Optimizer,
    order=3,
    ts_algo=MF()
)

result = cs_nctssos(spop, solver_config)

result_higher = cs_nctssos_higher(spop, result, solver_config)
result_higher.objective</code></pre><pre><code class="nohighlight hljs">-5.000454113653677</code></pre><pre><code class="language-julia hljs">-4.999999981821947</code></pre><p>This is accurate up to <span>$10$</span> decimals.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../../manual/optimizers/">« Optimizers</a><a class="docs-footer-nextpage" href="../trace_poly/">Trace Polynomial »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 23 September 2025 12:02">Tuesday 23 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
