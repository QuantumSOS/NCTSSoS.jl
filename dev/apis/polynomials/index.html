<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Polynomials · NCTSSoS.jl</title><meta name="title" content="Polynomials · NCTSSoS.jl"/><meta property="og:title" content="Polynomials · NCTSSoS.jl"/><meta property="twitter:title" content="Polynomials · NCTSSoS.jl"/><meta name="description" content="Documentation for NCTSSoS.jl."/><meta property="og:description" content="Documentation for NCTSSoS.jl."/><meta property="twitter:description" content="Documentation for NCTSSoS.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NCTSSoS.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quick_start/">Quick Start</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/polynomials/">Polynomials</a></li><li><a class="tocitem" href="../../manual/monomials/">Monomials</a></li><li><a class="tocitem" href="../../manual/polynomial_optimization/">Polynomial Optimization</a></li><li><a class="tocitem" href="../../manual/sparsities/">Sparsities</a></li><li><a class="tocitem" href="../../manual/sdp_relaxation/">SDP Relaxation</a></li><li><a class="tocitem" href="../../manual/optimizers/">Optimizers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/generated/bell/">Bell inequalities</a></li><li><a class="tocitem" href="../../examples/generated/trace_poly/">Trace Polynomial</a></li><li><a class="tocitem" href="../../examples/generated/monoid_algebras_showcase/">Monoid Algebra Showcase</a></li><li><a class="tocitem" href="../../examples/generated/ground_state_energy/">Ground State Energy</a></li><li><a class="tocitem" href="../../examples/generated/pauli_algebra_interface/">Pauli Algebra Interface</a></li><li><a class="tocitem" href="../../examples/generated/certify_ground_state_property/">Certifying Ground State Property</a></li></ul></li><li><a class="tocitem" href="../../reference/">References</a></li><li><span class="tocitem">APIs</span><ul><li><a class="tocitem" href="../interface/">User interface</a></li><li class="is-active"><a class="tocitem" href>Polynomials</a><ul class="internal"><li><a class="tocitem" href="#Algebra-Types"><span>Algebra Types</span></a></li><li><a class="tocitem" href="#Variables"><span>Variables</span></a></li><li><a class="tocitem" href="#Monomials"><span>Monomials</span></a></li><li><a class="tocitem" href="#Polynomials"><span>Polynomials</span></a></li><li><a class="tocitem" href="#State-Polynomial"><span>State Polynomial</span></a></li><li><a class="tocitem" href="#Simplification-Interface"><span>Simplification Interface</span></a></li><li><a class="tocitem" href="#Utilities"><span>Utilities</span></a></li></ul></li><li><a class="tocitem" href="../sparsities/">Sparsities</a></li><li><a class="tocitem" href="../relaxations/">SDP Relaxation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">APIs</a></li><li class="is-active"><a href>Polynomials</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Polynomials</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumSOS/NCTSSoS.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/main/docs/src/apis/polynomials.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Fast-Polynomials"><a class="docs-heading-anchor" href="#Fast-Polynomials">Fast Polynomials</a><a id="Fast-Polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Fast-Polynomials" title="Permalink"></a></h1><h2 id="Algebra-Types"><a class="docs-heading-anchor" href="#Algebra-Types">Algebra Types</a><a id="Algebra-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Algebra-Types" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="NCTSSoS.AlgebraType"><a class="docstring-binding" href="#NCTSSoS.AlgebraType"><code>NCTSSoS.AlgebraType</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AlgebraType</code></pre><p>Abstract type representing different algebraic structures with their commutation/anticommutation relations.</p><p>Each concrete algebra type is a singleton struct that enables multiple dispatch for simplification algorithms.</p><p><strong>Subtypes</strong></p><ul><li><code>NonCommutativeAlgebra</code>: Standard non-commutative variables (xy ≠ yx)</li><li><code>PauliAlgebra</code>: Pauli spin matrices satisfying σᵢ² = I and {σᵢ, σⱼ} = 2δᵢⱼ</li><li><code>FermionicAlgebra</code>: Fermionic creation/annihilation operators with {aᵢ, aⱼ†} = δᵢⱼ</li><li><code>BosonicAlgebra</code>: Bosonic creation/annihilation operators with [cᵢ, cⱼ†] = δᵢⱼ</li><li><code>ProjectorAlgebra</code>: Projector operators satisfying Pᵢ² = Pᵢ (idempotent)</li><li><code>UnipotentAlgebra</code>: Unipotent operators satisfying P² = I</li></ul><p><strong>Design</strong></p><p>Singleton types enable zero-cost dispatch on algebra operations:</p><pre><code class="language-julia hljs">simplify(::Type{PauliAlgebra}, m::NormalMonomial) = ...</code></pre><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; PauliAlgebra()
PauliAlgebra()

julia&gt; FermionicAlgebra() isa AlgebraType
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/algebra.jl#L1-L32">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.BosonicAlgebra"><a class="docstring-binding" href="#NCTSSoS.BosonicAlgebra"><code>NCTSSoS.BosonicAlgebra</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">BosonicAlgebra &lt;: PBWAlgebra</code></pre><p>Bosonic creation/annihilation operator algebra.</p><p><strong>Algebraic Rules</strong></p><ul><li>[cᵢ, cⱼ†] = δᵢⱼ (commutation: creation-annihilation)</li><li>[cᵢ, cⱼ] = 0 (commutation: annihilation-annihilation)</li><li>[cᵢ†, cⱼ†] = 0 (commutation: creation-creation)</li></ul><p>Normal ordering places all creation operators (c†) to the LEFT of all annihilation operators (c).</p><p><strong>Key difference from fermions</strong>: Commutation does not introduce sign changes, but adds correction terms. Simplification may return multiple terms.</p><p><strong>Variable Encoding</strong></p><ul><li>Annihilation <code>cᵢ</code>: positive index <code>i</code></li><li>Creation <code>cᵢ†</code>: negative index <code>-i</code></li></ul><p><strong>Integer Type</strong></p><p>Uses signed integer types (sign distinguishes creation/annihilation). Concrete type determined by VariableRegistry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/algebra.jl#L145-L169">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.FermionicAlgebra"><a class="docstring-binding" href="#NCTSSoS.FermionicAlgebra"><code>NCTSSoS.FermionicAlgebra</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FermionicAlgebra &lt;: PBWAlgebra</code></pre><p>Fermionic creation/annihilation operator algebra.</p><p><strong>Algebraic Rules</strong></p><ul><li>{aᵢ, aⱼ†} = δᵢⱼ (anticommutation: creation-annihilation)</li><li>{aᵢ, aⱼ} = 0 (anticommutation: annihilation-annihilation)</li><li>{aᵢ†, aⱼ†} = 0 (anticommutation: creation-creation)</li></ul><p>Normal ordering places all creation operators (a†) to the LEFT of all annihilation operators (a).</p><p><strong>Variable Encoding</strong></p><ul><li>Annihilation <code>aᵢ</code>: positive index <code>i</code></li><li>Creation <code>aᵢ†</code>: negative index <code>-i</code></li></ul><p><strong>Integer Type</strong></p><p>Uses signed integer types (sign distinguishes creation/annihilation). Concrete type determined by VariableRegistry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/algebra.jl#L122-L142">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.MonoidAlgebra"><a class="docstring-binding" href="#NCTSSoS.MonoidAlgebra"><code>NCTSSoS.MonoidAlgebra</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">MonoidAlgebra &lt;: AlgebraType</code></pre><p>Algebra category where the <strong>normal form of a monomial is still a single monomial</strong> (i.e. closed on monomials).</p><p>This matches a <em>monoid algebra / monoid ring</em> viewpoint: basis elements are indexed by elements of a monoid, and multiplying basis elements yields another basis element in the same basis (extended linearly to polynomials). [@monoidRing]</p><p>In <code>NCTSSoS.jl</code>, this category includes:</p><ul><li><code>NonCommutativeAlgebra</code> (free/noncommutative words)</li><li><code>ProjectorAlgebra</code> (idempotency P² = P)</li><li><code>UnipotentAlgebra</code> (involution U² = I)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/algebra.jl#L35-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.NonCommutativeAlgebra"><a class="docstring-binding" href="#NCTSSoS.NonCommutativeAlgebra"><code>NCTSSoS.NonCommutativeAlgebra</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NonCommutativeAlgebra &lt;: MonoidAlgebra</code></pre><p>Generic non-commutative algebra used when no specific algebra is specified.</p><p>This algebra is <em>site-aware</em>: operators on different sites commute, while operators on the same site remain non-commutative.</p><p><strong>Algebraic Rules</strong></p><ul><li><strong>Within a site</strong>: no simplification rules; operator order is preserved exactly.</li><li><strong>Across sites</strong>: operators commute; the canonical word is <strong>stable-sorted by site</strong> (stable sort preserves within-site order).</li></ul><p><strong>Index Encoding</strong></p><p>Variable indices must be <strong>unsigned</strong> and include bit-packed site information; see <code>encode_index</code> / <code>decode_site</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/algebra.jl#L81-L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.PBWAlgebra"><a class="docstring-binding" href="#NCTSSoS.PBWAlgebra"><code>NCTSSoS.PBWAlgebra</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PBWAlgebra &lt;: AlgebraType</code></pre><p>Algebra category where the <strong>normal form of a monomial expands to a sum of monomials</strong>.</p><p>This matches the computational noncommutative algebra pattern of <em>PBW algebras</em>: there is an ordered monomial basis and a rewriting/normal-ordering procedure, but reordering introduces lower terms, so a product may expand into multiple normal-form monomials. [@pbwAlgebraOscar]</p><p>In <code>NCTSSoS.jl</code>, this category includes:</p><ul><li><code>FermionicAlgebra</code> (CAR / anticommutation)</li><li><code>BosonicAlgebra</code> (CCR / commutation)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/algebra.jl#L66-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.PauliAlgebra"><a class="docstring-binding" href="#NCTSSoS.PauliAlgebra"><code>NCTSSoS.PauliAlgebra</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PauliAlgebra &lt;: TwistedGroupAlgebra</code></pre><p>Pauli spin matrix algebra.</p><p><strong>Algebraic Rules</strong></p><ul><li>σᵢ² = I (involution: squares to identity)</li><li>{σᵢ, σⱼ} = 2δᵢⱼ (anticommutation)</li><li>σₓ σᵧ = i σᵤ, σᵧ σᵤ = i σₓ, σᵤ σₓ = i σᵧ (cyclic products)</li><li>Operators on different sites commute</li></ul><p><strong>Variable Encoding</strong></p><p>Variables are ordered by site first: σx₁, σy₁, σz₁, σx₂, σy₂, σz₂, ... For index <code>idx</code>: site = <code>(idx - 1) ÷ 3 + 1</code>, pauli_type = <code>(idx - 1) % 3</code> (0=X, 1=Y, 2=Z)</p><p><strong>Integer Type</strong></p><p>Typically uses unsigned integer types (self-adjoint operators). Concrete type determined by VariableRegistry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/algebra.jl#L100-L119">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.ProjectorAlgebra"><a class="docstring-binding" href="#NCTSSoS.ProjectorAlgebra"><code>NCTSSoS.ProjectorAlgebra</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ProjectorAlgebra &lt;: MonoidAlgebra</code></pre><p>Projector operator algebra.</p><p><strong>Algebraic Rules</strong></p><ul><li>Pᵢ² = Pᵢ (idempotency: projectors square to themselves)</li><li>Commutativity NOT enforced (treat as non-commutative)</li></ul><p><strong>Variable Naming</strong></p><p>Variables use symbols P₁, P₂, P₃, ... Projectors are self-adjoint.</p><p><strong>Integer Type</strong></p><p>Typically uses unsigned integer types (self-adjoint operators). Concrete type determined by VariableRegistry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/algebra.jl#L172-L188">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.TwistedGroupAlgebra"><a class="docstring-binding" href="#NCTSSoS.TwistedGroupAlgebra"><code>NCTSSoS.TwistedGroupAlgebra</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">TwistedGroupAlgebra &lt;: AlgebraType</code></pre><p>Algebra category where the <strong>normal form of a monomial is a scalar/phase times a single monomial</strong>.</p><p>This matches a <em>twisted group algebra</em> viewpoint: basis elements are indexed by a group, but multiplication is twisted by a scalar 2-cocycle, so products satisfy <code>u_g * u_h = α(g,h) u_{gh}</code>. [@twistedGroupAlgebra]</p><p>In <code>NCTSSoS.jl</code>, this category includes:</p><ul><li><code>PauliAlgebra</code> (Pauli products generate phases {±1, ±i})</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/algebra.jl#L52-L63">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.UnipotentAlgebra"><a class="docstring-binding" href="#NCTSSoS.UnipotentAlgebra"><code>NCTSSoS.UnipotentAlgebra</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UnipotentAlgebra &lt;: MonoidAlgebra</code></pre><p>Unipotent operator algebra.</p><p><strong>Algebraic Rules</strong></p><ul><li>P² = I (squares to identity)</li><li>No cyclic products or cross-operator interactions</li></ul><p><strong>Note</strong>: This is simpler than Pauli algebra which also has cyclic product rules. Unipotent only removes consecutive pairs.</p><p><strong>Integer Type</strong></p><p>Typically uses unsigned integer types (self-adjoint operators). Concrete type determined by VariableRegistry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/algebra.jl#L191-L206">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.coeff_type-Tuple{Type{&lt;:AlgebraType}}"><a class="docstring-binding" href="#NCTSSoS.coeff_type-Tuple{Type{&lt;:AlgebraType}}"><code>NCTSSoS.coeff_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">coeff_type(::Type{A}) where {A&lt;:AlgebraType} -&gt; Type{&lt;:Number}</code></pre><p>Return the default coefficient type for a given algebra type.</p><p>Different algebras naturally work with different coefficient types:</p><ul><li><code>PauliAlgebra</code>: <code>ComplexF64</code> (Pauli products generate complex phases)</li><li>All others: <code>Float64</code> (real coefficients suffice)</li></ul><p>This is used by constructors like <code>Polynomial(m::NormalMonomial)</code> to infer the appropriate coefficient type when not explicitly specified.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; coeff_type(PauliAlgebra)
ComplexF64

julia&gt; coeff_type(NonCommutativeAlgebra)
Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/algebra.jl#L213-L235">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.decode_operator_id-Tuple{T} where T&lt;:Unsigned"><a class="docstring-binding" href="#NCTSSoS.decode_operator_id-Tuple{T} where T&lt;:Unsigned"><code>NCTSSoS.decode_operator_id</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">decode_operator_id(idx::T) where {T&lt;:Unsigned} -&gt; Int</code></pre><p>Extract operator ID from encoded index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/algebra.jl#L341-L345">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.decode_site-Tuple{T} where T&lt;:Unsigned"><a class="docstring-binding" href="#NCTSSoS.decode_site-Tuple{T} where T&lt;:Unsigned"><code>NCTSSoS.decode_site</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">decode_site(idx::T) where {T&lt;:Unsigned} -&gt; Int</code></pre><p>Extract site from encoded index (1-indexed).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/algebra.jl#L331-L335">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.encode_index-Union{Tuple{T}, Tuple{Type{T}, Integer, Integer}} where T&lt;:Unsigned"><a class="docstring-binding" href="#NCTSSoS.encode_index-Union{Tuple{T}, Tuple{Type{T}, Integer, Integer}} where T&lt;:Unsigned"><code>NCTSSoS.encode_index</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">encode_index(::Type{T}, operator_id::Int, site::Int) where {T&lt;:Unsigned} -&gt; T</code></pre><p>Encode operator_id and site into a single index of type T. Site is 1-indexed and stored directly in the lower bits.</p><p><strong>Arguments</strong></p><ul><li><code>T</code>: The unsigned integer type to use for encoding</li><li><code>operator_id</code>: Operator identifier (1-indexed, must be ≤ max_operators(T))</li><li><code>site</code>: Physical site (1-indexed, must be ≤ max_sites(T))</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">idx = encode_index(UInt16, 1, 3)  # 0x0013 (operator 1, site 3)
decode_site(idx)                   # 3
decode_operator_id(idx)            # 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/algebra.jl#L300-L317">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.max_operators-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Unsigned"><a class="docstring-binding" href="#NCTSSoS.max_operators-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Unsigned"><code>NCTSSoS.max_operators</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">max_operators(::Type{T}) where {T&lt;:Unsigned} -&gt; Int</code></pre><p>Maximum number of operators per site supported by unsigned type T. Since operator IDs are 1-indexed, the maximum is <code>2^(n-k) - 1</code> where n is bit width and k is site bits.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">max_operators(UInt16)  # 4095
max_operators(UInt32)  # 16777215</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/algebra.jl#L285-L296">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.max_sites-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Unsigned"><a class="docstring-binding" href="#NCTSSoS.max_sites-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Unsigned"><code>NCTSSoS.max_sites</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">max_sites(::Type{T}) where {T&lt;:Unsigned} -&gt; Int</code></pre><p>Maximum number of sites supported by unsigned type T. Since sites are 1-indexed and stored directly, max is <code>2^k - 1</code> where k is site_bits.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">max_sites(UInt8)   # 3 (2 bits can store 1,2,3)
max_sites(UInt16)  # 15 (4 bits can store 1-15)
max_sites(UInt32)  # 255 (8 bits can store 1-255)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/algebra.jl#L270-L282">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.select_uint_type-Tuple{Integer, Integer}"><a class="docstring-binding" href="#NCTSSoS.select_uint_type-Tuple{Integer, Integer}"><code>NCTSSoS.select_uint_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">select_uint_type(n_operators::Integer, n_sites::Integer) -&gt; Type{&lt;:Unsigned}</code></pre><p>Select the smallest unsigned integer type that can encode the given number of operators and sites.</p><div class="admonition is-info" id="Type-Stability-c79981b674a2a1c9"><header class="admonition-header">Type Stability<a class="admonition-anchor" href="#Type-Stability-c79981b674a2a1c9" title="Permalink"></a></header><div class="admonition-body"><p>This function returns a <code>Type</code>, not a value. The returned type depends on runtime values, so callers should use a function barrier or type annotation to maintain type stability in performance-critical code:</p><pre><code class="language-julia hljs">T = select_uint_type(n_ops, n_sites)
_inner_loop(T, data)  # function barrier</code></pre></div></div><p><strong>Arguments</strong></p><ul><li><code>n_operators</code>: Number of distinct operators per site</li><li><code>n_sites</code>: Number of physical sites</li></ul><p><strong>Returns</strong></p><p>The smallest UInt type (UInt8, UInt16, UInt32, or UInt64) that can fit the encoding.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">select_uint_type(10, 4)    # UInt16
select_uint_type(100, 10)  # UInt16
select_uint_type(1000, 100) # UInt32</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/algebra.jl#L352-L381">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.site_bits-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Unsigned"><a class="docstring-binding" href="#NCTSSoS.site_bits-Union{Tuple{Type{T}}, Tuple{T}} where T&lt;:Unsigned"><code>NCTSSoS.site_bits</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">site_bits(::Type{T}) where {T&lt;:Unsigned} -&gt; Int</code></pre><p>Number of bits used for site encoding. Fixed at n/4 where n is bit width. Equivalently: <code>sizeof(T) * 8 ÷ 4 = sizeof(T) * 2</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">site_bits(UInt8)   # 2
site_bits(UInt16)  # 4
site_bits(UInt32)  # 8</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/algebra.jl#L255-L267">source</a></section></details></article><h3 id="Categories"><a class="docs-heading-anchor" href="#Categories">Categories</a><a id="Categories-1"></a><a class="docs-heading-anchor-permalink" href="#Categories" title="Permalink"></a></h3><p><code>NCTSSoS.jl</code> groups algebras by the <strong>normal form of monomials</strong> (i.e. what <code>simplify(m::Monomial)</code> returns):</p><ul><li><code>MonoidAlgebra</code>: normal form stays a single monomial (monoid ring viewpoint). [@monoidRing]</li><li><code>TwistedGroupAlgebra</code>: normal form is a scalar/phase times a monomial (twisted group algebra). [@twistedGroupAlgebra]</li><li><code>PBWAlgebra</code>: normal form can expand into a sum of monomials (PBW-type rewriting/normal ordering). [@pbwAlgebraOscar]</li></ul><h2 id="Variables"><a class="docs-heading-anchor" href="#Variables">Variables</a><a id="Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Variables" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="NCTSSoS.VariableRegistry"><a class="docstring-binding" href="#NCTSSoS.VariableRegistry"><code>NCTSSoS.VariableRegistry</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">VariableRegistry</code></pre><p>A registry that maps between variable symbols and their indices. Supports both contiguous (Vector-like) and sparse (Dict-based) indices.</p><p><strong>Fields</strong></p><ul><li><code>idx_to_variables::Dict{T, Symbol}</code>: Maps index to symbol</li><li><code>variables_to_idx::Dict{Symbol, T}</code>: Maps symbol to index</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = create_pauli_variables(1:2)
VariableRegistry with 6 variables: σx₁, σy₁, σz₁, σx₂, σy₂, σz₂

julia&gt; length(reg)
6

julia&gt; reg[1]  # Access by index
:σx₁

julia&gt; Int(reg[:σx₁])  # Access by symbol (convert typed index to Int for display)
1

julia&gt; :σx₁ in reg
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/registry.jl#L1-L28">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.getindex-Tuple{VariableRegistry, Symbol}"><a class="docstring-binding" href="#Base.getindex-Tuple{VariableRegistry, Symbol}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.getindex(reg::VariableRegistry, sym::Symbol) -&gt; Int</code></pre><p>Get the index of the given variable symbol.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/registry.jl#L144-L148">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.getindex-Union{Tuple{T}, Tuple{A}, Tuple{VariableRegistry{A, T}, Integer}} where {A, T}"><a class="docstring-binding" href="#Base.getindex-Union{Tuple{T}, Tuple{A}, Tuple{VariableRegistry{A, T}, Integer}} where {A, T}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.getindex(reg::VariableRegistry{A,T}, idx::Integer) -&gt; Symbol</code></pre><p>Get the variable symbol at the given index (converts to type T).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/registry.jl#L137-L141">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.getindex-Union{Tuple{T}, Tuple{A}, Tuple{VariableRegistry{A, T}, T}} where {A, T}"><a class="docstring-binding" href="#Base.getindex-Union{Tuple{T}, Tuple{A}, Tuple{VariableRegistry{A, T}, T}} where {A, T}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.getindex(reg::VariableRegistry{A,T}, idx::T) -&gt; Symbol</code></pre><p>Get the variable symbol at the given index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/registry.jl#L130-L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.in-Tuple{Symbol, VariableRegistry}"><a class="docstring-binding" href="#Base.in-Tuple{Symbol, VariableRegistry}"><code>Base.in</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.in(sym::Symbol, reg::VariableRegistry) -&gt; Bool</code></pre><p>Check if a variable symbol exists in the registry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/registry.jl#L151-L155">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.length-Tuple{VariableRegistry}"><a class="docstring-binding" href="#Base.length-Tuple{VariableRegistry}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.length(reg::VariableRegistry) -&gt; Int</code></pre><p>Return the number of variables in the registry.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/registry.jl#L123-L127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.show-Tuple{IO, VariableRegistry}"><a class="docstring-binding" href="#Base.show-Tuple{IO, VariableRegistry}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.show(io::IO, reg::VariableRegistry)</code></pre><p>Display a variable registry showing its variables in order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/registry.jl#L199-L203">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._create_noncommutative_variables-Union{Tuple{VT}, Tuple{T}, Tuple{A}, Tuple{Type{A}, Array{Tuple{String, VT}, 1}}} where {A&lt;:AlgebraType, T&lt;:Integer, VT&lt;:AbstractVector{T}}"><a class="docstring-binding" href="#NCTSSoS._create_noncommutative_variables-Union{Tuple{VT}, Tuple{T}, Tuple{A}, Tuple{Type{A}, Array{Tuple{String, VT}, 1}}} where {A&lt;:AlgebraType, T&lt;:Integer, VT&lt;:AbstractVector{T}}"><code>NCTSSoS._create_noncommutative_variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_create_noncommutative_variables(::Type{A}, prefix_subscripts::Vector{Tuple{String, VT}})</code></pre><p>Internal function to create variables with multiple prefixes and site-encoded grouped indices. Each tuple <code>(prefix, subscripts)</code> defines a group of variables with a specific prefix. Variables from each group are assigned to a distinct physical site (1-indexed by group order).</p><p><strong>Arguments</strong></p><ul><li><code>A</code>: The algebra type for the monomials</li><li><code>prefix_subscripts</code>: Vector of tuples, each containing a prefix string and subscript collection</li></ul><p><strong>Returns</strong></p><p>A tuple of:</p><ul><li><code>VariableRegistry</code>: Registry mapping symbols to encoded indices</li><li><code>monomial_groups</code>: Tuple of <code>Vector{NormalMonomial{A,T}}</code> for each prefix group</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create P₁, P₂, P₃ (site 1) and Q₄, Q₅ (site 2)
_create_noncommutative_variables(ProjectorAlgebra, [(&quot;P&quot;, 1:3), (&quot;Q&quot;, 4:5)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/registry.jl#L596-L617">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._select_pauli_type-Tuple{Int64}"><a class="docstring-binding" href="#NCTSSoS._select_pauli_type-Tuple{Int64}"><code>NCTSSoS._select_pauli_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_select_pauli_type(n_sites::Int) -&gt; Type{&lt;:Unsigned}</code></pre><p>Select smallest unsigned type for Pauli variables. Pauli uses contiguous indices: 3 operators per site (σx, σy, σz). Total indices = 3 * n_sites.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/registry.jl#L314-L320">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._select_signed_index_type-Tuple{Int64}"><a class="docstring-binding" href="#NCTSSoS._select_signed_index_type-Tuple{Int64}"><code>NCTSSoS._select_signed_index_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_select_signed_index_type(n::Int) -&gt; Type{&lt;:Signed}</code></pre><p>Select smallest signed type that can hold ±n (for fermionic/bosonic).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/registry.jl#L415-L419">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._subscript_string-Tuple{Int64}"><a class="docstring-binding" href="#NCTSSoS._subscript_string-Tuple{Int64}"><code>NCTSSoS._subscript_string</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_subscript_string(n::Int) -&gt; String</code></pre><p>Convert an integer to its Unicode subscript representation.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">_subscript_string(42)  # &quot;₄₂&quot;
_subscript_string(0)   # &quot;₀&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/registry.jl#L99-L109">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.create_bosonic_variables-Tuple{Any}"><a class="docstring-binding" href="#NCTSSoS.create_bosonic_variables-Tuple{Any}"><code>NCTSSoS.create_bosonic_variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_bosonic_variables(subscripts)</code></pre><p>Create a variable registry and monomials for bosonic creation (c⁺) and annihilation (c) operators.</p><p>Bosonic operators satisfy commutation relations:</p><ul><li>[cᵢ, cⱼ⁺] = δᵢⱼ (creation-annihilation)</li><li>[cᵢ, cⱼ] = 0 (annihilation-annihilation)</li><li>[cᵢ⁺, cⱼ⁺] = 0 (creation-creation)</li></ul><p><strong>Arguments</strong></p><ul><li><code>subscripts</code>: Subscript values for different modes/sites</li></ul><p><strong>Returns</strong></p><p>A tuple of:</p><ul><li><code>VariableRegistry</code>: Registry with both c and c⁺ operators for each subscript</li><li><code>(c, c⁺)</code>: Tuple of monomial vectors (annihilation, creation)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg, (c, c⁺) = create_bosonic_variables(1:2);

julia&gt; length(c)  # One annihilation per mode
2

julia&gt; c[1]  # monomial for c₁
NormalMonomial{BosonicAlgebra, Int8}(...)

julia&gt; :c₁ in reg  # annihilation operator
true

julia&gt; :c⁺₁ in reg  # creation operator
true</code></pre><p>Multiple modes:</p><pre><code class="language-julia-repl hljs">julia&gt; reg, (c, c⁺) = create_bosonic_variables(1:3);

julia&gt; length(c)
3

julia&gt; length(c⁺)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/registry.jl#L427-L472">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.create_fermionic_variables-Tuple{Any}"><a class="docstring-binding" href="#NCTSSoS.create_fermionic_variables-Tuple{Any}"><code>NCTSSoS.create_fermionic_variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_fermionic_variables(subscripts)</code></pre><p>Create a variable registry and monomials for fermionic creation (a⁺) and annihilation (a) operators.</p><p>Fermionic operators satisfy anticommutation relations:</p><ul><li>{aᵢ, aⱼ⁺} = δᵢⱼ (creation-annihilation)</li><li>{aᵢ, aⱼ} = 0 (annihilation-annihilation)</li><li>{aᵢ⁺, aⱼ⁺} = 0 (creation-creation)</li></ul><p><strong>Arguments</strong></p><ul><li><code>subscripts</code>: Subscript values for different modes/sites</li></ul><p><strong>Returns</strong></p><p>A tuple of:</p><ul><li><code>VariableRegistry</code>: Registry with both a and a⁺ operators for each subscript</li><li><code>(a, a⁺)</code>: Tuple of monomial vectors (annihilation, creation)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg, (a, a⁺) = create_fermionic_variables(1:2);

julia&gt; length(a)  # One annihilation per mode
2

julia&gt; a[1]  # monomial for a₁
NormalMonomial{FermionicAlgebra, Int8}(...)

julia&gt; :a₁ in reg  # annihilation operator
true

julia&gt; :a⁺₁ in reg  # creation operator
true</code></pre><p>Multiple modes:</p><pre><code class="language-julia-repl hljs">julia&gt; reg, (a, a⁺) = create_fermionic_variables(1:3);

julia&gt; length(a)
3

julia&gt; length(a⁺)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/registry.jl#L329-L374">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.create_noncommutative_variables-Union{Tuple{Array{Tuple{String, VT}, 1}}, Tuple{VT}, Tuple{T}} where {T&lt;:Integer, VT&lt;:AbstractVector{T}}"><a class="docstring-binding" href="#NCTSSoS.create_noncommutative_variables-Union{Tuple{Array{Tuple{String, VT}, 1}}, Tuple{VT}, Tuple{T}} where {T&lt;:Integer, VT&lt;:AbstractVector{T}}"><code>NCTSSoS.create_noncommutative_variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_noncommutative_variables(prefix_subscripts::Vector{Tuple{String, VT}})</code></pre><p>Create a variable registry and monomials for generic non-commutative variables.</p><p>Non-commutative variables have no simplification rules - word order is preserved exactly as given.</p><p><strong>Arguments</strong></p><ul><li><code>prefix_subscripts</code>: Vector of <code>(prefix, subscripts)</code> tuples for multi-prefix creation</li></ul><p><strong>Returns</strong></p><p>A tuple of:</p><ul><li><code>VariableRegistry</code>: Registry with non-commutative variables for each subscript</li><li><code>monomial_groups</code>: Tuple of monomial vectors, one per prefix group</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg, (x,) = create_noncommutative_variables([(&quot;x&quot;, 1:3)]);

julia&gt; length(x)
3

julia&gt; x[1]  # monomial for x₁
NormalMonomial{NonCommutativeAlgebra, UInt8}(...)

julia&gt; reg, (x, y) = create_noncommutative_variables([(&quot;x&quot;, 1:2), (&quot;y&quot;, 3:4)]);

julia&gt; length(x), length(y)
(2, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/registry.jl#L558-L589">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.create_pauli_variables-Tuple{Any}"><a class="docstring-binding" href="#NCTSSoS.create_pauli_variables-Tuple{Any}"><code>NCTSSoS.create_pauli_variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_pauli_variables(subscripts)</code></pre><p>Create a variable registry and monomials for Pauli spin matrices σx, σy, σz.</p><p>Pauli matrices satisfy:</p><ul><li>σᵢ² = 1 (each Pauli matrix squares to identity)</li><li>{σᵢ, σⱼ} = 2δᵢⱼ (anticommutation relation)</li></ul><p>The operators are always x, y, z components. This function creates variables for each subscript value.</p><p><strong>Variable Ordering:</strong> Variables are ordered by site first, then by Pauli type (x, y, z). This enables efficient encoding: for index <code>idx</code>, site = <code>(idx - 1) ÷ 3 + 1</code>, pauli_type = <code>(idx - 1) % 3</code> (0=X, 1=Y, 2=Z).</p><p><strong>Arguments</strong></p><ul><li><code>subscripts</code>: Subscript values for different qubits/sites</li></ul><p><strong>Returns</strong></p><p>A tuple of:</p><ul><li><code>VariableRegistry</code>: Registry with Pauli variables σx, σy, σz for each subscript</li><li><code>(σx, σy, σz)</code>: Tuple of monomial vectors grouped by Pauli type</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg, (σx, σy, σz) = create_pauli_variables(1:2);

julia&gt; length(σx)  # One σx per site
2

julia&gt; σx[1]  # monomial for σx₁
NormalMonomial{PauliAlgebra, UInt8}(...)

julia&gt; :σx₁ in reg
true

julia&gt; Int(reg[:σx₁])  # Index 1: site 1, type X
1</code></pre><p>Single qubit:</p><pre><code class="language-julia-repl hljs">julia&gt; reg, (σx, σy, σz) = create_pauli_variables([1]);

julia&gt; length(σx)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/registry.jl#L223-L271">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.create_projector_variables-Union{Tuple{Array{Tuple{String, VT}, 1}}, Tuple{VT}, Tuple{T}} where {T&lt;:Integer, VT&lt;:AbstractVector{T}}"><a class="docstring-binding" href="#NCTSSoS.create_projector_variables-Union{Tuple{Array{Tuple{String, VT}, 1}}, Tuple{VT}, Tuple{T}} where {T&lt;:Integer, VT&lt;:AbstractVector{T}}"><code>NCTSSoS.create_projector_variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_projector_variables(prefix_subscripts::Vector{Tuple{String, VT}})</code></pre><p>Create a variable registry and monomials for projector operators.</p><p>Projector operators satisfy:</p><ul><li>Pi^2 = Pi (idempotency: projectors square to themselves)</li></ul><p>Projectors are self-adjoint and commutativity is NOT enforced.</p><p><strong>Arguments</strong></p><ul><li><code>prefix_subscripts</code>: Vector of <code>(prefix, subscripts)</code> tuples for multi-prefix creation</li></ul><p><strong>Returns</strong></p><p>A tuple of:</p><ul><li><code>VariableRegistry</code>: Registry with projector variables for each subscript</li><li><code>monomial_groups</code>: Tuple of monomial vectors, one per prefix group</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg, (P,) = create_projector_variables([(&quot;P&quot;, 1:3)]);

julia&gt; length(P)
3

julia&gt; P[1]  # monomial for P₁
NormalMonomial{ProjectorAlgebra, UInt8}(...)

julia&gt; reg, (P, Q) = create_projector_variables([(&quot;P&quot;, 1:2), (&quot;Q&quot;, 3:4)]);

julia&gt; length(P), length(Q)
(2, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/registry.jl#L475-L508">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.create_unipotent_variables-Union{Tuple{Array{Tuple{String, VT}, 1}}, Tuple{VT}, Tuple{T}} where {T&lt;:Integer, VT&lt;:AbstractVector{T}}"><a class="docstring-binding" href="#NCTSSoS.create_unipotent_variables-Union{Tuple{Array{Tuple{String, VT}, 1}}, Tuple{VT}, Tuple{T}} where {T&lt;:Integer, VT&lt;:AbstractVector{T}}"><code>NCTSSoS.create_unipotent_variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_unipotent_variables(prefix_subscripts::Vector{Tuple{String, VT}})</code></pre><p>Create a variable registry and monomials for unipotent operators.</p><p>Unipotent operators satisfy:</p><ul><li>U^2 = I (squares to identity)</li></ul><p>This is simpler than Pauli algebra - no cyclic products or cross-operator interactions.</p><p><strong>Arguments</strong></p><ul><li><code>prefix_subscripts</code>: Vector of <code>(prefix, subscripts)</code> tuples for multi-prefix creation</li></ul><p><strong>Returns</strong></p><p>A tuple of:</p><ul><li><code>VariableRegistry</code>: Registry with unipotent variables for each subscript</li><li><code>monomial_groups</code>: Tuple of monomial vectors, one per prefix group</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg, (U,) = create_unipotent_variables([(&quot;U&quot;, 1:3)]);

julia&gt; length(U)
3

julia&gt; U[1]  # monomial for U₁
NormalMonomial{UnipotentAlgebra, UInt8}(...)

julia&gt; reg, (U, V) = create_unipotent_variables([(&quot;U&quot;, 1:2), (&quot;V&quot;, 3:4)]);

julia&gt; length(U), length(V)
(2, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/registry.jl#L517-L551">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.indices-Tuple{VariableRegistry}"><a class="docstring-binding" href="#NCTSSoS.indices-Tuple{VariableRegistry}"><code>NCTSSoS.indices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">indices(reg::VariableRegistry{A,T}) -&gt; Vector{T}</code></pre><p>Return all indices in sorted order.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = create_projector_variables(1:3)
VariableRegistry with 3 variables: P₁, P₂, P₃

julia&gt; indices(reg)
3-element Vector{UInt8}:
 0x01
 0x02
 0x03</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/registry.jl#L180-L196">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.subregistry-Union{Tuple{VT}, Tuple{T}, Tuple{A}, Tuple{VariableRegistry{A, T}, VT}} where {A&lt;:AlgebraType, T&lt;:Integer, VT&lt;:AbstractVector{T}}"><a class="docstring-binding" href="#NCTSSoS.subregistry-Union{Tuple{VT}, Tuple{T}, Tuple{A}, Tuple{VariableRegistry{A, T}, VT}} where {A&lt;:AlgebraType, T&lt;:Integer, VT&lt;:AbstractVector{T}}"><code>NCTSSoS.subregistry</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">subregistry(reg::VariableRegistry{A,T}, subset_indices::VT) where {A,T,VT&lt;:AbstractVector{T}}</code></pre><p>Create a new VariableRegistry containing only the specified subset of indices.</p><p>This is useful for creating clique-local registries for basis generation in correlative sparsity decomposition.</p><p><strong>Arguments</strong></p><ul><li><code>reg::VariableRegistry{A,T}</code>: The parent registry</li><li><code>subset_indices::AbstractVector{T}</code>: Indices to include in the sub-registry (must match registry&#39;s index type)</li></ul><p><strong>Returns</strong></p><p>A new <code>VariableRegistry{A,T}</code> containing only the variables at the specified indices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg, (x,) = create_noncommutative_variables([(&quot;x&quot;, 1:5)]);

julia&gt; sorted_idxs = sort(collect(keys(reg.idx_to_variables)));

julia&gt; sub_reg = subregistry(reg, sorted_idxs[1:3]);

julia&gt; length(sub_reg)
3</code></pre><p><strong>Notes</strong></p><ul><li>Indices not present in the parent registry are silently ignored</li><li>The returned registry has the same algebra type as the parent</li><li>This is a copy operation, not a view - modifications to the sub-registry do not affect the parent registry</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/registry.jl#L48-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.symbols-Tuple{VariableRegistry}"><a class="docstring-binding" href="#NCTSSoS.symbols-Tuple{VariableRegistry}"><code>NCTSSoS.symbols</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">symbols(reg::VariableRegistry) -&gt; Vector{Symbol}</code></pre><p>Return all symbols in index-sorted order.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = create_projector_variables(1:3)
VariableRegistry with 3 variables: P₁, P₂, P₃

julia&gt; symbols(reg)
3-element Vector{Symbol}:
 :P₁
 :P₂
 :P₃</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/registry.jl#L158-L174">source</a></section></details></article><h2 id="Monomials"><a class="docs-heading-anchor" href="#Monomials">Monomials</a><a id="Monomials-1"></a><a class="docs-heading-anchor-permalink" href="#Monomials" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="NCTSSoS.SUPERSCRIPT_EXPONENTS"><a class="docstring-binding" href="#NCTSSoS.SUPERSCRIPT_EXPONENTS"><code>NCTSSoS.SUPERSCRIPT_EXPONENTS</code></a> — <span class="docstring-category">Constant</span></summary><section><div><pre><code class="language-julia hljs">SUPERSCRIPT_EXPONENTS::Dict{Int,String}</code></pre><p>Module-level constant mapping small exponents (2-9) to Unicode superscript characters.</p><p>Used by <code>Base.show</code> to display repeated variables with exponents (e.g., <code>x³</code> instead of <code>x^3</code>). Avoids allocation in the display loop. Exponents outside this range fall back to <code>^n</code> notation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/monomial.jl#L167-L174">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.AbstractMonomial"><a class="docstring-binding" href="#NCTSSoS.AbstractMonomial"><code>NCTSSoS.AbstractMonomial</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractMonomial{A&lt;:AlgebraType, T&lt;:Integer}</code></pre><p>Abstract supertype for all monomial types, parameterized by algebra type and integer type.</p><p>The type hierarchy is:</p><pre><code class="language-julia hljs">AbstractTensorMonomial{As}
├── AbstractMonomial{A,T}                 # Single-algebra monomials (As == Tuple{A})
│   ├── NormalMonomial{A,T}               # Bare word (always in canonical form)
│   ├── Monomial{A,T,C,W}                 # User-facing wrapper (coeff + word(s))
│   ├── StateSymbol{ST,A,T}               # State expectation symbol (in src/states/)
│   └── StateWord{ST,A,T}                 # Product of state symbols (in src/states/)
└── ComposedMonomial{As,Ts}               # Multi-algebra tensor monomial (in composed.jl)</code></pre><p><strong>Interface</strong></p><p>All subtypes should implement:</p><ul><li><code>degree(m)</code>: Return total degree (number of operators)</li><li><code>variable_indices(m)</code>: Return set of variable indices present</li><li><code>Base.isless(m1, m2)</code>: Ordering for sorting</li><li><code>Base.:(==)(m1, m2)</code>: Equality comparison</li><li><code>Base.hash(m, h)</code>: Hash function</li></ul><p>See also: <a href="#NCTSSoS.NormalMonomial"><code>NormalMonomial</code></a>, <a href="#NCTSSoS.AbstractTensorMonomial"><code>AbstractTensorMonomial</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/monomial.jl#L43-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.AbstractTensorMonomial"><a class="docstring-binding" href="#NCTSSoS.AbstractTensorMonomial"><code>NCTSSoS.AbstractTensorMonomial</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractTensorMonomial{As&lt;:Tuple}</code></pre><p>Abstract supertype for monomials living in an <strong>ordered tensor-product algebra</strong> <code>⊗_{i} As[i]</code>.</p><p>The signature <code>As</code> is <strong>semantic and ordered</strong>: <code>Tuple{PauliAlgebra,FermionicAlgebra}</code> is different from <code>Tuple{FermionicAlgebra,PauliAlgebra}</code>.</p><p>This type exists to enable signature-level multiple dispatch without wrapper objects.</p><p>See also: <a href="#NCTSSoS.AbstractMonomial"><code>AbstractMonomial</code></a>, <a href="#NCTSSoS.ComposedMonomial"><code>ComposedMonomial</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/monomial.jl#L26-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.NormalMonomial"><a class="docstring-binding" href="#NCTSSoS.NormalMonomial"><code>NCTSSoS.NormalMonomial</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NormalMonomial{A&lt;:AlgebraType, T&lt;:Integer} &lt;: AbstractMonomial{A,T}</code></pre><p>Represents an immutable monomial in word representation for non-commutative algebras. The word vector represents a product of operators (e.g., [1,3,1,3] = xzxz).</p><p><strong>Fields</strong></p><ul><li><code>word::Vector{T}</code>: The monomial representation word</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>A&lt;:AlgebraType</code>: Algebra type for dispatch (PauliAlgebra, FermionicAlgebra, etc.)</li><li><code>T&lt;:Integer</code>: Integer type for the monomial vector<ul><li><code>UInt16</code>: For self-adjoint variables (Pauli, Projector, Unipotent)</li><li><code>Int32</code>: For non-self-adjoint variables (Fermionic, Bosonic)</li></ul></li></ul><p><strong>Design</strong></p><p>The algebra type is in the type parameter, enabling:</p><ul><li>Zero per-element overhead (no runtime metadata)</li><li>Compile-time dispatch for multiplication/simplification</li><li>Type safety: can&#39;t accidentally multiply incompatible algebras</li></ul><p>The struct is immutable for safety - simplification operations return new monomials rather than mutating existing ones.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m1 = NormalMonomial{PauliAlgebra}([1, 3, 1, 3]);

julia&gt; m1.word
4-element Vector{Int64}:
 1
 3
 1
 3

julia&gt; typeof(m1)
NormalMonomial{PauliAlgebra, Int64}</code></pre><p>Different algebra types:</p><pre><code class="language-julia-repl hljs">julia&gt; m_pauli = NormalMonomial{PauliAlgebra}(UInt16[1, 2, 3]);

julia&gt; typeof(m_pauli)
NormalMonomial{PauliAlgebra, UInt16}

julia&gt; m_fermi = NormalMonomial{FermionicAlgebra}(Int32[-1, 2, -3]);

julia&gt; typeof(m_fermi)
NormalMonomial{FermionicAlgebra, Int32}</code></pre><p>Equality comparison:</p><pre><code class="language-julia-repl hljs">julia&gt; m1 = NormalMonomial{PauliAlgebra}([1, 3, 1, 3]);

julia&gt; m2 = NormalMonomial{PauliAlgebra}([1, 3, 1, 2]);

julia&gt; m1 == m2
false

julia&gt; m3 = NormalMonomial{PauliAlgebra}([1, 3, 1, 3]);

julia&gt; m1 == m3
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/monomial.jl#L186-L252">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:==-Union{Tuple{T2}, Tuple{T1}, Tuple{A2}, Tuple{A1}, Tuple{NormalMonomial{A1, T1}, NormalMonomial{A2, T2}}} where {A1, A2, T1, T2}"><a class="docstring-binding" href="#Base.:==-Union{Tuple{T2}, Tuple{T1}, Tuple{A2}, Tuple{A1}, Tuple{NormalMonomial{A1, T1}, NormalMonomial{A2, T2}}} where {A1, A2, T1, T2}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(==)(m1::NormalMonomial, m2::NormalMonomial) -&gt; Bool</code></pre><p>Equality comparison for monomials. Monomials of different algebra types are never equal (type-level distinction).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/monomial.jl#L265-L270">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.hash-Union{Tuple{A}, Tuple{NormalMonomial{A}, UInt64}} where A"><a class="docstring-binding" href="#Base.hash-Union{Tuple{A}, Tuple{NormalMonomial{A}, UInt64}} where A"><code>Base.hash</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.hash(m::NormalMonomial, h::UInt) -&gt; UInt</code></pre><p>Hash function for NormalMonomial. Includes algebra type for consistency with equality.</p><p>The hash includes both the algebra type <code>A</code> and the word vector, ensuring that monomials from different algebras with the same word have different hashes. This maintains the hash/equality contract: if <code>m1 == m2</code>, then <code>hash(m1) == hash(m2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/monomial.jl#L275-L283">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.isless-Union{Tuple{T}, Tuple{A}, Tuple{NormalMonomial{A, T}, NormalMonomial{A, T}}} where {A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.isless-Union{Tuple{T}, Tuple{A}, Tuple{NormalMonomial{A, T}, NormalMonomial{A, T}}} where {A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.isless(m1::NormalMonomial{A,T}, m2::NormalMonomial{A,T}) where {A,T} -&gt; Bool</code></pre><p>Compare two monomials of the same algebra type using degree-first (graded) ordering, then lexicographic ordering on the word vector for monomials of equal degree.</p><p>This ordering is required for:</p><ul><li>Sorting polynomials (terms are stored in sorted order)</li><li>Binary search in polynomial operations</li><li>Consistent canonical forms</li></ul><p><strong>Ordering Rules</strong></p><ol><li><strong>Degree-first</strong>: Shorter monomials come before longer ones</li><li><strong>Lexicographic</strong>: For same-degree monomials, compare word vectors element-by-element</li></ol><p><strong>Type Safety</strong></p><p>Only monomials of the same algebra type <code>A</code> and integer type <code>T</code> can be compared. Attempting to compare monomials of different algebra types will result in a <code>MethodError</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m1 = NormalMonomial{PauliAlgebra}([1]);

julia&gt; m2 = NormalMonomial{PauliAlgebra}([1, 2]);

julia&gt; isless(m1, m2)  # degree 1 &lt; degree 2
true

julia&gt; m3 = NormalMonomial{PauliAlgebra}([2]);

julia&gt; isless(m1, m3)  # same degree, [1] &lt; [2] lexicographically
true

julia&gt; isless(m3, m1)
false</code></pre><p>Sorting works correctly:</p><pre><code class="language-julia-repl hljs">julia&gt; monos = [NormalMonomial{PauliAlgebra}([2]), NormalMonomial{PauliAlgebra}([1, 2]), NormalMonomial{PauliAlgebra}([1])];

julia&gt; sort!(monos);

julia&gt; [m.word for m in monos]
3-element Vector{Vector{Int64}}:
 [1]
 [2]
 [1, 2]</code></pre><p>See also: <a href="#NCTSSoS.degree-Tuple{NormalMonomial}"><code>degree</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/monomial.jl#L369-L420">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.isone-Tuple{NormalMonomial}"><a class="docstring-binding" href="#Base.isone-Tuple{NormalMonomial}"><code>Base.isone</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.isone(m::NormalMonomial) -&gt; Bool</code></pre><p>Check if a monomial is the multiplicative identity (empty word).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m_identity = NormalMonomial{PauliAlgebra}(Int[]);

julia&gt; isone(m_identity)
true

julia&gt; m_not_identity = NormalMonomial{PauliAlgebra}([1, 2]);

julia&gt; isone(m_not_identity)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/monomial.jl#L312-L329">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.iterate-Union{Tuple{NormalMonomial{A, T}}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.iterate-Union{Tuple{NormalMonomial{A, T}}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.iterate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.iterate(m::NormalMonomial{A,T}) where {A,T}
Base.iterate(m::NormalMonomial{A,T}, state) where {A,T}</code></pre><p>Iterate a NormalMonomial, yielding a single <code>(coefficient, NormalMonomial)</code> pair.</p><p>The coefficient is <code>one(coeff_type(A))</code> since NormalMonomial represents a bare word with unit coefficient. This enables uniform iteration over both NormalMonomial (single term) and Polynomial (multiple terms) in algorithms that process bases of monomials.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m = NormalMonomial{PauliAlgebra}([1, 2]);

julia&gt; for (coef, mono) in m
           println(&quot;Coefficient: $coef, Word: $(mono.word)&quot;)
       end
Coefficient: 1.0 + 0.0im, Word: [1, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/monomial.jl#L539-L561">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.one-Tuple{Type{NormalMonomial}}"><a class="docstring-binding" href="#Base.one-Tuple{Type{NormalMonomial}}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.one(::Type{NormalMonomial}) -&gt; NormalMonomial{NonCommutativeAlgebra,UInt}</code></pre><p>Create the identity monomial (empty word) for the generic NormalMonomial type. This fallback is needed for code that uses <code>one(NormalMonomial)</code> without type parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/monomial.jl#L361-L366">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.one-Union{Tuple{NormalMonomial{A, T}}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.one-Union{Tuple{NormalMonomial{A, T}}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.one(m::NormalMonomial{A,T}) where {A,T}</code></pre><p>Create the identity monomial for the same type as <code>m</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/monomial.jl#L352-L356">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.one-Union{Tuple{Type{NormalMonomial{A, T}}}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.one-Union{Tuple{Type{NormalMonomial{A, T}}}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.one(::Type{NormalMonomial{A,T}}) where {A&lt;:AlgebraType, T&lt;:Integer}</code></pre><p>Create the identity monomial (empty word).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m_one = one(NormalMonomial{PauliAlgebra,Int64});

julia&gt; isone(m_one)
true

julia&gt; m_one.word
Int64[]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/monomial.jl#L332-L347">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.show-Union{Tuple{T}, Tuple{A}, Tuple{IO, NormalMonomial{A, T}}} where {A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.show-Union{Tuple{T}, Tuple{A}, Tuple{IO, NormalMonomial{A, T}}} where {A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.show(io::IO, m::NormalMonomial{A,T}) where {A,T}</code></pre><p>Display a monomial. If a <code>:registry</code> is present in the IOContext, uses symbol names from the registry. Otherwise, falls back to displaying raw indices.</p><p>When using a registry, consecutive identical variables are displayed with exponents:</p><ul><li><code>[1, 1, 1]</code> with index 1 mapping to <code>:x</code> displays as <code>x³</code></li><li><code>[1, 2, 2]</code> displays as <code>x₁y₂²</code></li><li><code>[1, 1, 2, 2, 2]</code> displays as <code>x₁²y₂³</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Without registry (raw indices)
julia&gt; m = NormalMonomial{PauliAlgebra}([1, 2, 3]);
julia&gt; show(stdout, m)
[1, 2, 3]

# With registry (symbolic names)
julia&gt; reg, (σx, σy, σz) = create_pauli_variables(1:2);
julia&gt; m = σx[1] * σy[1];
julia&gt; show(IOContext(stdout, :registry =&gt; reg), m)
σx₁σy₁

# With exponents for repeated variables
julia&gt; m = NormalMonomial{PauliAlgebra}([1, 1, 1]);
julia&gt; show(IOContext(stdout, :registry =&gt; reg), m)
σx₁³</code></pre><p>See also: <a href="#NCTSSoS.VariableRegistry"><code>VariableRegistry</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/monomial.jl#L437-L468">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._eq_same_algebra-Union{Tuple{A2}, Tuple{A1}, Tuple{Type{A1}, Type{A2}, Any, Any}} where {A1&lt;:AlgebraType, A2&lt;:AlgebraType}"><a class="docstring-binding" href="#NCTSSoS._eq_same_algebra-Union{Tuple{A2}, Tuple{A1}, Tuple{Type{A1}, Type{A2}, Any, Any}} where {A1&lt;:AlgebraType, A2&lt;:AlgebraType}"><code>NCTSSoS._eq_same_algebra</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_eq_same_algebra(::Type{A1}, ::Type{A2}, x1, x2) -&gt; Bool</code></pre><p>Internal helper for type-safe equality comparison across algebra types.</p><p>Returns <code>false</code> immediately if <code>A1 !== A2</code> (different algebra types are never equal), otherwise delegates to <code>x1 == x2</code> for the actual payload comparison.</p><p>This ensures monomials from different algebras with identical word vectors are correctly distinguished (e.g., Pauli <code>[1,2]</code> ≠ Fermionic <code>[1,2]</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/monomial.jl#L75-L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._hash_with_algebra-Union{Tuple{A}, Tuple{Type{A}, Any, UInt64}} where A&lt;:AlgebraType"><a class="docstring-binding" href="#NCTSSoS._hash_with_algebra-Union{Tuple{A}, Tuple{Type{A}, Any, UInt64}} where A&lt;:AlgebraType"><code>NCTSSoS._hash_with_algebra</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_hash_with_algebra(::Type{A}, payload, h::UInt) -&gt; UInt</code></pre><p>Internal helper that incorporates the algebra type <code>A</code> into the hash.</p><p>This maintains the hash/equality contract: since monomials from different algebras are never equal (even with identical payloads), their hashes must also differ. The algebra type is hashed first, then combined with the payload hash.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/monomial.jl#L91-L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._validate_word-Union{Tuple{T}, Tuple{A}, Tuple{Type{A}, Vector{T}}} where {A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#NCTSSoS._validate_word-Union{Tuple{T}, Tuple{A}, Tuple{Type{A}, Vector{T}}} where {A&lt;:AlgebraType, T&lt;:Integer}"><code>NCTSSoS._validate_word</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_validate_word(::Type{A}, word::Vector{T}) where {A&lt;:AlgebraType,T&lt;:Integer}</code></pre><p>Validate that <code>word</code> is already in the algebra-specific normal form for <code>A</code>.</p><p>This is called by the <code>NormalMonomial{A,T}</code> constructor to enforce the invariant: <strong>a <code>NormalMonomial</code> is always in normal form</strong>.</p><p>Algebra-specific methods are defined in <code>src/simplification/*.jl</code>. The default implementation throws an error for unimplemented algebras.</p><p><strong>Throws</strong></p><ul><li><code>ErrorException</code> if no validation method is defined for algebra <code>A</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/monomial.jl#L149-L162">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.algebra_type-Union{Tuple{Type{&lt;:AbstractMonomial{A}}}, Tuple{A}} where A&lt;:AlgebraType"><a class="docstring-binding" href="#NCTSSoS.algebra_type-Union{Tuple{Type{&lt;:AbstractMonomial{A}}}, Tuple{A}} where A&lt;:AlgebraType"><code>NCTSSoS.algebra_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">algebra_type(::Type{&lt;:AbstractMonomial{A}}) where {A&lt;:AlgebraType} -&gt; Type{A}
algebra_type(m::AbstractMonomial) -&gt; Type{A}</code></pre><p>Return the algebra type parameter for a monomial type or instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/monomial.jl#L136-L141">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.coeff_type-Union{Tuple{Type{&lt;:AbstractMonomial{A}}}, Tuple{A}} where A&lt;:AlgebraType"><a class="docstring-binding" href="#NCTSSoS.coeff_type-Union{Tuple{Type{&lt;:AbstractMonomial{A}}}, Tuple{A}} where A&lt;:AlgebraType"><code>NCTSSoS.coeff_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">coeff_type(::Type{T}) -&gt; Type{&lt;:Number}
coeff_type(x) -&gt; Type{&lt;:Number}</code></pre><p>Return the coefficient type for a simplify result type.</p><p>This enables compile-time determination of coefficient types for type-stable processing of simplification results. Used by <code>ComposedMonomial</code> simplification to determine appropriate coefficient types for the Cartesian product of terms.</p><p>For <code>NormalMonomial{A,T}</code>, returns <code>coeff_type(A)</code> (the algebra&#39;s default). For <code>Polynomial{A,T,C}</code>, returns <code>C</code> (the explicit coefficient type).</p><p>This method is shared by <code>NormalMonomial</code>, simplified <code>Monomial</code> expansions, and state monomials (<code>StateSymbol</code>, <code>StateWord</code>) that carry the same algebra type parameter.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; coeff_type(NormalMonomial{PauliAlgebra,Int64})
ComplexF64

julia&gt; coeff_type(NormalMonomial{FermionicAlgebra,Int32})
Float64

julia&gt; coeff_type(Polynomial{BosonicAlgebra,Int32,Float64})
Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/monomial.jl#L103-L132">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.degree-Tuple{NormalMonomial}"><a class="docstring-binding" href="#NCTSSoS.degree-Tuple{NormalMonomial}"><code>NCTSSoS.degree</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">degree(m::NormalMonomial) -&gt; Int</code></pre><p>Compute the total degree of a monomial (length of word vector). For non-commutative monomials in word representation, this is the number of operators.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m1 = NormalMonomial([1, 3, 1, 3]);

julia&gt; degree(m1)
4

julia&gt; m2 = NormalMonomial([2, 2, 2]);

julia&gt; degree(m2)
3

julia&gt; m_zero = NormalMonomial(Int[]);

julia&gt; degree(m_zero)
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/monomial.jl#L286-L309">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.monomials-Union{Tuple{NormalMonomial{A, T}}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#NCTSSoS.monomials-Union{Tuple{NormalMonomial{A, T}}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer}"><code>NCTSSoS.monomials</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">monomials(m::NormalMonomial{A,T}) where {A,T} -&gt; Vector{NormalMonomial{A,T}}</code></pre><p>Return a single-element vector containing the monomial.</p><p>This provides compatibility with the <code>monomials</code> function for Polynomials, allowing uniform iteration over monomials regardless of input type.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m = NormalMonomial{PauliAlgebra}([1, 2]);

julia&gt; monomials(m)
1-element Vector{NormalMonomial{PauliAlgebra, Int64}}:
 NormalMonomial{PauliAlgebra, Int64}([1, 2])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/monomial.jl#L514-L532">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.ComposedMonomial"><a class="docstring-binding" href="#NCTSSoS.ComposedMonomial"><code>NCTSSoS.ComposedMonomial</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ComposedMonomial{As&lt;:Tuple,Ts&lt;:Tuple} &lt;: AbstractTensorMonomial{As}</code></pre><p>Represents a product of monomials from different algebra types.</p><p>Each component is a <code>NormalMonomial{A,T}</code> with its own algebra type in the type parameter. This enables tensor products of operators from different algebraic structures.</p><p><strong>Fields</strong></p><ul><li><code>components::Ts</code>: Tuple of monomials, e.g., <code>(NormalMonomial{PauliAlgebra}, NormalMonomial{FermionicAlgebra})</code></li></ul><p><strong>Type Parameters</strong></p><ul><li><code>As&lt;:Tuple</code>: Ordered algebra signature, e.g. <code>Tuple{PauliAlgebra,FermionicAlgebra}</code></li><li><code>Ts&lt;:Tuple</code>: Tuple type of the component monomials</li></ul><p><strong>Design</strong></p><p>Algebra types are compile-time information (in each monomial&#39;s type parameter), so <code>ComposedMonomial</code> has zero runtime overhead for algebra type storage.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m_pauli = NormalMonomial{PauliAlgebra}(UInt16[1, 4, 7]);  # σx on sites 1,2,3

julia&gt; m_fermi = NormalMonomial{FermionicAlgebra}(Int32[-1, 2]);

julia&gt; cm = ComposedMonomial((m_pauli, m_fermi));

julia&gt; length(cm)
2

julia&gt; degree(cm)
5

julia&gt; cm[1] === m_pauli
true</code></pre><p>Simplification dispatches to each component&#39;s algebra and returns a vector of <code>(coefficient, ComposedMonomial)</code> pairs:</p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; using NCTSSoS: encode_index

julia&gt; m_pauli = NormalMonomial{PauliAlgebra}(UInt16[1, 4]);  # σx on sites 1,2

julia&gt; m_unip = NormalMonomial{UnipotentAlgebra}(UInt16[encode_index(UInt16, 1, 1), encode_index(UInt16, 1, 1), encode_index(UInt16, 2, 1)]);

julia&gt; cm = ComposedMonomial((m_pauli, m_unip));

julia&gt; terms = simplify(cm);

julia&gt; terms[1][1]
1.0 + 0.0im

julia&gt; terms[1][2][1].word == UInt16[1, 4]  # Pauli component stays canonical
true

julia&gt; terms[1][2][2].word == [encode_index(UInt16, 2, 1)]  # Unipotent: [1,1,2] -&gt; [2]
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/composed.jl#L105-L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:==-Union{Tuple{Ts2}, Tuple{As2}, Tuple{Ts1}, Tuple{As1}, Tuple{ComposedMonomial{As1, Ts1}, ComposedMonomial{As2, Ts2}}} where {As1, Ts1, As2, Ts2}"><a class="docstring-binding" href="#Base.:==-Union{Tuple{Ts2}, Tuple{As2}, Tuple{Ts1}, Tuple{As1}, Tuple{ComposedMonomial{As1, Ts1}, ComposedMonomial{As2, Ts2}}} where {As1, Ts1, As2, Ts2}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(==)(cm1::ComposedMonomial, cm2::ComposedMonomial) -&gt; Bool</code></pre><p>Equality check via component-wise comparison.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/composed.jl#L111-L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.getindex-Tuple{ComposedMonomial, Int64}"><a class="docstring-binding" href="#Base.getindex-Tuple{ComposedMonomial, Int64}"><code>Base.getindex</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.getindex(cm::ComposedMonomial, i::Int) -&gt; NormalMonomial</code></pre><p>Access the i-th component monomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/composed.jl#L185-L189">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.hash-Tuple{ComposedMonomial, UInt64}"><a class="docstring-binding" href="#Base.hash-Tuple{ComposedMonomial, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.hash(cm::ComposedMonomial, h::UInt) -&gt; UInt</code></pre><p>Hash function computed from components.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/composed.jl#L124-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.isless-Union{Tuple{Ts}, Tuple{As}, Tuple{ComposedMonomial{As, Ts}, ComposedMonomial{As, Ts}}} where {As&lt;:Tuple, Ts&lt;:Tuple}"><a class="docstring-binding" href="#Base.isless-Union{Tuple{Ts}, Tuple{As}, Tuple{ComposedMonomial{As, Ts}, ComposedMonomial{As, Ts}}} where {As&lt;:Tuple, Ts&lt;:Tuple}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.isless(cm1::ComposedMonomial{As,Ts}, cm2::ComposedMonomial{As,Ts}) where {As&lt;:Tuple,Ts&lt;:Tuple}</code></pre><p>Compare two ComposedMonomials using degree-first ordering, then component-wise lexicographic.</p><p>This ordering enables sorting ComposedMonomials for polynomial operations.</p><p><strong>Algorithm</strong></p><ol><li>Compare total degrees (degree-first ordering)</li><li>If degrees equal, compare components lexicographically using their isless</li></ol><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m1 = NormalMonomial{PauliAlgebra}(UInt16[1]);

julia&gt; m2 = NormalMonomial{PauliAlgebra}(UInt16[1, 2]);

julia&gt; m3 = NormalMonomial{FermionicAlgebra}(Int32[1]);

julia&gt; cm1 = ComposedMonomial((m1, m3));  # degree 2

julia&gt; cm2 = ComposedMonomial((m2, m3));  # degree 3

julia&gt; isless(cm1, cm2)  # degree 2 &lt; degree 3
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/composed.jl#L137-L165">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.isone-Tuple{ComposedMonomial}"><a class="docstring-binding" href="#Base.isone-Tuple{ComposedMonomial}"><code>Base.isone</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.isone(cm::ComposedMonomial) -&gt; Bool</code></pre><p>Check if a ComposedMonomial is the identity (all components are identity monomials).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/composed.jl#L213-L217">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.isone-Union{Tuple{Tuple{C, ComposedMonomial}}, Tuple{C}} where C&lt;:Number"><a class="docstring-binding" href="#Base.isone-Union{Tuple{Tuple{C, ComposedMonomial}}, Tuple{C}} where C&lt;:Number"><code>Base.isone</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.isone(t::Tuple{C,&lt;:ComposedMonomial}) where {C} -&gt; Bool</code></pre><p>Check if a composed term is the identity (coefficient 1, all components are identity monomials).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/composed.jl#L241-L245">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.length-Tuple{ComposedMonomial}"><a class="docstring-binding" href="#Base.length-Tuple{ComposedMonomial}"><code>Base.length</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.length(cm::ComposedMonomial) -&gt; Int</code></pre><p>Number of component monomials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/composed.jl#L178-L182">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.one-Union{Tuple{ComposedMonomial{As, Ts}}, Tuple{Ts}, Tuple{As}} where {As, Ts}"><a class="docstring-binding" href="#Base.one-Union{Tuple{ComposedMonomial{As, Ts}}, Tuple{Ts}, Tuple{As}} where {As, Ts}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.one(cm::ComposedMonomial{As,Ts}) where {As,Ts}</code></pre><p>Create the identity ComposedMonomial for the same type as <code>cm</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/composed.jl#L232-L236">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.one-Union{Tuple{Type{ComposedMonomial{As, Ts}}}, Tuple{Ts}, Tuple{As}} where {As&lt;:Tuple, Ts&lt;:Tuple}"><a class="docstring-binding" href="#Base.one-Union{Tuple{Type{ComposedMonomial{As, Ts}}}, Tuple{Ts}, Tuple{As}} where {As&lt;:Tuple, Ts&lt;:Tuple}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.one(::Type{ComposedMonomial{As,Ts}}) where {As&lt;:Tuple,Ts&lt;:Tuple}</code></pre><p>Create the identity ComposedMonomial (all components are identity monomials).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/composed.jl#L222-L226">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.degree-Tuple{ComposedMonomial}"><a class="docstring-binding" href="#NCTSSoS.degree-Tuple{ComposedMonomial}"><code>NCTSSoS.degree</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">degree(cm::ComposedMonomial) -&gt; Int</code></pre><p>Total degree across all components.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m1 = NormalMonomial{PauliAlgebra}(UInt16[1, 2, 3]);

julia&gt; m2 = NormalMonomial{FermionicAlgebra}(Int32[1, 2]);

julia&gt; cm = ComposedMonomial((m1, m2));

julia&gt; degree(cm)
5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/composed.jl#L192-L210">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.simplify-Union{Tuple{ComposedMonomial{As, Ts}}, Tuple{Ts}, Tuple{As}} where {As&lt;:Tuple, Ts&lt;:Tuple}"><a class="docstring-binding" href="#NCTSSoS.simplify-Union{Tuple{ComposedMonomial{As, Ts}}, Tuple{Ts}, Tuple{As}} where {As&lt;:Tuple, Ts&lt;:Tuple}"><code>NCTSSoS.simplify</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simplify(cm::ComposedMonomial) -&gt; Vector{Tuple{&lt;:Number,&lt;:ComposedMonomial}}</code></pre><p>Simplify each component according to its algebra type.</p><p>Always returns <code>Vector{Tuple{coefficient,ComposedMonomial}}</code> for consistent API. Each entry contains a ComposedMonomial with the simplified component monomials.</p><p><strong>Algorithm</strong></p><ol><li>Simplify each component using its algebra&#39;s simplify function</li><li>Convert all results to (coefficient, monomial) pairs</li><li>Compute Cartesian product across all components</li><li>Filter zero terms</li></ol><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; using NCTSSoS: encode_index

julia&gt; m_pauli = NormalMonomial{PauliAlgebra}(UInt16[]);  # identity

julia&gt; u2 = encode_index(UInt16, 2, 1);

julia&gt; m_unip = NormalMonomial{UnipotentAlgebra}(UInt16[u2, u2]);

julia&gt; cm = ComposedMonomial((m_pauli, m_unip));

julia&gt; result = simplify(cm);

julia&gt; result isa Vector{&lt;:Tuple}
true

julia&gt; result[1][1]
1.0 + 0.0im

julia&gt; isempty(result[1][2][1].word)  # Pauli identity stays identity
true

julia&gt; isempty(result[1][2][2].word)  # Unipotent [2,2] -&gt; []
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/composed.jl#L251-L293">source</a></section></details></article><h2 id="Polynomials"><a class="docs-heading-anchor" href="#Polynomials">Polynomials</a><a id="Polynomials-1"></a><a class="docs-heading-anchor-permalink" href="#Polynomials" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="NCTSSoS.AbstractPolynomial"><a class="docstring-binding" href="#NCTSSoS.AbstractPolynomial"><code>NCTSSoS.AbstractPolynomial</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractPolynomial{C&lt;:Number}</code></pre><p>Abstract supertype for all polynomial types in NCTSSoS.</p><p><strong>Type Parameters</strong></p><ul><li><code>C&lt;:Number</code>: Coefficient type (Float64, ComplexF64, etc.)</li></ul><p><strong>Subtypes</strong></p><ul><li><code>Polynomial{A,T,C}</code>: Standard polynomial over a non-commutative algebra</li><li><code>StatePolynomial{C,ST,A,T}</code>: Polynomial of state expectations (commutative)</li><li><code>NCStatePolynomial{C,ST,A,T}</code>: Polynomial of state-operator products</li></ul><p><strong>Interface</strong></p><p>All subtypes should implement:</p><ul><li><code>coefficients(p)</code>: Return vector of coefficients</li><li><code>monomials(p)</code>: Return vector of monomials/terms</li><li><code>degree(p)</code>: Return maximum degree</li><li><code>Base.zero(::Type{P})</code>, <code>Base.one(::Type{P})</code>: Identity elements</li><li><code>Base.:(+)</code>, <code>Base.:(-)</code>, <code>Base.:(*)</code>: Arithmetic operations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L1-L21">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.Polynomial"><a class="docstring-binding" href="#NCTSSoS.Polynomial"><code>NCTSSoS.Polynomial</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Polynomial{A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}</code></pre><p>A polynomial represented as a sum of <code>(coefficient, monomial)</code> pairs. Maintains sorted, unique monomials with non-zero coefficients.</p><p><strong>Fields</strong></p><ul><li><code>terms::Vector{Tuple{C,NormalMonomial{A,T}}}</code>: Sorted terms with unique monomials and non-zero coefficients</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>A&lt;:AlgebraType</code>: Algebra type for dispatch (PauliAlgebra, FermionicAlgebra, etc.)</li><li><code>T&lt;:Integer</code>: Integer type for monomial word representation</li><li><code>C&lt;:Number</code>: Coefficient type (Float64, ComplexF64, etc.)</li></ul><p><strong>Invariants</strong></p><ul><li>Terms are sorted by monomial (using isless)</li><li>No duplicate monomials (combined during construction)</li><li>All coefficients are non-zero (zeros removed during construction)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m1 = NormalMonomial{PauliAlgebra}([1, 2]);

julia&gt; m2 = NormalMonomial{PauliAlgebra}([3]);

julia&gt; p = Polynomial([(1.0 + 0.0im, m1), (2.0 + 0.0im, m2)]);

julia&gt; length(terms(p))
2

julia&gt; degree(p)
2</code></pre><p>Construction with automatic deduplication:</p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m = NormalMonomial{PauliAlgebra}([1]);

julia&gt; p = Polynomial([(1.0+0im, m), (2.0+0im, m)]);  # Same monomial twice

julia&gt; length(terms(p))  # Combined into one term
1

julia&gt; coefficients(p)[1]  # Coefficients added
3.0 + 0.0im</code></pre><p>See also: <a href="#NCTSSoS.NormalMonomial"><code>NormalMonomial</code></a>, <a href="#NCTSSoS.coefficients-Tuple{Polynomial}"><code>coefficients</code></a>, <a href="../../manual/monomials/#monomials"><code>monomials</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L24-L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.Polynomial-Union{Tuple{NormalMonomial{A, T}}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#NCTSSoS.Polynomial-Union{Tuple{NormalMonomial{A, T}}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer}"><code>NCTSSoS.Polynomial</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Polynomial(m::NormalMonomial{A,T}) where {A,T}</code></pre><p>Construct a polynomial from a monomial with coefficient 1.</p><p>The coefficient type is determined by <code>coeff_type(A)</code>:</p><ul><li><code>PauliAlgebra</code>: uses <code>ComplexF64</code> (Pauli products generate complex phases)</li><li>All others: uses <code>Float64</code></li></ul><div class="admonition is-info" id="No-automatic-simplification-43a6a2aca89f8ab2"><header class="admonition-header">No automatic simplification<a class="admonition-anchor" href="#No-automatic-simplification-43a6a2aca89f8ab2" title="Permalink"></a></header><div class="admonition-body"><p>This constructor does NOT call <code>simplify</code> on the monomial. If the monomial is not in canonical form (e.g., a Pauli product like <code>σx₁ * σx₁</code> that should simplify to identity), the resulting polynomial will contain the unsimplified monomial. Use <code>simplify(Polynomial(m))</code> if canonical form is required.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m = NormalMonomial{PauliAlgebra}([1, 2]);

julia&gt; p = Polynomial(m);

julia&gt; coefficients(p)
1-element Vector{ComplexF64}:
 1.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L171-L198">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.Polynomial-Union{Tuple{Number}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><a class="docstring-binding" href="#NCTSSoS.Polynomial-Union{Tuple{Number}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><code>NCTSSoS.Polynomial</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Polynomial{A,T,C}(c::Number) where {A,T,C}</code></pre><p>Construct a constant polynomial (coefficient times identity monomial).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; p = Polynomial{PauliAlgebra,Int64,Float64}(5.0);

julia&gt; coefficients(p)
1-element Vector{Float64}:
 5.0

julia&gt; isone(monomials(p)[1])
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L265-L283">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.Polynomial-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><a class="docstring-binding" href="#NCTSSoS.Polynomial-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><code>NCTSSoS.Polynomial</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Polynomial(p::Polynomial{A,T,C}) where {A,T,C}</code></pre><p>Identity constructor: returns the polynomial unchanged. Useful for generic code that may receive NormalMonomial or Polynomial.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; p1 = Polynomial([(2.0 + 0.0im, NormalMonomial{PauliAlgebra}([1]))]);

julia&gt; p2 = Polynomial(p1);

julia&gt; p1 === p2
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L243-L260">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.Polynomial-Union{Tuple{Tuple{C, NormalMonomial{A, T}}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><a class="docstring-binding" href="#NCTSSoS.Polynomial-Union{Tuple{Tuple{C, NormalMonomial{A, T}}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><code>NCTSSoS.Polynomial</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Polynomial((c, m)::Tuple{C,NormalMonomial{A,T}}) where {A,T,C}</code></pre><p>Construct a polynomial from a single term.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m = NormalMonomial{PauliAlgebra}([1, 2]);

julia&gt; p = Polynomial((3.0 + 0.0im, m));

julia&gt; length(terms(p))
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L145-L161">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.Polynomial-Union{Tuple{Tuple{Vector{T}, UInt8}}, Tuple{T}} where T&lt;:Integer"><a class="docstring-binding" href="#NCTSSoS.Polynomial-Union{Tuple{Tuple{Vector{T}, UInt8}}, Tuple{T}} where T&lt;:Integer"><code>NCTSSoS.Polynomial</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Polynomial(t::Tuple{Vector{T},UInt8}) where {T&lt;:Integer}</code></pre><p>Construct a Polynomial from a (word, phase) tuple returned by Pauli simplification.</p><p>The phase encoding: 0=1, 1=i, 2=-1, 3=-i (representing (im)^phase).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; # Result from simplify(PauliAlgebra, word)
julia&gt; result = (Int64[1, 2], UInt8(1));  # word with phase i

julia&gt; p = Polynomial(result);

julia&gt; coefficients(p)[1]
0.0 + 1.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L210-L229">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:==-Union{Tuple{C2}, Tuple{C1}, Tuple{T2}, Tuple{T1}, Tuple{A2}, Tuple{A1}, Tuple{Polynomial{A1, T1, C1}, Polynomial{A2, T2, C2}}} where {A1, A2, T1, T2, C1, C2}"><a class="docstring-binding" href="#Base.:==-Union{Tuple{C2}, Tuple{C1}, Tuple{T2}, Tuple{T1}, Tuple{A2}, Tuple{A1}, Tuple{Polynomial{A1, T1, C1}, Polynomial{A2, T2, C2}}} where {A1, A2, T1, T2, C1, C2}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(==)(p1::Polynomial, p2::Polynomial) -&gt; Bool</code></pre><p>Check if two polynomials are equal. Polynomials are equal if they have the same terms (same monomials with same coefficients).</p><p>Since polynomials are maintained in canonical form (sorted, deduplicated), equality is a straightforward comparison of the terms vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L647-L655">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.convert-Union{Tuple{C2}, Tuple{C1}, Tuple{T}, Tuple{A}, Tuple{Type{Polynomial{A, T, C2}}, Polynomial{A, T, C1}}} where {A&lt;:AlgebraType, T&lt;:Integer, C1&lt;:Number, C2&lt;:Number}"><a class="docstring-binding" href="#Base.convert-Union{Tuple{C2}, Tuple{C1}, Tuple{T}, Tuple{A}, Tuple{Type{Polynomial{A, T, C2}}, Polynomial{A, T, C1}}} where {A&lt;:AlgebraType, T&lt;:Integer, C1&lt;:Number, C2&lt;:Number}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.convert(::Type{Polynomial{A,T,C2}}, p::Polynomial{A,T,C1}) where {A,T,C1,C2}</code></pre><p>Convert a polynomial to a different coefficient type.</p><p>This is needed for operations like <code>power_by_squaring</code> which may require converting between different coefficient types during computation.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m = NormalMonomial{NonCommutativeAlgebra}(UInt8[1]);

julia&gt; p_int = Polynomial([(2, m)]);  # Int coefficients

julia&gt; p_float = convert(Polynomial{NonCommutativeAlgebra,UInt8,Float64}, p_int);

julia&gt; coefficients(p_float)[1]
2.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L295-L316">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.copy-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><a class="docstring-binding" href="#Base.copy-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><code>Base.copy</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.copy(p::Polynomial{A,T,C}) where {A,T,C}</code></pre><p>Create a shallow copy of the polynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L401-L405">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.eltype-Union{Tuple{Type{Polynomial{A, T, C}}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><a class="docstring-binding" href="#Base.eltype-Union{Tuple{Type{Polynomial{A, T, C}}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><code>Base.eltype</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.iterate(p::Polynomial{A,T,C})
Base.iterate(p::Polynomial{A,T,C}, state::Int)</code></pre><p>Iterate a Polynomial, yielding <code>(coefficient, NormalMonomial)</code> pairs for each term.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m1 = NormalMonomial{PauliAlgebra}([1]);

julia&gt; m2 = NormalMonomial{PauliAlgebra}([2]);

julia&gt; p = Polynomial([(1.0+0im, m1), (2.0+0im, m2)]);

julia&gt; length(collect(p))
2

julia&gt; for (coef, mono) in p
           println(&quot;Coefficient: $coef, Degree: $(degree(mono))&quot;)
       end
Coefficient: 1.0 + 0.0im, Degree: 1
Coefficient: 2.0 + 0.0im, Degree: 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L770-L795">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.hash-Tuple{Polynomial, UInt64}"><a class="docstring-binding" href="#Base.hash-Tuple{Polynomial, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.hash(p::Polynomial, h::UInt) -&gt; UInt</code></pre><p>Hash function for polynomial. Combines hashes of all terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L672-L676">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.isless-Union{Tuple{C}, Tuple{T}, Tuple{A}, Tuple{Polynomial{A, T, C}, Polynomial{A, T, C}}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><a class="docstring-binding" href="#Base.isless-Union{Tuple{C}, Tuple{T}, Tuple{A}, Tuple{Polynomial{A, T, C}, Polynomial{A, T, C}}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.isless(p1::Polynomial{A,T,C}, p2::Polynomial{A,T,C}) where {A,T,C} -&gt; Bool</code></pre><p>Compare two polynomials for sorting. Uses degree-first (graded) ordering:</p><ol><li>Compare by highest-degree monomial first</li><li>For equal monomials, compare by coefficient magnitude</li><li>Continue to next-highest degree monomial if still equal</li><li>Polynomial with fewer terms is &quot;less&quot; if all compared terms are equal</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L685-L693">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.isone-Tuple{Polynomial}"><a class="docstring-binding" href="#Base.isone-Tuple{Polynomial}"><code>Base.isone</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.isone(p::Polynomial) -&gt; Bool</code></pre><p>Check if a polynomial is the multiplicative identity (single term with coefficient 1 and identity monomial).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; p = one(Polynomial{PauliAlgebra,Int64,Float64});

julia&gt; isone(p)
true

julia&gt; p2 = Polynomial{PauliAlgebra,Int64,Float64}(2.0);

julia&gt; isone(p2)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L430-L449">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.iszero-Tuple{Polynomial}"><a class="docstring-binding" href="#Base.iszero-Tuple{Polynomial}"><code>Base.iszero</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.iszero(p::Polynomial) -&gt; Bool</code></pre><p>Check if a polynomial is the zero polynomial (has no terms).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m = NormalMonomial{PauliAlgebra}([1]);

julia&gt; p = Polynomial([(1.0+0im, m), (-1.0+0im, m)]);  # Cancels out

julia&gt; iszero(p)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L411-L427">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.one-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><a class="docstring-binding" href="#Base.one-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.one(p::Polynomial{A,T,C}) where {A,T,C}</code></pre><p>Create the multiplicative identity polynomial for the same type as <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L392-L396">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.one-Union{Tuple{Type{Polynomial{A, T, C}}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><a class="docstring-binding" href="#Base.one-Union{Tuple{Type{Polynomial{A, T, C}}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.one(::Type{Polynomial{A,T,C}}) where {A,T,C}</code></pre><p>Create the multiplicative identity polynomial (1 times identity monomial).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; p = one(Polynomial{PauliAlgebra,Int64,Float64});

julia&gt; isone(p)
true

julia&gt; coefficients(p)
1-element Vector{Float64}:
 1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L369-L387">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.show-Union{Tuple{C}, Tuple{T}, Tuple{A}, Tuple{IO, Polynomial{A, T, C}}} where {A, T, C}"><a class="docstring-binding" href="#Base.show-Union{Tuple{C}, Tuple{T}, Tuple{A}, Tuple{IO, Polynomial{A, T, C}}} where {A, T, C}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.show(io::IO, p::Polynomial)</code></pre><p>Display a polynomial as a sum of terms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L745-L749">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.zero-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><a class="docstring-binding" href="#Base.zero-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><code>Base.zero</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.zero(p::Polynomial{A,T,C}) where {A,T,C}</code></pre><p>Create the zero polynomial for the same type as <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L360-L364">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.zero-Union{Tuple{Type{Polynomial{A, T, C}}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><a class="docstring-binding" href="#Base.zero-Union{Tuple{Type{Polynomial{A, T, C}}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><code>Base.zero</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.zero(::Type{Polynomial{A,T,C}}) where {A,T,C}</code></pre><p>Create the zero polynomial (no terms).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; p = zero(Polynomial{PauliAlgebra,Int64,Float64});

julia&gt; iszero(p)
true

julia&gt; length(terms(p))
0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L338-L355">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._process_terms-Union{Tuple{C}, Tuple{T}, Tuple{A}, Tuple{Array{Tuple{C, NormalMonomial{A, T}}, 1}, Type{C}}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><a class="docstring-binding" href="#NCTSSoS._process_terms-Union{Tuple{C}, Tuple{T}, Tuple{A}, Tuple{Array{Tuple{C, NormalMonomial{A, T}}, 1}, Type{C}}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><code>NCTSSoS._process_terms</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_process_terms(input_terms, C) -&gt; Vector{Tuple{C,NormalMonomial}}</code></pre><p>Process a vector of terms: sort by monomial, combine duplicates, remove zeros. This is the core algorithm for maintaining polynomial invariants.</p><p><strong>Algorithm</strong></p><ol><li>If empty, return empty vector</li><li>Sort terms by monomial (degree-first, then lexicographic)</li><li>Iterate through sorted terms, combining coefficients for duplicate monomials</li><li>Filter out terms with zero coefficients</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L96-L107">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.coeff_type-Union{Tuple{Type{&lt;:NCTSSoS.AbstractPolynomial{C}}}, Tuple{C}} where C&lt;:Number"><a class="docstring-binding" href="#NCTSSoS.coeff_type-Union{Tuple{Type{&lt;:NCTSSoS.AbstractPolynomial{C}}}, Tuple{C}} where C&lt;:Number"><code>NCTSSoS.coeff_type</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">coeff_type(::Type{&lt;:AbstractPolynomial{C}}) where {C} -&gt; Type{&lt;:Number}
coeff_type(p::AbstractPolynomial) -&gt; Type{&lt;:Number}</code></pre><p>Return the coefficient type <code>C</code> for any <code>AbstractPolynomial</code> subtype.</p><p>Works for all polynomial types including <code>Polynomial{A,T,C}</code> and <code>NCStatePolynomial{C,ST,A,T}</code> since both subtype <code>AbstractPolynomial{C}</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; coeff_type(Polynomial{PauliAlgebra,Int64,ComplexF64})
ComplexF64

julia&gt; coeff_type(Polynomial{NonCommutativeAlgebra,Int64,Float64})
Float64</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L816-L833">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.coefficients-Tuple{Polynomial}"><a class="docstring-binding" href="#NCTSSoS.coefficients-Tuple{Polynomial}"><code>NCTSSoS.coefficients</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">coefficients(p::Polynomial) -&gt; Vector{C}</code></pre><p>Extract the coefficients of all terms in the polynomial.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m1 = NormalMonomial{PauliAlgebra}([1]);

julia&gt; m2 = NormalMonomial{PauliAlgebra}([2]);

julia&gt; p = Polynomial([(1.0+0im, m1), (2.0+0im, m2)]);

julia&gt; coefficients(p)
2-element Vector{ComplexF64}:
 1.0 + 0.0im
 2.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L485-L505">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.degree-Tuple{Polynomial}"><a class="docstring-binding" href="#NCTSSoS.degree-Tuple{Polynomial}"><code>NCTSSoS.degree</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">degree(p::Polynomial) -&gt; Union{Int, Float64}</code></pre><p>Compute the maximum degree of all monomials in the polynomial. Returns <code>-Inf</code> for the zero polynomial to preserve the algebraic identity <code>deg(p * q) = deg(p) + deg(q)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m1 = NormalMonomial{PauliAlgebra}([1]);

julia&gt; m2 = NormalMonomial{PauliAlgebra}([2, 3, 4]);

julia&gt; p = Polynomial([(1.0+0im, m1), (2.0+0im, m2)]);

julia&gt; degree(p)
3

julia&gt; degree(zero(Polynomial{PauliAlgebra,Int64,ComplexF64}))
-Inf</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L531-L554">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.monomials-Union{Tuple{Polynomial{A, T}}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#NCTSSoS.monomials-Union{Tuple{Polynomial{A, T}}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer}"><code>NCTSSoS.monomials</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">monomials(p::Polynomial) -&gt; Vector{NormalMonomial}</code></pre><p>Extract the monomials of all terms in the polynomial.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m1 = NormalMonomial{PauliAlgebra}([1]);

julia&gt; m2 = NormalMonomial{PauliAlgebra}([2]);

julia&gt; p = Polynomial([(1.0+0im, m1), (2.0+0im, m2)]);

julia&gt; ms = monomials(p);

julia&gt; length(ms)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L508-L528">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.terms-Tuple{Polynomial}"><a class="docstring-binding" href="#NCTSSoS.terms-Tuple{Polynomial}"><code>NCTSSoS.terms</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">terms(p::Polynomial)</code></pre><p>Iterate the polynomial as <code>(coefficient, monomial)</code> pairs.</p><p>The returned monomials are <code>NormalMonomial</code>s (canonical form).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; reg, (σx, σy, σz) = create_pauli_variables(1:1);

julia&gt; m1 = σx[1];

julia&gt; m2 = σy[1];

julia&gt; p = Polynomial([(1.0+0im, m1), (2.0+0im, m2)]);

julia&gt; length(terms(p))
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L460-L482">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.variable_indices-Union{Tuple{NormalMonomial{A, T}}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#NCTSSoS.variable_indices-Union{Tuple{NormalMonomial{A, T}}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer}"><code>NCTSSoS.variable_indices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">variable_indices(m::NormalMonomial{A,T}) -&gt; Set{T}</code></pre><p>Get the set of all variable indices used in a monomial. Returns a Set of integer indices.</p><p>For signed index types (Fermionic/Bosonic), uses <code>abs(idx)</code> to normalize indices. This treats creation operators (negative indices like -1 for a₁†) and annihilation operators (positive indices like 1 for a₁) as referring to the same physical mode, which is the correct behavior for correlative sparsity analysis.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m = NormalMonomial{PauliAlgebra}([1, 2, 1]);

julia&gt; variable_indices(m)
Set{Int64} with 2 elements:
  2
  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L597-L619">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.variable_indices-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A, T, C}"><a class="docstring-binding" href="#NCTSSoS.variable_indices-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A, T, C}"><code>NCTSSoS.variable_indices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">variable_indices(p::Polynomial) -&gt; Set</code></pre><p>Get the set of all variable indices used in the polynomial&#39;s monomials. Returns a Set of integer indices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m1 = NormalMonomial{PauliAlgebra}([1, 2]);

julia&gt; m2 = NormalMonomial{PauliAlgebra}([2, 3]);

julia&gt; p = Polynomial([(1.0+0im, m1), (1.0+0im, m2)]);

julia&gt; variable_indices(p)
Set{Int64} with 3 elements:
  2
  3
  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/types/polynomial.jl#L562-L584">source</a></section></details></article><h2 id="State-Polynomial"><a class="docs-heading-anchor" href="#State-Polynomial">State Polynomial</a><a id="State-Polynomial-1"></a><a class="docs-heading-anchor-permalink" href="#State-Polynomial" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="NCTSSoS.NCStatePolynomial"><a class="docstring-binding" href="#NCTSSoS.NCStatePolynomial"><code>NCTSSoS.NCStatePolynomial</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NCStatePolynomial{C&lt;:Number, ST&lt;:StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}</code></pre><p>A polynomial in non-commutative state words with coefficients.</p><p>Represents a sum of NCStateWords with coefficients: sum<em>i c</em>i * ncsw_i</p><p><strong>Fields</strong></p><ul><li><code>coeffs::Vector{C}</code>: Coefficients for each NC state word</li><li><code>nc_state_words::Vector{NCStateWord{ST,A,T}}</code>: Sorted unique NC state words</li></ul><p><strong>Invariants</strong></p><p>Same as StatePolynomial: sorted, unique, non-zero coefficients.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m1 = NormalMonomial{ProjectorAlgebra}(UInt8[1]);

julia&gt; sw = StateWord{Arbitrary}([m1]);

julia&gt; ncsw = NCStateWord(sw, m1);

julia&gt; ncsp = NCStatePolynomial([1.0], [ncsw]);

julia&gt; length(ncsp.nc_state_words)
1</code></pre><p>See also: <a href="#NCTSSoS.NCStateWord"><code>NCStateWord</code></a>, <a href="#NCTSSoS.StatePolynomial"><code>StatePolynomial</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L754-L785">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.StatePolynomial"><a class="docstring-binding" href="#NCTSSoS.StatePolynomial"><code>NCTSSoS.StatePolynomial</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StatePolynomial{C&lt;:Number, ST&lt;:StateType, A&lt;:AlgebraType, T&lt;:Integer}</code></pre><p>A polynomial in state words with coefficients.</p><p>Represents a sum of state words with coefficients: sum<em>i c</em>i * sw_i</p><p><strong>Fields</strong></p><ul><li><code>coeffs::Vector{C}</code>: Coefficients for each state word</li><li><code>state_words::Vector{StateWord{ST,A,T}}</code>: Sorted unique state words</li></ul><p><strong>Invariants</strong></p><ul><li><code>state_words</code> is sorted by the StateWord ordering</li><li>All state words are unique (combined during construction)</li><li>All coefficients are non-zero (zeros removed during construction)</li><li><code>length(coeffs) == length(state_words)</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m1 = NormalMonomial{ProjectorAlgebra}(UInt8[1, 2]);

julia&gt; m2 = NormalMonomial{ProjectorAlgebra}(UInt8[3]);

julia&gt; sw1 = StateWord{Arbitrary}([m1]);

julia&gt; sw2 = StateWord{Arbitrary}([m2]);

julia&gt; sp = StatePolynomial([1.0, 2.0], [sw1, sw2]);

julia&gt; length(sp.state_words)
2</code></pre><p>See also: <a href="#NCTSSoS.StateWord"><code>StateWord</code></a>, <a href="#NCTSSoS.NCStatePolynomial"><code>NCStatePolynomial</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L86-L122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Tuple{NCTSSoS.NCStatePolynomial, Number}"><a class="docstring-binding" href="#Base.:*-Tuple{NCTSSoS.NCStatePolynomial, Number}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(*)(ncsp::NCStatePolynomial, c::Number)</code></pre><p>Scalar multiplication (scalar on right).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L1013-L1017">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Tuple{StatePolynomial, Number}"><a class="docstring-binding" href="#Base.:*-Tuple{StatePolynomial, Number}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(*)(sp::StatePolynomial, c::Number)</code></pre><p>Scalar multiplication (scalar on right).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L498-L502">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C2}, Tuple{C1}, Tuple{StatePolynomial{C1, ST, A, T}, StatePolynomial{C2, ST, A, T}}} where {C1&lt;:Number, C2&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C2}, Tuple{C1}, Tuple{StatePolynomial{C1, ST, A, T}, StatePolynomial{C2, ST, A, T}}} where {C1&lt;:Number, C2&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(*)(a::StatePolynomial{C1,ST,A,T}, b::StatePolynomial{C2,ST,A,T}) where {C1,C2,ST,A,T}</code></pre><p>Multiply two StatePolynomials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L618-L622">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{NormalMonomial{A, T}, StatePolynomial{C, ST, A, T}}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{NormalMonomial{A, T}, StatePolynomial{C, ST, A, T}}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(*)(m::NormalMonomial{A,T}, sp::StatePolynomial{C,ST,A,T}) where {C,ST,A,T}</code></pre><p>Multiply a NormalMonomial by a StatePolynomial (on the left).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L520-L524">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{Number, NCTSSoS.NCStatePolynomial{C, ST, A, T}}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{Number, NCTSSoS.NCStatePolynomial{C, ST, A, T}}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(*)(c::Number, ncsp::NCStatePolynomial)</code></pre><p>Scalar multiplication (scalar on left).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L1002-L1006">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{Number, StatePolynomial{C, ST, A, T}}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{Number, StatePolynomial{C, ST, A, T}}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(*)(c::Number, sp::StatePolynomial)</code></pre><p>Scalar multiplication (scalar on left).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L487-L491">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{StatePolynomial{C, ST, A, T}, NormalMonomial{A, T}}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{StatePolynomial{C, ST, A, T}, NormalMonomial{A, T}}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(*)(sp::StatePolynomial{C,ST,A,T}, m::NormalMonomial{A,T}) where {C,ST,A,T}</code></pre><p>Multiply a StatePolynomial by a NormalMonomial (on the right). Equivalent to multiplying by <code>one(Polynomial)</code> - used in expressions like <code>sp * one(NormalMonomial)</code>. The result is an NCStatePolynomial since it now has both state and non-commutative parts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L505-L511">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{StatePolynomial{C, ST, A, T}, StateWord{ST, A, T}}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{StatePolynomial{C, ST, A, T}, StateWord{ST, A, T}}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(*)(sp::StatePolynomial{C,ST,A,T}, sw::StateWord{ST,A,T}) where {C,ST,A,T}</code></pre><p>Multiply a StatePolynomial by a StateWord.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L646-L650">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{StateWord{ST, A, T}, StatePolynomial{C, ST, A, T}}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{StateWord{ST, A, T}, StatePolynomial{C, ST, A, T}}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(*)(sw::StateWord{ST,A,T}, sp::StatePolynomial{C,ST,A,T}) where {C,ST,A,T}</code></pre><p>Multiply a StateWord by a StatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L669-L673">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{Number, NCStateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{Number, NCStateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(*)(c::Number, ncsw::NCStateWord{ST,A,T}) where {ST,A,T}</code></pre><p>Multiply a scalar with an NCStateWord, creating an NCStatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L1020-L1024">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{Number, StateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{Number, StateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(*)(c::Number, sw::StateWord{ST,A,T}) where {ST,A,T}</code></pre><p>Multiply a scalar with a StateWord, creating a StatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L558-L562">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:+-Union{Tuple{TC}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateWord{ST, A, T}, Tuple{TC, StateWord{ST, A, T}}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer, TC&lt;:Number}"><a class="docstring-binding" href="#Base.:+-Union{Tuple{TC}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateWord{ST, A, T}, Tuple{TC, StateWord{ST, A, T}}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer, TC&lt;:Number}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(+)(sw::StateWord{ST,A,T}, t::Tuple{TC,StateWord{ST,A,T}}) where {ST,A,T,TC}</code></pre><p>Add a StateWord to a <code>(coefficient, StateWord)</code> pair to create a StatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L360-L364">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C2}, Tuple{C1}, Tuple{NCTSSoS.NCStatePolynomial{C1, ST, A, T}, NCTSSoS.NCStatePolynomial{C2, ST, A, T}}} where {C1&lt;:Number, C2&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C2}, Tuple{C1}, Tuple{NCTSSoS.NCStatePolynomial{C1, ST, A, T}, NCTSSoS.NCStatePolynomial{C2, ST, A, T}}} where {C1&lt;:Number, C2&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(+)(a::NCStatePolynomial, b::NCStatePolynomial)</code></pre><p>Add two NCStatePolynomials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L967-L971">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C2}, Tuple{C1}, Tuple{StatePolynomial{C1, ST, A, T}, StatePolynomial{C2, ST, A, T}}} where {C1&lt;:Number, C2&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C2}, Tuple{C1}, Tuple{StatePolynomial{C1, ST, A, T}, StatePolynomial{C2, ST, A, T}}} where {C1&lt;:Number, C2&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(+)(a::StatePolynomial{C1,ST,A,T}, b::StatePolynomial{C2,ST,A,T}) where {C1,C2,ST,A,T}</code></pre><p>Add two StatePolynomials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L314-L318">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}, NCStateWord{ST, A, T}}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}, NCStateWord{ST, A, T}}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(+)(ncsp::NCStatePolynomial{C,ST,A,T}, ncsw::NCStateWord{ST,A,T}) where {C,ST,A,T}</code></pre><p>Add an NCStateWord to an NCStatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L1096-L1100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{StatePolynomial{C, ST, A, T}, StateWord{ST, A, T}}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{StatePolynomial{C, ST, A, T}, StateWord{ST, A, T}}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(+)(sp::StatePolynomial{C,ST,A,T}, sw::StateWord{ST,A,T}) where {C,ST,A,T}</code></pre><p>Add a StateWord to a StatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L430-L434">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{NCStateWord{ST, A, T}, NCStateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{NCStateWord{ST, A, T}, NCStateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(+)(a::NCStateWord{ST,A,T}, b::NCStateWord{ST,A,T}) where {ST,A,T}</code></pre><p>Add two NCStateWords to create an NCStatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L1031-L1035">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{Number, NCStateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{Number, NCStateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(+)(c::Number, ncsw::NCStateWord{ST,A,T}) where {ST,A,T}</code></pre><p>Add a scalar to an NCStateWord, creating an NCStatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L1062-L1066">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{Number, StateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{Number, StateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(+)(c::Number, sw::StateWord{ST,A,T}) where {ST,A,T}</code></pre><p>Add a scalar to a StateWord, creating a StatePolynomial with identity StateWord for the constant.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L534-L538">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateWord{ST, A, T}, StateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateWord{ST, A, T}, StateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(+)(sw1::StateWord{ST,A,T}, sw2::StateWord{ST,A,T}) where {ST,A,T}</code></pre><p>Add two StateWords to create a StatePolynomial with both words.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L329-L333">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{TC}, Tuple{C}, Tuple{StatePolynomial{C, ST, A, T}, Tuple{TC, StateWord{ST, A, T}}}} where {C&lt;:Number, TC&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{TC}, Tuple{C}, Tuple{StatePolynomial{C, ST, A, T}, Tuple{TC, StateWord{ST, A, T}}}} where {C&lt;:Number, TC&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(+)(sp::StatePolynomial{C,ST,A,T}, t::Tuple{TC,StateWord{ST,A,T}}) where {C,TC,ST,A,T}</code></pre><p>Add a <code>(coefficient, StateWord)</code> pair to a StatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L397-L401">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:--Union{Tuple{NCStateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:--Union{Tuple{NCStateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(-)(ncsw::NCStateWord{ST,A,T}) where {ST,A,T}</code></pre><p>Negate an NCStateWord to create an NCStatePolynomial with coefficient -1.0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L1053-L1057">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:--Union{Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:--Union{Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(-)(ncsp::NCStatePolynomial)</code></pre><p>Negate an NCStatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L982-L986">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:--Union{Tuple{StatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:--Union{Tuple{StatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(-)(sp::StatePolynomial)</code></pre><p>Negate a StatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L463-L467">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:--Union{Tuple{StateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:--Union{Tuple{StateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(-)(sw::StateWord{ST,A,T}) where {ST,A,T}</code></pre><p>Negate a StateWord to create a StatePolynomial with coefficient -1.0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L351-L355">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:--Union{Tuple{TC}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateWord{ST, A, T}, Tuple{TC, StateWord{ST, A, T}}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer, TC&lt;:Number}"><a class="docstring-binding" href="#Base.:--Union{Tuple{TC}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateWord{ST, A, T}, Tuple{TC, StateWord{ST, A, T}}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer, TC&lt;:Number}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(-)(sw::StateWord{ST,A,T}, t::Tuple{TC,StateWord{ST,A,T}}) where {ST,A,T,TC}</code></pre><p>Subtract a <code>(coefficient, StateWord)</code> pair from a StateWord to create a StatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L373-L377">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:--Union{Tuple{TC}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{Tuple{TC, StateWord{ST, A, T}}, StateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer, TC&lt;:Number}"><a class="docstring-binding" href="#Base.:--Union{Tuple{TC}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{Tuple{TC, StateWord{ST, A, T}}, StateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer, TC&lt;:Number}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(-)(t::Tuple{TC,StateWord{ST,A,T}}, sw::StateWord{ST,A,T}) where {ST,A,T,TC}</code></pre><p>Subtract a StateWord from a <code>(coefficient, StateWord)</code> pair to create a StatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L385-L389">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C2}, Tuple{C1}, Tuple{NCTSSoS.NCStatePolynomial{C1, ST, A, T}, NCTSSoS.NCStatePolynomial{C2, ST, A, T}}} where {C1&lt;:Number, C2&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C2}, Tuple{C1}, Tuple{NCTSSoS.NCStatePolynomial{C1, ST, A, T}, NCTSSoS.NCStatePolynomial{C2, ST, A, T}}} where {C1&lt;:Number, C2&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(-)(a::NCStatePolynomial, b::NCStatePolynomial)</code></pre><p>Subtract two NCStatePolynomials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L991-L995">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C2}, Tuple{C1}, Tuple{StatePolynomial{C1, ST, A, T}, StatePolynomial{C2, ST, A, T}}} where {C1&lt;:Number, C2&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C2}, Tuple{C1}, Tuple{StatePolynomial{C1, ST, A, T}, StatePolynomial{C2, ST, A, T}}} where {C1&lt;:Number, C2&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(-)(a::StatePolynomial, b::StatePolynomial)</code></pre><p>Subtract two StatePolynomials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L472-L476">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{NCStateWord{ST, A, T}, NCTSSoS.NCStatePolynomial{C, ST, A, T}}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{NCStateWord{ST, A, T}, NCTSSoS.NCStatePolynomial{C, ST, A, T}}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(-)(ncsw::NCStateWord{ST,A,T}, ncsp::NCStatePolynomial{C,ST,A,T}) where {C,ST,A,T}</code></pre><p>Subtract an NCStatePolynomial from an NCStateWord.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L1125-L1129">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}, NCStateWord{ST, A, T}}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}, NCStateWord{ST, A, T}}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(-)(ncsp::NCStatePolynomial{C,ST,A,T}, ncsw::NCStateWord{ST,A,T}) where {C,ST,A,T}</code></pre><p>Subtract an NCStateWord from an NCStatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L1111-L1115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{StatePolynomial{C, ST, A, T}, StateWord{ST, A, T}}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{StatePolynomial{C, ST, A, T}, StateWord{ST, A, T}}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(-)(sp::StatePolynomial{C,ST,A,T}, sw::StateWord{ST,A,T}) where {C,ST,A,T}</code></pre><p>Subtract a StateWord from a StatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L445-L449">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{NCStateWord{ST, A, T}, NCStateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{NCStateWord{ST, A, T}, NCStateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(-)(a::NCStateWord{ST,A,T}, b::NCStateWord{ST,A,T}) where {ST,A,T}</code></pre><p>Subtract two NCStateWords to create an NCStatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L1042-L1046">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{NCStateWord{ST, A, T}, Number}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{NCStateWord{ST, A, T}, Number}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(-)(ncsw::NCStateWord{ST,A,T}, c::Number) where {ST,A,T}</code></pre><p>Subtract a scalar from an NCStateWord.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L1085-L1089">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{Number, NCStateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{Number, NCStateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(-)(c::Number, ncsw::NCStateWord{ST,A,T}) where {ST,A,T}</code></pre><p>Subtract an NCStateWord from a scalar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L1074-L1078">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{Number, StateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{Number, StateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(-)(c::Number, sw::StateWord{ST,A,T}) where {ST,A,T}</code></pre><p>Subtract a StateWord from a scalar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L547-L551">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateWord{ST, A, T}, StateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateWord{ST, A, T}, StateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(-)(sw1::StateWord{ST,A,T}, sw2::StateWord{ST,A,T}) where {ST,A,T}</code></pre><p>Subtract two StateWords to create a StatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L340-L344">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{TC}, Tuple{C}, Tuple{StatePolynomial{C, ST, A, T}, Tuple{TC, StateWord{ST, A, T}}}} where {C&lt;:Number, TC&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{TC}, Tuple{C}, Tuple{StatePolynomial{C, ST, A, T}, Tuple{TC, StateWord{ST, A, T}}}} where {C&lt;:Number, TC&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(-)(sp::StatePolynomial{C,ST,A,T}, t::Tuple{TC,StateWord{ST,A,T}}) where {C,TC,ST,A,T}</code></pre><p>Subtract a <code>(coefficient, StateWord)</code> pair from a StatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L414-L418">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:==-Union{Tuple{T2}, Tuple{T1}, Tuple{A2}, Tuple{A1}, Tuple{ST2}, Tuple{ST1}, Tuple{C2}, Tuple{C1}, Tuple{NCTSSoS.NCStatePolynomial{C1, ST1, A1, T1}, NCTSSoS.NCStatePolynomial{C2, ST2, A2, T2}}} where {C1, C2, ST1, ST2, A1, A2, T1, T2}"><a class="docstring-binding" href="#Base.:==-Union{Tuple{T2}, Tuple{T1}, Tuple{A2}, Tuple{A1}, Tuple{ST2}, Tuple{ST1}, Tuple{C2}, Tuple{C1}, Tuple{NCTSSoS.NCStatePolynomial{C1, ST1, A1, T1}, NCTSSoS.NCStatePolynomial{C2, ST2, A2, T2}}} where {C1, C2, ST1, ST2, A1, A2, T1, T2}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(==)(a::NCStatePolynomial, b::NCStatePolynomial) -&gt; Bool</code></pre><p>Check if two NCStatePolynomials are equal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L934-L938">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:==-Union{Tuple{T2}, Tuple{T1}, Tuple{A2}, Tuple{A1}, Tuple{ST2}, Tuple{ST1}, Tuple{C2}, Tuple{C1}, Tuple{StatePolynomial{C1, ST1, A1, T1}, StatePolynomial{C2, ST2, A2, T2}}} where {C1, C2, ST1, ST2, A1, A2, T1, T2}"><a class="docstring-binding" href="#Base.:==-Union{Tuple{T2}, Tuple{T1}, Tuple{A2}, Tuple{A1}, Tuple{ST2}, Tuple{ST1}, Tuple{C2}, Tuple{C1}, Tuple{StatePolynomial{C1, ST1, A1, T1}, StatePolynomial{C2, ST2, A2, T2}}} where {C1, C2, ST1, ST2, A1, A2, T1, T2}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(==)(a::StatePolynomial, b::StatePolynomial) -&gt; Bool</code></pre><p>Check if two StatePolynomials are equal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L281-L285">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.hash-Tuple{NCTSSoS.NCStatePolynomial, UInt64}"><a class="docstring-binding" href="#Base.hash-Tuple{NCTSSoS.NCStatePolynomial, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.hash(ncsp::NCStatePolynomial, h::UInt) -&gt; UInt</code></pre><p>Hash function for NCStatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L950-L954">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.hash-Tuple{StatePolynomial, UInt64}"><a class="docstring-binding" href="#Base.hash-Tuple{StatePolynomial, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.hash(sp::StatePolynomial, h::UInt) -&gt; UInt</code></pre><p>Hash function for StatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L297-L301">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.isone-Tuple{NCTSSoS.NCStatePolynomial}"><a class="docstring-binding" href="#Base.isone-Tuple{NCTSSoS.NCStatePolynomial}"><code>Base.isone</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.isone(ncsp::NCStatePolynomial) -&gt; Bool</code></pre><p>Check if an NCStatePolynomial is the identity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L920-L924">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.isone-Tuple{StatePolynomial}"><a class="docstring-binding" href="#Base.isone-Tuple{StatePolynomial}"><code>Base.isone</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.isone(sp::StatePolynomial) -&gt; Bool</code></pre><p>Check if a StatePolynomial is the identity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L267-L271">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.iszero-Tuple{NCTSSoS.NCStatePolynomial}"><a class="docstring-binding" href="#Base.iszero-Tuple{NCTSSoS.NCStatePolynomial}"><code>Base.iszero</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.iszero(ncsp::NCStatePolynomial) -&gt; Bool</code></pre><p>Check if an NCStatePolynomial is zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L895-L899">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.iszero-Tuple{StatePolynomial}"><a class="docstring-binding" href="#Base.iszero-Tuple{StatePolynomial}"><code>Base.iszero</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.iszero(sp::StatePolynomial) -&gt; Bool</code></pre><p>Check if a StatePolynomial is zero (has no terms).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L242-L246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.one-Union{Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.one-Union{Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.one(ncsp::NCStatePolynomial{C,ST,A,T}) where {C,ST,A,T}</code></pre><p>Create the identity NCStatePolynomial for the same type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L911-L915">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.one-Union{Tuple{StatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.one-Union{Tuple{StatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.one(sp::StatePolynomial{C,ST,A,T}) where {C,ST,A,T}</code></pre><p>Create the identity StatePolynomial for the same type as <code>sp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L258-L262">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.one-Union{Tuple{Type{NCTSSoS.NCStatePolynomial{C, ST, A, T}}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.one-Union{Tuple{Type{NCTSSoS.NCStatePolynomial{C, ST, A, T}}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.one(::Type{NCStatePolynomial{C,ST,A,T}}) where {C,ST,A,T}</code></pre><p>Create the identity NCStatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L902-L906">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.one-Union{Tuple{Type{StatePolynomial{C, ST, A, T}}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.one-Union{Tuple{Type{StatePolynomial{C, ST, A, T}}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.one(::Type{StatePolynomial{C,ST,A,T}}) where {C,ST,A,T}</code></pre><p>Create the identity StatePolynomial (1 * identity StateWord).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L249-L253">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.show-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{IO, NCTSSoS.NCStatePolynomial{C, ST, A, T}}} where {C, ST, A, T}"><a class="docstring-binding" href="#Base.show-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{IO, NCTSSoS.NCStatePolynomial{C, ST, A, T}}} where {C, ST, A, T}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.show(io::IO, ncsp::NCStatePolynomial{C,ST,A,T}) where {C,ST,A,T}</code></pre><p>Display an NCStatePolynomial. Uses registry from IO context if available for human-readable symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L1161-L1166">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.show-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{IO, StatePolynomial{C, ST, A, T}}} where {C, ST, A, T}"><a class="docstring-binding" href="#Base.show-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{IO, StatePolynomial{C, ST, A, T}}} where {C, ST, A, T}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.show(io::IO, sp::StatePolynomial{C,ST,A,T}) where {C,ST,A,T}</code></pre><p>Display a StatePolynomial. Uses registry from IO context if available for human-readable symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L685-L690">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.zero-Union{Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.zero-Union{Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.zero</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.zero(ncsp::NCStatePolynomial{C,ST,A,T}) where {C,ST,A,T}</code></pre><p>Create the zero NCStatePolynomial for the same type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L886-L890">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.zero-Union{Tuple{StatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.zero-Union{Tuple{StatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.zero</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.zero(sp::StatePolynomial{C,ST,A,T}) where {C,ST,A,T}</code></pre><p>Create the zero StatePolynomial for the same type as <code>sp</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L233-L237">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.zero-Union{Tuple{Type{NCTSSoS.NCStatePolynomial{C, ST, A, T}}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.zero-Union{Tuple{Type{NCTSSoS.NCStatePolynomial{C, ST, A, T}}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.zero</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.zero(::Type{NCStatePolynomial{C,ST,A,T}}) where {C,ST,A,T}</code></pre><p>Create the zero NCStatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L877-L881">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.zero-Union{Tuple{Type{StatePolynomial{C, ST, A, T}}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.zero-Union{Tuple{Type{StatePolynomial{C, ST, A, T}}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.zero</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.zero(::Type{StatePolynomial{C,ST,A,T}}) where {C,ST,A,T}</code></pre><p>Create the zero StatePolynomial (no terms).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L224-L228">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._process_state_terms-Union{Tuple{W}, Tuple{C}, Tuple{Vector{C}, Vector{W}}} where {C&lt;:Number, W}"><a class="docstring-binding" href="#NCTSSoS._process_state_terms-Union{Tuple{W}, Tuple{C}, Tuple{Vector{C}, Vector{W}}} where {C&lt;:Number, W}"><code>NCTSSoS._process_state_terms</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_process_state_terms(coeffs::Vector{C}, words::Vector{W}) where {C&lt;:Number, W}</code></pre><p>Sort, combine duplicates, and filter zeros for state polynomial construction. Returns (processed<em>coeffs, processed</em>words).</p><p>This is shared logic between StatePolynomial and NCStatePolynomial constructors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L5-L12">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._show_poly_coeff-Union{Tuple{C}, Tuple{IO, Number, Type{C}, Bool}} where C&lt;:Number"><a class="docstring-binding" href="#NCTSSoS._show_poly_coeff-Union{Tuple{C}, Tuple{IO, Number, Type{C}, Bool}} where C&lt;:Number"><code>NCTSSoS._show_poly_coeff</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_show_poly_coeff(io::IO, c::Number, ::Type{C}, is_first::Bool) where {C&lt;:Number}</code></pre><p>Format and print a polynomial term&#39;s coefficient with proper sign handling. Returns false (for next iteration&#39;s is_first flag).</p><p>Handles special cases:</p><ul><li>+1: prints nothing (first term) or &quot; + &quot; (subsequent)</li><li>-1: prints &quot;-&quot; (first term) or &quot; - &quot; (subsequent)</li><li>negative: prints value (first term) or &quot; - abs(value)&quot; (subsequent)</li><li>positive: prints value (first term) or &quot; + value&quot; (subsequent)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L46-L57">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.coefficients-Tuple{NCTSSoS.NCStatePolynomial}"><a class="docstring-binding" href="#NCTSSoS.coefficients-Tuple{NCTSSoS.NCStatePolynomial}"><code>NCTSSoS.coefficients</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">coefficients(ncsp::NCStatePolynomial) -&gt; Vector{C}</code></pre><p>Get the coefficients of the NCStatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L802-L806">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.coefficients-Tuple{StatePolynomial}"><a class="docstring-binding" href="#NCTSSoS.coefficients-Tuple{StatePolynomial}"><code>NCTSSoS.coefficients</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">coefficients(sp::StatePolynomial) -&gt; Vector{C}</code></pre><p>Get the coefficients of the StatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L139-L143">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.degree-Tuple{NCTSSoS.NCStatePolynomial}"><a class="docstring-binding" href="#NCTSSoS.degree-Tuple{NCTSSoS.NCStatePolynomial}"><code>NCTSSoS.degree</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">degree(ncsp::NCStatePolynomial) -&gt; Int</code></pre><p>Compute the maximum degree of all NC state words in the polynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L823-L827">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.degree-Tuple{StatePolynomial}"><a class="docstring-binding" href="#NCTSSoS.degree-Tuple{StatePolynomial}"><code>NCTSSoS.degree</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">degree(sp::StatePolynomial) -&gt; Int</code></pre><p>Compute the maximum degree of all state words in the polynomial. Returns 0 for the zero polynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L196-L201">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.expval-Union{Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#NCTSSoS.expval-Union{Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>NCTSSoS.expval</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">expval(ncsp::NCStatePolynomial) -&gt; StatePolynomial</code></pre><p>Compute the expectation value of an NCStatePolynomial.</p><p>Converts each NCStateWord to a StateWord using <code>expval</code> and combines with coefficients.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L1143-L1149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.expval-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><a class="docstring-binding" href="#NCTSSoS.expval-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number}"><code>NCTSSoS.expval</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">expval(::Type{ST}, p::Polynomial{A,T,C}) where {ST,A,T,C}</code></pre><p>Expectation value of a Polynomial.</p><p>Returns a <code>StatePolynomial</code> with the same coefficients, converting each <code>NormalMonomial</code> to a <code>StateWord{ST}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L179-L186">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.monomials-Tuple{NCTSSoS.NCStatePolynomial}"><a class="docstring-binding" href="#NCTSSoS.monomials-Tuple{NCTSSoS.NCStatePolynomial}"><code>NCTSSoS.monomials</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">monomials(ncsp::NCStatePolynomial) -&gt; Vector{NCStateWord}</code></pre><p>Get the NC state words of the NCStatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L809-L813">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.monomials-Tuple{StatePolynomial}"><a class="docstring-binding" href="#NCTSSoS.monomials-Tuple{StatePolynomial}"><code>NCTSSoS.monomials</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">monomials(sp::StatePolynomial) -&gt; Vector{StateWord}</code></pre><p>Get the state words of the StatePolynomial (these are the &quot;monomials&quot; in state space).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L146-L150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.terms-Tuple{NCTSSoS.NCStatePolynomial}"><a class="docstring-binding" href="#NCTSSoS.terms-Tuple{NCTSSoS.NCStatePolynomial}"><code>NCTSSoS.terms</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">terms(ncsp::NCStatePolynomial) -&gt; Zip</code></pre><p>Iterate over (coefficient, nc<em>state</em>word) pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L816-L820">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.terms-Tuple{StatePolynomial}"><a class="docstring-binding" href="#NCTSSoS.terms-Tuple{StatePolynomial}"><code>NCTSSoS.terms</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">terms(sp::StatePolynomial) -&gt; Zip</code></pre><p>Iterate over (coefficient, state_word) pairs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L153-L157">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.tr-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:MonoidAlgebra, T&lt;:Integer, C&lt;:Number}"><a class="docstring-binding" href="#NCTSSoS.tr-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:MonoidAlgebra, T&lt;:Integer, C&lt;:Number}"><code>NCTSSoS.tr</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tr(p::Polynomial{A,T,C}) -&gt; StatePolynomial</code></pre><p>Create a tracial StatePolynomial from a Polynomial. Converts each term&#39;s monomial to a <code>StateWord{MaxEntangled}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L736-L741">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.variable_indices-Union{Tuple{NCStateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST, A, T}"><a class="docstring-binding" href="#NCTSSoS.variable_indices-Union{Tuple{NCStateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST, A, T}"><code>NCTSSoS.variable_indices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">variable_indices(ncsw::NCStateWord) -&gt; Set{T}</code></pre><p>Get variable indices from an NCStateWord.</p><p>This is an alias for <code>variables()</code> that matches the naming convention used by regular NormalMonomial types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L859-L866">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.variable_indices-Union{Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C, ST, A, T}"><a class="docstring-binding" href="#NCTSSoS.variable_indices-Union{Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C, ST, A, T}"><code>NCTSSoS.variable_indices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">variable_indices(ncsp::NCStatePolynomial) -&gt; Set{T}</code></pre><p>Get all variable indices from an NCStatePolynomial. Extracts indices from both the StateWord and nc_word parts of each NCStateWord.</p><p>This is an alias for <code>variables()</code> that matches the naming convention used by regular Polynomial types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L846-L854">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.variables-Union{Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C, ST, A, T}"><a class="docstring-binding" href="#NCTSSoS.variables-Union{Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C, ST, A, T}"><code>NCTSSoS.variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">variables(ncsp::NCStatePolynomial) -&gt; Set</code></pre><p>Get the set of all variable indices used in the NCStatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L833-L837">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.variables-Union{Tuple{StatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C, ST, A, T}"><a class="docstring-binding" href="#NCTSSoS.variables-Union{Tuple{StatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C, ST, A, T}"><code>NCTSSoS.variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">variables(sp::StatePolynomial) -&gt; Set</code></pre><p>Get the set of all variable indices used in the StatePolynomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L207-L211">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.ς-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:MonoidAlgebra, T&lt;:Integer, C&lt;:Number}"><a class="docstring-binding" href="#NCTSSoS.ς-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A&lt;:MonoidAlgebra, T&lt;:Integer, C&lt;:Number}"><code>NCTSSoS.ς</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ς(p::Polynomial{A,T,C}) -&gt; StatePolynomial</code></pre><p>Create a StatePolynomial from a Polynomial. Converts each term&#39;s monomial to a StateWord{Arbitrary}.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m = NormalMonomial{ProjectorAlgebra}(UInt8[1, 2]);

julia&gt; p = Polynomial([(1.0, m)]);

julia&gt; sp = ς(p);

julia&gt; sp isa StatePolynomial
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/polynomial.jl#L708-L727">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.NCStateWord"><a class="docstring-binding" href="#NCTSSoS.NCStateWord"><code>NCTSSoS.NCStateWord</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">NCStateWord{ST&lt;:StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}</code></pre><p>A product of state expectations and a non-commutative operator: &lt;M1&gt;&lt;M2&gt;...&lt;Mk&gt; * Onc</p><p>Combines a commutative StateWord (expectations) with a non-commutative monomial (operator).</p><p><strong>Fields</strong></p><ul><li><code>sw::StateWord{ST,A,T}</code>: Commutative state word part</li><li><code>nc_word::NormalMonomial{A,T}</code>: Non-commutative operator part</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m1 = NormalMonomial{NonCommutativeAlgebra}([1, 2]);

julia&gt; m2 = NormalMonomial{NonCommutativeAlgebra}([3]);

julia&gt; sw = StateWord{Arbitrary}([m1]);

julia&gt; ncsw = NCStateWord(sw, m2);

julia&gt; degree(ncsw)
3</code></pre><p>See also: <a href="#NCTSSoS.StateWord"><code>StateWord</code></a>, <a href="#NCTSSoS.NCStatePolynomial"><code>NCStatePolynomial</code></a>, <a href="#NCTSSoS.expval-Union{Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C&lt;:Number, ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>expval</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L528-L556">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.StateSymbol"><a class="docstring-binding" href="#NCTSSoS.StateSymbol"><code>NCTSSoS.StateSymbol</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StateSymbol{ST&lt;:StateType, A&lt;:AlgebraType, T&lt;:Integer} &lt;: AbstractMonomial{A,T}</code></pre><p>A single state expectation symbol wrapping a canonicalized monomial.</p><p>StateSymbol is the atomic unit of state expectations. It stores a single monomial that has been canonicalized according to the state type:</p><ul><li><code>Arbitrary</code>: involution canon (min(m, adjoint(m)))</li><li><code>MaxEntangled</code>: cyclic<em>symmetric</em>canon(m)</li></ul><p><strong>Fields</strong></p><ul><li><code>mono::Vector{T}</code>: The canonicalized monomial</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>ST</code>: State type (Arbitrary or MaxEntangled)</li><li><code>A</code>: Algebra type</li><li><code>T</code>: Integer type for monomial words</li></ul><p><strong>Invariants</strong></p><ul><li>The monomial is always in canonical form for the given state type</li><li>Canonicalization happens automatically at construction</li></ul><p><strong>Note on non-monoid algebras</strong></p><p>For algebras where simplification can introduce phases (Pauli / <code>TwistedGroupAlgebra</code>) or multi-term PBW expansions (Fermionic/Bosonic / <code>PBWAlgebra</code>), the expectation value of a <code>Monomial</code> is not representable by a single <code>StateSymbol</code>. Use <code>expval(ST, m::Monomial)</code> to obtain a <code>StatePolynomial</code> (a linear combination of <code>StateWord</code>s) instead.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m = NormalMonomial{ProjectorAlgebra}(UInt8[1, 2]);

julia&gt; sym = StateSymbol{Arbitrary}(m);

julia&gt; degree(sym)
2</code></pre><p>See also: <a href="#NCTSSoS.StateWord"><code>StateWord</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L1-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.StateWord"><a class="docstring-binding" href="#NCTSSoS.StateWord"><code>NCTSSoS.StateWord</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StateWord{ST&lt;:StateType, A&lt;:AlgebraType, T&lt;:Integer} &lt;: AbstractMonomial{A,T}</code></pre><p>A product of state expectations &lt;M1&gt;&lt;M2&gt;...&lt;Mk&gt;.</p><p>The state expectations commute, so StateWord maintains symbols in sorted order. All symbols share the same algebra type A.</p><p><strong>Fields</strong></p><ul><li><code>state_syms::Vector{StateSymbol{ST,A,T}}</code>: Sorted, canonicalized state symbols</li></ul><p><strong>Type Parameters</strong></p><ul><li><code>ST</code>: State type (Arbitrary or MaxEntangled)</li><li><code>A</code>: Algebra type (all expectations use the same algebra)</li><li><code>T</code>: Integer type for monomial words</li></ul><p><strong>Invariants</strong></p><ol><li><strong>Canonicalization</strong>: Each symbol is canonicalized per state type</li><li><strong>Commutativity</strong>: state_syms is sorted by the symbol ordering</li><li>Identity symbols are filtered out (unless all are identity)</li></ol><div class="admonition is-warning" id="Real-expectation-values-c1643b5e7fbc0a3e"><header class="admonition-header">Real expectation values<a class="admonition-anchor" href="#Real-expectation-values-c1643b5e7fbc0a3e" title="Permalink"></a></header><div class="admonition-body"><p>The involution canonicalization enforces ⟨M⟩ = ⟨M†⟩, which means all expectation values are treated as real variables. This is appropriate for Hermitian moment optimization but restricts the variable space to real-valued expectations.</p></div></div><div class="admonition is-warning" id="MaxEntangled-(trace)-assumptions-420b1360628d9b2b"><header class="admonition-header">MaxEntangled (trace) assumptions<a class="admonition-anchor" href="#MaxEntangled-(trace)-assumptions-420b1360628d9b2b" title="Permalink"></a></header><div class="admonition-body"><p>The <code>MaxEntangled</code> (trace) state type uses cyclic-symmetric canonicalization, which assumes tr(M) = tr(reverse(M)). This can fail for algebras where transposition introduces signs/phases (e.g. Pauli algebra). <code>NCTSSoS.jl</code> restricts state polynomials to <code>MonoidAlgebra</code> (NC/Projector/Unipotent), so <code>PauliAlgebra</code> is not supported here.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m1 = NormalMonomial{NonCommutativeAlgebra}([1, 2]);

julia&gt; m2 = NormalMonomial{NonCommutativeAlgebra}([3]);

julia&gt; sw = StateWord{Arbitrary}([m1, m2]);

julia&gt; length(sw.state_syms)
2

julia&gt; degree(sw)
3</code></pre><p>See also: <a href="#NCTSSoS.StateSymbol"><code>StateSymbol</code></a>, <a href="#NCTSSoS.NCStateWord"><code>NCStateWord</code></a>, <a href="#NCTSSoS.StatePolynomial"><code>StatePolynomial</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L180-L231">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{NCStateWord{ST, A, T}, NCStateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{NCStateWord{ST, A, T}, NCStateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(*)(a::NCStateWord{ST,A,T}, b::NCStateWord{ST,A,T}) where {ST,A,T}</code></pre><p>Multiply two NCStateWords: multiply sw parts (commutative) and nc_word parts (non-commutative).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L625-L629">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateWord{ST, A, T}, StateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateWord{ST, A, T}, StateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(*)(a::StateWord{ST,A,T}, b::StateWord{ST,A,T}) where {ST,A,T}</code></pre><p>Multiply two StateWords by concatenating and re-sorting their symbols.</p><p>State expectations commute, so the result is a sorted StateWord containing all expectations from both operands.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m1 = NormalMonomial{NonCommutativeAlgebra}([1, 2]);

julia&gt; m2 = NormalMonomial{NonCommutativeAlgebra}([3]);

julia&gt; sw1 = StateWord{Arbitrary}([m1]);

julia&gt; sw2 = StateWord{Arbitrary}([m2]);

julia&gt; result = sw1 * sw2;

julia&gt; result isa StateWord
true

julia&gt; length(result.state_syms)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L437-L465">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:==-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{NCStateWord{ST, A, T}, NCStateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:==-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{NCStateWord{ST, A, T}, NCStateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(==)(a::NCStateWord{ST,A,T}, b::NCStateWord{ST,A,T}) where {ST,A,T} -&gt; Bool</code></pre><p>Check if two NCStateWords are equal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L594-L598">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:==-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateSymbol{ST, A, T}, StateSymbol{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:==-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateSymbol{ST, A, T}, StateSymbol{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(==)(a::StateSymbol{ST,A,T}, b::StateSymbol{ST,A,T}) where {ST,A,T} -&gt; Bool</code></pre><p>Check if two StateSymbols are equal (same canonicalized monomial).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L113-L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:==-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateWord{ST, A, T}, StateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.:==-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateWord{ST, A, T}, StateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.:(==)(a::StateWord{ST,A,T}, b::StateWord{ST,A,T}) where {ST,A,T} -&gt; Bool</code></pre><p>Check if two StateWords are equal (same state symbols).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L375-L379">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.adjoint-Union{Tuple{NCStateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.adjoint-Union{Tuple{NCStateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.adjoint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.adjoint(ncsw::NCStateWord{ST,A,T}) where {ST,A,T}</code></pre><p>Compute the adjoint (Hermitian conjugate) of an NCStateWord by adjointing both parts.</p><div class="admonition is-info" id="Physics-notation-3fdaf44d002235e"><header class="admonition-header">Physics notation<a class="admonition-anchor" href="#Physics-notation-3fdaf44d002235e" title="Permalink"></a></header><div class="admonition-body"><p>This is the dagger (†) or star (*) operation in physics notation. You can also use the Julia syntax <code>ncsw&#39;</code> as shorthand for <code>adjoint(ncsw)</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L645-L653">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.adjoint-Union{Tuple{StateSymbol{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.adjoint-Union{Tuple{StateSymbol{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.adjoint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.adjoint(sym::StateSymbol{ST,A,T}) where {ST,A,T}</code></pre><p>Return the StateSymbol itself (due to canonicalization, adjoint equals self).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L143-L147">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.adjoint-Union{Tuple{StateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.adjoint-Union{Tuple{StateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.adjoint</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.adjoint(sw::StateWord{ST,A,T}) where {ST,A,T}</code></pre><p>Compute the adjoint (Hermitian conjugate) of a StateWord. Due to the involution invariant, adjoint(sw) == sw for all StateWords.</p><div class="admonition is-info" id="Physics-notation-4a709e8d7996fa6e"><header class="admonition-header">Physics notation<a class="admonition-anchor" href="#Physics-notation-4a709e8d7996fa6e" title="Permalink"></a></header><div class="admonition-body"><p>This is the dagger (†) or star (*) operation in physics notation. You can also use the Julia syntax <code>sw&#39;</code> as shorthand for <code>adjoint(sw)</code>.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m = NormalMonomial{NonCommutativeAlgebra}([1, 2, 3]);

julia&gt; sw = StateWord{Arbitrary}([m]);

julia&gt; sw_adj = adjoint(sw);

julia&gt; sw == sw_adj  # Due to involution canonicalization
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L474-L497">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.hash-Tuple{NCStateWord, UInt64}"><a class="docstring-binding" href="#Base.hash-Tuple{NCStateWord, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.hash(ncsw::NCStateWord, h::UInt) -&gt; UInt</code></pre><p>Hash function for NCStateWord. Computed from sw and nc_word.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L603-L607">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.hash-Tuple{StateSymbol, UInt64}"><a class="docstring-binding" href="#Base.hash-Tuple{StateSymbol, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.hash(sym::StateSymbol, h::UInt) -&gt; UInt</code></pre><p>Hash function for StateSymbol.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L122-L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.hash-Tuple{StateWord, UInt64}"><a class="docstring-binding" href="#Base.hash-Tuple{StateWord, UInt64}"><code>Base.hash</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.hash(sw::StateWord, h::UInt) -&gt; UInt</code></pre><p>Hash function for StateWord. Computed from state_syms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L384-L388">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.isless-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{NCStateWord{ST, A, T}, NCStateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.isless-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{NCStateWord{ST, A, T}, NCStateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.isless(a::NCStateWord{ST,A,T}, b::NCStateWord{ST,A,T}) where {ST,A,T} -&gt; Bool</code></pre><p>Compare two NCStateWords: degree first, then nc_word, then sw.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L610-L614">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.isless-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateSymbol{ST, A, T}, StateSymbol{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.isless-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateSymbol{ST, A, T}, StateSymbol{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.isless(a::StateSymbol{ST,A,T}, b::StateSymbol{ST,A,T}) where {ST,A,T} -&gt; Bool</code></pre><p>Compare two StateSymbols: degree-first, then by monomial ordering.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L129-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.isless-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateWord{ST, A, T}, StateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.isless-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateWord{ST, A, T}, StateWord{ST, A, T}}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.isless(a::StateWord{ST,A,T}, b::StateWord{ST,A,T}) where {ST,A,T} -&gt; Bool</code></pre><p>Compare two StateWords using degree-first ordering, then lexicographic on state_syms.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m1 = NormalMonomial{NonCommutativeAlgebra}([1]);

julia&gt; m2 = NormalMonomial{NonCommutativeAlgebra}([1, 2]);

julia&gt; sw1 = StateWord{Arbitrary}([m1]);

julia&gt; sw2 = StateWord{Arbitrary}([m2]);

julia&gt; isless(sw1, sw2)  # degree 1 &lt; degree 2
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L391-L411">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.isone-Tuple{NCStateWord}"><a class="docstring-binding" href="#Base.isone-Tuple{NCStateWord}"><code>Base.isone</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.isone(ncsw::NCStateWord) -&gt; Bool</code></pre><p>Check if an NCStateWord is the identity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L772-L776">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.isone-Tuple{StateSymbol}"><a class="docstring-binding" href="#Base.isone-Tuple{StateSymbol}"><code>Base.isone</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.isone(sym::StateSymbol) -&gt; Bool</code></pre><p>Check if a StateSymbol wraps the identity monomial.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L78-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.isone-Tuple{StateWord}"><a class="docstring-binding" href="#Base.isone-Tuple{StateWord}"><code>Base.isone</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.isone(sw::StateWord) -&gt; Bool</code></pre><p>Check if a StateWord is the identity (single identity symbol).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; sw_one = one(StateWord{Arbitrary,NonCommutativeAlgebra,Int64});

julia&gt; isone(sw_one)
true

julia&gt; m = NormalMonomial{NonCommutativeAlgebra}([1]);

julia&gt; sw = StateWord{Arbitrary}([m]);

julia&gt; isone(sw)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L292-L313">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.one-Union{Tuple{NCStateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.one-Union{Tuple{NCStateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.one(ncsw::NCStateWord{ST,A,T}) where {ST,A,T}</code></pre><p>Create the identity NCStateWord for the same type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L763-L767">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.one-Union{Tuple{StateSymbol{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.one-Union{Tuple{StateSymbol{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.one(sym::StateSymbol{ST,A,T}) where {ST,A,T}</code></pre><p>Create the identity StateSymbol for the same type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L69-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.one-Union{Tuple{StateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.one-Union{Tuple{StateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.one(sw::StateWord{ST,A,T}) where {ST,A,T}</code></pre><p>Create the identity StateWord for the same type as <code>sw</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L283-L287">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.one-Union{Tuple{Type{NCStateWord{ST, A, T}}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#Base.one-Union{Tuple{Type{NCStateWord{ST, A, T}}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.one(::Type{NCStateWord{ST,A,T}}) where {ST,A,T}</code></pre><p>Create the identity NCStateWord.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L754-L758">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.one-Union{Tuple{Type{StateSymbol{ST, A, T}}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.one-Union{Tuple{Type{StateSymbol{ST, A, T}}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.one(::Type{StateSymbol{ST,A,T}}) where {ST,A,T}</code></pre><p>Create the identity StateSymbol (wrapping identity monomial).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L60-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.one-Union{Tuple{Type{StateWord{ST, A, T}}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#Base.one-Union{Tuple{Type{StateWord{ST, A, T}}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:AlgebraType, T&lt;:Integer}"><code>Base.one</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.one(::Type{StateWord{ST,A,T}}) where {ST,A,T}</code></pre><p>Create the identity StateWord (single identity symbol).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; sw_one = one(StateWord{Arbitrary,NonCommutativeAlgebra,Int64});

julia&gt; isone(sw_one)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L264-L278">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.show-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{IO, NCStateWord{ST, A, T}}} where {ST, A, T}"><a class="docstring-binding" href="#Base.show-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{IO, NCStateWord{ST, A, T}}} where {ST, A, T}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.show(io::IO, ncsw::NCStateWord{ST,A,T}) where {ST,A,T}</code></pre><p>Display an NCStateWord. Uses registry from IO context if available for human-readable symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L733-L738">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.show-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{IO, StateSymbol{ST, A, T}}} where {ST, A, T}"><a class="docstring-binding" href="#Base.show-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{IO, StateSymbol{ST, A, T}}} where {ST, A, T}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.show(io::IO, sym::StateSymbol{ST,A,T}) where {ST,A,T}</code></pre><p>Display a StateSymbol with appropriate brackets based on state type.</p><ul><li>Arbitrary: ⟨mono⟩</li><li>MaxEntangled: tr(mono)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L157-L163">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.show-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{IO, StateWord{ST, A, T}}} where {ST, A, T}"><a class="docstring-binding" href="#Base.show-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{IO, StateWord{ST, A, T}}} where {ST, A, T}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.show(io::IO, sw::StateWord{ST,A,T}) where {ST,A,T}</code></pre><p>Display a StateWord with appropriate brackets based on state type. Uses registry from IO context if available for human-readable symbols.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L508-L513">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._generate_statewords_up_to_degree-Union{Tuple{ST}, Tuple{T}, Tuple{A}, Tuple{Array{NormalMonomial{A, T}, 1}, Int64, Type{ST}}} where {A&lt;:AlgebraType, T&lt;:Integer, ST&lt;:NCTSSoS.StateType}"><a class="docstring-binding" href="#NCTSSoS._generate_statewords_up_to_degree-Union{Tuple{ST}, Tuple{T}, Tuple{A}, Tuple{Array{NormalMonomial{A, T}, 1}, Int64, Type{ST}}} where {A&lt;:AlgebraType, T&lt;:Integer, ST&lt;:NCTSSoS.StateType}"><code>NCTSSoS._generate_statewords_up_to_degree</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_generate_statewords_up_to_degree(monos, max_deg, ST) -&gt; Vector{StateWord}</code></pre><p>Generate all StateWords with total degree &lt;= max_deg.</p><p>Includes:</p><ul><li>Identity StateWord &lt;I&gt; (degree 0)</li><li>Single expectations &lt;M&gt;</li><li>Compound expectations &lt;M1&gt;&lt;M2&gt;, &lt;M1&gt;&lt;M2&gt;&lt;M3&gt;, etc.</li></ul><p><strong>Arguments</strong></p><ul><li><code>monos</code>: Vector of all available monomials</li><li><code>max_deg</code>: Maximum total degree for the StateWord</li><li><code>ST</code>: StateType (Arbitrary or MaxEntangled)</li></ul><p><strong>Returns</strong></p><p>Vector of unique, sorted StateWords.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L976-L993">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.degree-Tuple{NCStateWord}"><a class="docstring-binding" href="#NCTSSoS.degree-Tuple{NCStateWord}"><code>NCTSSoS.degree</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">degree(ncsw::NCStateWord) -&gt; Int</code></pre><p>Compute the total degree of an NCStateWord (sw degree + nc_word degree).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L570-L574">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.degree-Tuple{StateSymbol}"><a class="docstring-binding" href="#NCTSSoS.degree-Tuple{StateSymbol}"><code>NCTSSoS.degree</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">degree(sym::StateSymbol) -&gt; Int</code></pre><p>Compute the degree of a StateSymbol (degree of its monomial).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L89-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.degree-Tuple{StateWord}"><a class="docstring-binding" href="#NCTSSoS.degree-Tuple{StateWord}"><code>NCTSSoS.degree</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">degree(sw::StateWord) -&gt; Int</code></pre><p>Compute the total degree of a StateWord (sum of symbol degrees).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m1 = NormalMonomial{NonCommutativeAlgebra}([1, 2]);  # degree 2

julia&gt; m2 = NormalMonomial{NonCommutativeAlgebra}([3]);     # degree 1

julia&gt; sw = StateWord{Arbitrary}([m1, m2]);

julia&gt; degree(sw)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L320-L338">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.expval-Union{Tuple{NCStateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#NCTSSoS.expval-Union{Tuple{NCStateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST&lt;:NCTSSoS.StateType, A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>NCTSSoS.expval</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">expval(ncsw::NCStateWord{ST,A,T}) where {ST,A,T}</code></pre><p>Collapse NCStateWord to StateWord by adding nc_word as an expectation.</p><p>Converts <code>&lt;M1&gt;&lt;M2&gt;...&lt;Mk&gt; * Onc</code> to <code>&lt;M1&gt;&lt;M2&gt;...&lt;Mk&gt;&lt;Onc&gt;</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m1 = NormalMonomial{NonCommutativeAlgebra}([1, 2]);

julia&gt; m2 = NormalMonomial{NonCommutativeAlgebra}([3, 4]);

julia&gt; sw = StateWord{Arbitrary}([m1]);

julia&gt; ncsw = NCStateWord(sw, m2);

julia&gt; ev = expval(ncsw);

julia&gt; length(ev.state_syms)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L685-L709">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.get_state_basis-Union{Tuple{ST}, Tuple{T}, Tuple{A}, Tuple{VariableRegistry{A, T}, Int64}} where {A&lt;:MonoidAlgebra, T&lt;:Integer, ST&lt;:NCTSSoS.StateType}"><a class="docstring-binding" href="#NCTSSoS.get_state_basis-Union{Tuple{ST}, Tuple{T}, Tuple{A}, Tuple{VariableRegistry{A, T}, Int64}} where {A&lt;:MonoidAlgebra, T&lt;:Integer, ST&lt;:NCTSSoS.StateType}"><code>NCTSSoS.get_state_basis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_state_basis(registry::VariableRegistry{A,T}, d::Int;
                state_type::Type{ST}=Arbitrary) where {A&lt;:AlgebraType, T&lt;:Integer, ST&lt;:StateType}</code></pre><p>Generate a basis of NCStateWord elements up to degree d.</p><p>This function generates all unique NCStateWord basis elements that can be formed from the variables in the registry up to the specified degree. The basis includes all (StateWord, Monomial) combinations where <code>degree(sw) + degree(nc_word) &lt;= d</code>.</p><p>This generates:</p><ul><li><code>&lt;I&gt;*M</code> forms (identity StateWord, operator monomial)</li><li><code>&lt;M&gt;*I</code> forms (single expectation, identity operator)</li><li><code>&lt;M1&gt;&lt;M2&gt;*I</code> forms (compound expectations, identity operator)</li><li><code>&lt;M&gt;*N</code> mixed forms (expectation with operator)</li></ul><p><strong>Arguments</strong></p><ul><li><code>registry</code>: Variable registry containing the variable indices</li><li><code>d</code>: Maximum total degree (inclusive)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>state_type</code>: The state type for the basis elements (default: <code>Arbitrary</code>)</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{NCStateWord{ST,A,T}}</code>: Sorted unique NCStateWord basis elements</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; reg, (x,) = create_unipotent_variables([(&quot;x&quot;, 1:2)]);

julia&gt; basis = get_state_basis(reg, 1);

julia&gt; length(basis)  # includes &lt;I&gt;*I, &lt;I&gt;*x1, &lt;I&gt;*x2, &lt;x1&gt;*I, &lt;x2&gt;*I
5

julia&gt; all(b -&gt; b isa NCStateWord{Arbitrary}, basis)
true</code></pre><p>For projector algebra:</p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; reg, (P,) = create_projector_variables([(&quot;P&quot;, 1:2)]);

julia&gt; basis = get_state_basis(reg, 2; state_type=MaxEntangled);

julia&gt; all(b -&gt; b isa NCStateWord{MaxEntangled}, basis)
true</code></pre><p>See also: <a href="#NCTSSoS.NCStateWord"><code>NCStateWord</code></a>, <a href="#NCTSSoS.get_ncbasis-Union{Tuple{T}, Tuple{A}, Tuple{VariableRegistry{A, T}, Int64}} where {A&lt;:AlgebraType, T&lt;:Integer}"><code>get_ncbasis</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L873-L927">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.neat_dot-Tuple{NCStateWord, NCStateWord}"><a class="docstring-binding" href="#NCTSSoS.neat_dot-Tuple{NCStateWord, NCStateWord}"><code>NCTSSoS.neat_dot</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">neat_dot(x::NCStateWord, y::NCStateWord)</code></pre><p>Compute adjoint(x) * y. Common operation in quantum optimization.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m = NormalMonomial{NonCommutativeAlgebra}([1]);

julia&gt; sw = StateWord{Arbitrary}([m]);

julia&gt; ncsw = NCStateWord(sw, m);

julia&gt; nd = neat_dot(ncsw, ncsw);

julia&gt; nd == adjoint(ncsw) * ncsw
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L662-L682">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.tr-Union{Tuple{NormalMonomial{A, T}}, Tuple{T}, Tuple{A}} where {A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#NCTSSoS.tr-Union{Tuple{NormalMonomial{A, T}}, Tuple{T}, Tuple{A}} where {A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>NCTSSoS.tr</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tr(m::NormalMonomial{A,T}) where {A,T}</code></pre><p>Create a StateSymbol{MaxEntangled} from a monomial.</p><p>This is a convenience function for creating trace expressions in the maximally entangled state formalism. Equivalent to <code>StateSymbol{MaxEntangled}(m)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m = NormalMonomial{NonCommutativeAlgebra}([1, 2]);

julia&gt; sym = tr(m);

julia&gt; sym isa StateSymbol{MaxEntangled}
true</code></pre><p>tr(m::NormalMonomial{A,T}) where {A&lt;:MonoidAlgebra,T&lt;:Integer} = StateSymbol{MaxEntangled}(m) tr(pairs::Vector{Tuple{Val{1},NormalMonomial{A,T}}}) where {A&lt;:MonoidAlgebra,T&lt;:Integer} = StateSymbol{MaxEntangled}(pairs)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L845-L866">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.variables-Union{Tuple{NCStateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST, A, T}"><a class="docstring-binding" href="#NCTSSoS.variables-Union{Tuple{NCStateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST, A, T}"><code>NCTSSoS.variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">variables(ncsw::NCStateWord) -&gt; Set</code></pre><p>Get the set of all variable indices used in the NCStateWord.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L577-L581">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.variables-Union{Tuple{StateSymbol{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST, A, T}"><a class="docstring-binding" href="#NCTSSoS.variables-Union{Tuple{StateSymbol{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST, A, T}"><code>NCTSSoS.variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">variables(sym::StateSymbol{ST,A,T}) -&gt; Set{T}</code></pre><p>Get the set of variable indices used in the StateSymbol.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L96-L100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.variables-Union{Tuple{StateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST, A, T}"><a class="docstring-binding" href="#NCTSSoS.variables-Union{Tuple{StateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST, A, T}"><code>NCTSSoS.variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">variables(sw::StateWord) -&gt; Set</code></pre><p>Get the set of all variable indices used in the StateWord&#39;s symbols.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m1 = NormalMonomial{NonCommutativeAlgebra}([1, 2]);

julia&gt; m2 = NormalMonomial{NonCommutativeAlgebra}([2, 3]);

julia&gt; sw = StateWord{Arbitrary}([m1, m2]);

julia&gt; sort(collect(variables(sw)))
3-element Vector{Int64}:
 1
 2
 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L341-L362">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.ς-Union{Tuple{NormalMonomial{A, T}}, Tuple{T}, Tuple{A}} where {A&lt;:MonoidAlgebra, T&lt;:Integer}"><a class="docstring-binding" href="#NCTSSoS.ς-Union{Tuple{NormalMonomial{A, T}}, Tuple{T}, Tuple{A}} where {A&lt;:MonoidAlgebra, T&lt;:Integer}"><code>NCTSSoS.ς</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ς(m::NormalMonomial{A,T}) where {A,T}</code></pre><p>Create a StateWord{Arbitrary} from a monomial.</p><p>This is a convenience function for creating state expectations in the arbitrary state formalism. Equivalent to <code>StateWord{Arbitrary}(m)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; m = NormalMonomial{NonCommutativeAlgebra}([1, 2]);

julia&gt; sym = ς(m);

julia&gt; sym isa StateWord{Arbitrary}
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/states/word.jl#L820-L839">source</a></section></details></article><h2 id="Simplification-Interface"><a class="docs-heading-anchor" href="#Simplification-Interface">Simplification Interface</a><a id="Simplification-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Simplification-Interface" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="NCTSSoS._pauli_product-Tuple{Int64, Int64}"><a class="docstring-binding" href="#NCTSSoS._pauli_product-Tuple{Int64, Int64}"><code>NCTSSoS._pauli_product</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_pauli_product(type1::Int, type2::Int) -&gt; Tuple{UInt8, Int}</code></pre><p>Compute the product of two Pauli operators on the SAME site. Returns (phase<em>k</em>delta, result_type) where:</p><ul><li>phase<em>k</em>delta ∈ 0:3 encodes phase contribution as (im)^phase<em>k</em>delta</li><li>result_type is 0, 1, or 2 (or -1 for identity)</li></ul><p>If type1 == type2, returns (0, -1) to indicate identity (σᵢ² = I).</p><p>Phase encoding: 0 → 1, 1 → i, 2 → -1, 3 → -i</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/pauli.jl#L83-L94">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._validate_word-Union{Tuple{T}, Tuple{Type{PauliAlgebra}, Vector{T}}} where T&lt;:Integer"><a class="docstring-binding" href="#NCTSSoS._validate_word-Union{Tuple{T}, Tuple{Type{PauliAlgebra}, Vector{T}}} where T&lt;:Integer"><code>NCTSSoS._validate_word</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_validate_pauli_word!(word::Vector{T}) where {T&lt;:Integer}</code></pre><p>Check that a Pauli word is in canonical form. Throws <code>ArgumentError</code> if invalid.</p><p>Canonical form requirements:</p><ul><li>≤1 operator per site (no σ² terms)</li><li>Sites sorted in ascending order</li></ul><p>This is used by <code>NormalMonomial{PauliAlgebra,T}</code> constructor to enforce invariants.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/pauli.jl#L46-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.simplify!-Union{Tuple{T}, Tuple{Type{PauliAlgebra}, Vector{T}}} where T&lt;:Integer"><a class="docstring-binding" href="#NCTSSoS.simplify!-Union{Tuple{T}, Tuple{Type{PauliAlgebra}, Vector{T}}} where T&lt;:Integer"><code>NCTSSoS.simplify!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simplify!(::Type{PauliAlgebra}, word::Vector{T}) where {T&lt;:Integer} -&gt; Tuple{Vector{T}, UInt8}</code></pre><p>In-place site-aware simplification for Pauli algebra word vectors.</p><p>Operators on different sites commute and are sorted by site (ascending). Within each site, Pauli product rules apply: σₓσᵧ = iσz, σᵢ² = I, etc.</p><p>Returns a tuple of (word, phase_k) where:</p><ul><li>word is the input vector, mutated and resized in-place</li><li>phase<em>k ∈ 0:3 encodes the accumulated phase as (im)^phase</em>k</li></ul><p>Phase encoding: 0 → 1, 1 → i, 2 → -1, 3 → -i</p><p><strong>Algorithm</strong></p><ol><li>Stable sort by site (using <code>_pauli_site</code>)</li><li>Two-pointer reduction: read<em>idx scans groups, write</em>idx writes results</li><li>Resize to truncate trailing elements</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/pauli.jl#L119-L137">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.simplify-Union{Tuple{T}, Tuple{Type{PauliAlgebra}, Vector{T}}} where T&lt;:Integer"><a class="docstring-binding" href="#NCTSSoS.simplify-Union{Tuple{T}, Tuple{Type{PauliAlgebra}, Vector{T}}} where T&lt;:Integer"><code>NCTSSoS.simplify</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simplify(::Type{PauliAlgebra}, word::Vector{T}) where {T&lt;:Integer}</code></pre><p>Simplify a raw Pauli word into canonical form.</p><p>This is the primary entry point for Pauli simplification. Takes a raw word vector and returns a <code>(word, phase)</code> tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/pauli.jl#L204-L211">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.iszero-Union{Tuple{NormalMonomial{FermionicAlgebra, T}}, Tuple{T}} where T"><a class="docstring-binding" href="#Base.iszero-Union{Tuple{NormalMonomial{FermionicAlgebra, T}}, Tuple{T}} where T"><code>Base.iszero</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.iszero(m::NormalMonomial{FermionicAlgebra,T}) -&gt; Bool</code></pre><p>Check if a fermionic monomial is zero due to nilpotency.</p><p><strong>Algorithm</strong></p><p>A fermionic monomial is zero if for any mode, the net surplus of operators (annihilation minus creation, or vice versa) is 2 or more. This is because:</p><ul><li><code>aᵢ aᵢ = 0</code> (two annihilations with no creation to contract)</li><li><code>aᵢ† aᵢ† = 0</code> (two creations with no annihilation to contract)</li></ul><p>The key insight is that anticommutation <code>{aᵢ, aⱼ} = 0</code> allows reordering, but if there&#39;s a net surplus of ≥2 same-type operators for any mode, they cannot all be contracted away and the result is zero.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; m = NormalMonomial{FermionicAlgebra}(Int32[1, 1]);  # a₁ a₁ = 0 (surplus 2)

julia&gt; iszero(m)
true

julia&gt; m2 = NormalMonomial{FermionicAlgebra}(Int32[1, 2, 1]);  # a₁ a₂ a₁ = -a₁ a₁ a₂ = 0

julia&gt; iszero(m2)
true

julia&gt; m3 = NormalMonomial{FermionicAlgebra}(Int32[1, 1, -1]);  # a₁ a₁ a₁† (surplus 1, not zero yet)

julia&gt; iszero(m3)
false

julia&gt; m4 = NormalMonomial{FermionicAlgebra}(Int32[1, -1, 1, -1]);  # a₁ a₁† a₁ a₁† ≠ 0

julia&gt; iszero(m4)
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/fermionic.jl#L67-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._compute_normal_ordered_term-Union{Tuple{T}, Tuple{Vector{T}, Vector{Tuple{Int64, Int64}}}} where T"><a class="docstring-binding" href="#NCTSSoS._compute_normal_ordered_term-Union{Tuple{T}, Tuple{Vector{T}, Vector{Tuple{Int64, Int64}}}} where T"><code>NCTSSoS._compute_normal_ordered_term</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_compute_normal_ordered_term(word::Vector{T}, contraction::Vector{Tuple{Int,Int}}) where T</code></pre><p>Steps 3-4 of Wick&#39;s algorithm: Form N-product and evaluate sign.</p><p>For a given contraction combination:</p><ol><li>Remove contracted operator pairs from the word</li><li>Normal-order remaining operators (creators left, annihilators right, sorted by mode)</li><li>Compute sign from the permutation required</li><li>Check for nilpotency (duplicate operators → zero)</li></ol><p>Returns (coefficient, normal<em>ordered</em>word).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/fermionic.jl#L318-L330">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._contraction_sign-Union{Tuple{T}, Tuple{Vector{T}, Vector{Tuple{Int64, Int64}}}} where T"><a class="docstring-binding" href="#NCTSSoS._contraction_sign-Union{Tuple{T}, Tuple{Vector{T}, Vector{Tuple{Int64, Int64}}}} where T"><code>NCTSSoS._contraction_sign</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_contraction_sign(word::Vector{T}, contraction::Vector{Tuple{Int,Int}}) where T</code></pre><p>Compute the sign from bringing contracted pairs together.</p><p>For each contraction (i, j), we count the number of uncontracted operators between positions i and j. Each such operator requires a swap to bring the pair together, contributing a factor of -1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/fermionic.jl#L278-L286">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._find_valid_contractions-Union{Tuple{Vector{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#NCTSSoS._find_valid_contractions-Union{Tuple{Vector{T}}, Tuple{T}} where T"><code>NCTSSoS._find_valid_contractions</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_find_valid_contractions(word::Vector{T}) -&gt; Vector{Tuple{Int,Int}}</code></pre><p>Step 1 of Wick&#39;s algorithm: Identify all pairs with non-zero contractions.</p><p>For fermions, a contraction is non-zero only when:</p><ul><li>Position i has annihilation operator (positive index)</li><li>Position j &gt; i has creation operator (negative index)</li><li>Both have the same mode (|word[i]| == |word[j]|)</li></ul><p>This represents aᵢ followed by aᵢ† where {aᵢ, aᵢ†} = 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/fermionic.jl#L204-L215">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._generate_nonoverlapping_combinations-Tuple{Vector{Tuple{Int64, Int64}}}"><a class="docstring-binding" href="#NCTSSoS._generate_nonoverlapping_combinations-Tuple{Vector{Tuple{Int64, Int64}}}"><code>NCTSSoS._generate_nonoverlapping_combinations</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_generate_nonoverlapping_combinations(contractions::Vector{Tuple{Int,Int}}) -&gt; Vector{Vector{Tuple{Int,Int}}}</code></pre><p>Step 2 of Wick&#39;s algorithm: Generate all non-overlapping combinations.</p><p>Returns all subsets of contractions where no two pairs share an index. Includes the empty set (no contractions).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/fermionic.jl#L235-L242">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._is_fermionic_nilpotent-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Signed"><a class="docstring-binding" href="#NCTSSoS._is_fermionic_nilpotent-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Signed"><code>NCTSSoS._is_fermionic_nilpotent</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_is_fermionic_nilpotent(word::Vector{T}) where {T&lt;:Signed} -&gt; Bool</code></pre><p>Check if a fermionic word contains repeated identical operators (nilpotent: aᵢ² = 0 or (a†ᵢ)² = 0).</p><p>Note: aᵢ and a†ᵢ are DIFFERENT operators (indices 1 and -1 for mode 1), so [1, -1] is NOT nilpotent, but [1, 1] or [-1, -1] are.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/fermionic.jl#L523-L530">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._is_nilpotent_by_flux-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Signed"><a class="docstring-binding" href="#NCTSSoS._is_nilpotent_by_flux-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Signed"><code>NCTSSoS._is_nilpotent_by_flux</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_is_nilpotent_by_flux(word::Vector{T}) where {T&lt;:Signed} -&gt; Bool</code></pre><p>Check if a raw fermionic word is nilpotent using flux-based detection. A fermionic word is zero if any mode has net surplus &gt;= 2 (same-type operators).</p><p>This is the Vector{T} version of iszero(::NormalMonomial{FermionicAlgebra}) for use before a NormalMonomial is constructed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/fermionic.jl#L134-L142">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._permutation_parity-Tuple{VT} where VT&lt;:(AbstractVector{&lt;:Integer})"><a class="docstring-binding" href="#NCTSSoS._permutation_parity-Tuple{VT} where VT&lt;:(AbstractVector{&lt;:Integer})"><code>NCTSSoS._permutation_parity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_permutation_parity(perm::AbstractVector{&lt;:Integer}) -&gt; Int</code></pre><p>Compute the parity (sign) of a permutation using the cycle counting algorithm.</p><p><strong>Algorithm</strong></p><p>The sign of a permutation equals <code>(-1)^(n - c)</code> where:</p><ul><li><code>n</code> is the length of the permutation</li><li><code>c</code> is the number of disjoint cycles</li></ul><p><strong>Returns</strong></p><ul><li><code>1</code> for even permutations (even number of swaps)</li><li><code>-1</code> for odd permutations (odd number of swaps)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/fermionic.jl#L169-L182">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._simplify_fermionic_word!-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Integer"><a class="docstring-binding" href="#NCTSSoS._simplify_fermionic_word!-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Integer"><code>NCTSSoS._simplify_fermionic_word!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_simplify_fermionic_word!(word::Vector{T}) where {T&lt;:Integer} -&gt; Vector{Tuple{Int,Vector{T}}}</code></pre><p>Normal-order a fermionic word using Generalized Wick&#39;s Theorem.</p><p>Returns a vector of (coefficient, normal<em>ordered</em>word) pairs representing the sum:   Σ coeffs[i] * word[i]</p><p>This is the low-level function used by <code>simplify(FermionicAlgebra, word)</code>. Integer coefficients are exact (from anticommutation signs).</p><p><strong>Algorithm</strong></p><ol><li>Find all valid contractions (aᵢ...aᵢ† pairs with same mode)</li><li>Generate all non-overlapping contraction combinations</li><li>For each combination, compute the normal-ordered term with sign</li><li>Combine like terms</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/fermionic.jl#L383-L399">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._validate_word-Union{Tuple{T}, Tuple{Type{FermionicAlgebra}, Vector{T}}} where T&lt;:Signed"><a class="docstring-binding" href="#NCTSSoS._validate_word-Union{Tuple{T}, Tuple{Type{FermionicAlgebra}, Vector{T}}} where T&lt;:Signed"><code>NCTSSoS._validate_word</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_validate_fermionic_word!(word::Vector{T}) where {T&lt;:Signed}</code></pre><p>Check that a fermionic word is in normal-ordered form. Throws <code>ArgumentError</code> if invalid.</p><p>Normal order requirements:</p><ul><li>Creation operators (negative indices) come before annihilation operators (positive)</li><li>Creators sorted by mode descending; annihilators sorted by mode ascending</li></ul><p>This is used by <code>NormalMonomial{FermionicAlgebra,T}</code> constructor to enforce invariants.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/fermionic.jl#L544-L554">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.has_even_parity-Union{Tuple{NormalMonomial{FermionicAlgebra, T}}, Tuple{T}} where T"><a class="docstring-binding" href="#NCTSSoS.has_even_parity-Union{Tuple{NormalMonomial{FermionicAlgebra, T}}, Tuple{T}} where T"><code>NCTSSoS.has_even_parity</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_even_parity(m::NormalMonomial{FermionicAlgebra,T}) where T -&gt; Bool</code></pre><p>Check if a fermionic monomial has even parity (even number of operators).</p><p>In fermionic systems, parity superselection forbids observables with odd fermion number from having non-zero expectation values. Only operators with even parity (even number of creation/annihilation operators) can have non-zero physical expectation values.</p><p><strong>Arguments</strong></p><ul><li><code>m::NormalMonomial{FermionicAlgebra,T}</code>: A fermionic monomial</li></ul><p><strong>Returns</strong></p><ul><li><code>true</code> if the monomial has an even number of operators (including 0 for identity)</li><li><code>false</code> if the monomial has an odd number of operators</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; registry, (a, a_dag) = create_fermionic_variables(1:2);

julia&gt; has_even_parity(one(typeof(a[1])))  # Identity has 0 operators
true

julia&gt; has_even_parity(a[1])  # Single annihilation: 1 operator (odd)
false

julia&gt; has_even_parity(a_dag[1] * a[1])  # Number operator: 2 operators (even)
true</code></pre><p>See also: <a href="#NCTSSoS.FermionicAlgebra"><code>FermionicAlgebra</code></a>, <a href="#NCTSSoS.simplify-Union{Tuple{ComposedMonomial{As, Ts}}, Tuple{Ts}, Tuple{As}} where {As&lt;:Tuple, Ts&lt;:Tuple}"><code>simplify</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/fermionic.jl#L28-L62">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.simplify!-Union{Tuple{T}, Tuple{Type{FermionicAlgebra}, Vector{T}}} where T&lt;:Signed"><a class="docstring-binding" href="#NCTSSoS.simplify!-Union{Tuple{T}, Tuple{Type{FermionicAlgebra}, Vector{T}}} where T&lt;:Signed"><code>NCTSSoS.simplify!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simplify!(::Type{FermionicAlgebra}, word::Vector{T}) where {T&lt;:Signed} -&gt; Vector{Tuple{Int,Vector{T}}}</code></pre><p>Low-level in-place normal ordering of a fermionic word.</p><p>Returns a vector of <code>(coefficient, normal_ordered_word)</code> pairs representing the PBW expansion as a sum. Each word in the result is unique (coefficients are accumulated for identical words). Modifies <code>word</code> in-place (filters zeros).</p><p>This is the internal workhorse; most users should call <code>simplify(FermionicAlgebra, word)</code>.</p><p><strong>Algorithm</strong></p><p>Uses Generalized Wick&#39;s Theorem:</p><ol><li>Find all valid contractions (aᵢ...aᵢ† pairs with same mode)</li><li>Generate all non-overlapping contraction combinations</li><li>For each combination, compute the normal-ordered term with sign</li><li>Combine like terms</li></ol><p><strong>Throws</strong></p><ul><li><code>ErrorException</code> if simplification produces an empty result (should not happen for valid input)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/fermionic.jl#L460-L480">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.simplify-Union{Tuple{T}, Tuple{Type{FermionicAlgebra}, Vector{T}}} where T&lt;:Signed"><a class="docstring-binding" href="#NCTSSoS.simplify-Union{Tuple{T}, Tuple{Type{FermionicAlgebra}, Vector{T}}} where T&lt;:Signed"><code>NCTSSoS.simplify</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simplify(::Type{FermionicAlgebra}, word::Vector{T}) where {T&lt;:Signed} -&gt; Vector{Tuple{Int,Vector{T}}}</code></pre><p>Simplify a raw fermionic word into normal-ordered form.</p><p>This is the primary entry point for fermionic simplification. Takes a raw word vector and returns a vector of <code>(coefficient, normal_ordered_word)</code> pairs representing the canonical normal-ordered representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/fermionic.jl#L449-L457">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._validate_word-Union{Tuple{T}, Tuple{Type{BosonicAlgebra}, Vector{T}}} where T&lt;:Signed"><a class="docstring-binding" href="#NCTSSoS._validate_word-Union{Tuple{T}, Tuple{Type{BosonicAlgebra}, Vector{T}}} where T&lt;:Signed"><code>NCTSSoS._validate_word</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_validate_word(::Type{BosonicAlgebra}, word::Vector{T}) where {T&lt;:Signed}</code></pre><p>Validate that a bosonic word is in normal-ordered form.</p><p>Throws <code>ArgumentError</code> if the word violates normal ordering. Called by the <code>NormalMonomial{BosonicAlgebra,T}</code> constructor to enforce invariants.</p><p>Normal order requirements:</p><ul><li>Creation operators (negative indices) before annihilation operators (positive)</li><li>Creators sorted by mode descending; annihilators sorted by mode ascending</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/bosonic.jl#L349-L360">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.build_ferrers_board-Union{Tuple{V}, Tuple{T}} where {T, V&lt;:AbstractVector{T}}"><a class="docstring-binding" href="#NCTSSoS.build_ferrers_board-Union{Tuple{V}, Tuple{T}} where {T, V&lt;:AbstractVector{T}}"><code>NCTSSoS.build_ferrers_board</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">build_ferrers_board(ops::AbstractVector{T}) -&gt; Vector{Int}</code></pre><p>Build a Ferrers board from an operator sequence (single mode). Returns column heights where board[j] = number of creations AFTER annihilation j.</p><p>The board has n columns (one per annihilation) and m rows (one per creation). Cell (i, j) is included if creation i appears AFTER annihilation j in the word. This corresponds to pairs that need contraction (swapping a with a†).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">ops = Int32[1, -1]  # a a† (annihilation at 1, creation at 2)
board = build_ferrers_board(ops)
# Creation is AFTER annihilation → contraction possible → height 1
# board = [1]

ops = Int32[-1, 1]  # a† a (creation at 1, annihilation at 2)
board = build_ferrers_board(ops)
# Creation is BEFORE annihilation → no contraction → height 0
# board = [0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/bosonic.jl#L198-L220">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.compute_rook_numbers-Tuple{Vector{Int64}}"><a class="docstring-binding" href="#NCTSSoS.compute_rook_numbers-Tuple{Vector{Int64}}"><code>NCTSSoS.compute_rook_numbers</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_rook_numbers(board::Vector{Int}) -&gt; Vector{Int}</code></pre><p>Compute rook numbers for a Ferrers board using dynamic programming. Returns rook<em>numbers where rook</em>numbers[k+1] = rₖ(B) (1-indexed).</p><p>rₖ(B) = number of ways to place k non-attacking rooks on board B.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">board = [1, 1]  # Two columns, each with height 1 (one row)
rook = compute_rook_numbers(board)
# r₀ = 1 (one way to place 0 rooks)
# r₁ = 2 (two cells to place one rook)
# r₂ = 0 (can&#39;t place 2 rooks in 1 row, but we only track up to n_rows)
# rook = [1, 2]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/bosonic.jl#L246-L263">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.find_site_separation-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Signed"><a class="docstring-binding" href="#NCTSSoS.find_site_separation-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Signed"><code>NCTSSoS.find_site_separation</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">find_site_separation(word::Vector{T}) -&gt; Vector{Int}</code></pre><p>Find mode boundaries in a pre-sorted word.</p><p>Assumes <code>word</code> is already sorted by mode (via <code>_stable_sort_by_site!</code>). Returns separation indices <code>[0, end_mode1, end_mode2, ...]</code> where operators for mode i are at indices <code>sep[i]+1:sep[i+1]</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">word = Int32[1, -1, -2, 2]  # Already sorted: mode 1 ops, then mode 2 ops
sep = find_site_separation(word)
# sep = [0, 2, 4]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/bosonic.jl#L164-L179">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.simplify!-Union{Tuple{T}, Tuple{Type{BosonicAlgebra}, Vector{T}}} where T&lt;:Signed"><a class="docstring-binding" href="#NCTSSoS.simplify!-Union{Tuple{T}, Tuple{Type{BosonicAlgebra}, Vector{T}}} where T&lt;:Signed"><code>NCTSSoS.simplify!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simplify!(::Type{BosonicAlgebra}, word::Vector{T}) where {T&lt;:Signed} -&gt; Vector{Tuple{Int,Vector{T}}}</code></pre><p>Low-level in-place normal ordering of a bosonic word.</p><p>Returns a vector of <code>(coefficient, normal_ordered_word)</code> pairs representing the PBW expansion as a sum. Each word in the result is unique (coefficients are accumulated for identical words). Modifies <code>word</code> in-place (filters zeros, sorts by mode).</p><p>This is the internal workhorse; most users should call <code>simplify(BosonicAlgebra, word)</code>.</p><p><strong>Algorithm</strong></p><p>Uses rook numbers on Ferrers boards (arXiv:quant-ph/0507206):</p><ol><li>Sort by mode (preserving relative order within each mode)</li><li>Find mode boundaries</li><li>Compute single-mode normal forms using rook number formula</li><li>Expand Cartesian product across all modes</li><li>Combine like terms by final word and construct result pairs</li></ol><p><strong>Throws</strong></p><ul><li><code>ErrorException</code> if simplification produces an empty result (should not happen for valid input)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/bosonic.jl#L70-L91">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.simplify-Union{Tuple{T}, Tuple{Type{BosonicAlgebra}, Vector{T}}} where T&lt;:Signed"><a class="docstring-binding" href="#NCTSSoS.simplify-Union{Tuple{T}, Tuple{Type{BosonicAlgebra}, Vector{T}}} where T&lt;:Signed"><code>NCTSSoS.simplify</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simplify(::Type{BosonicAlgebra}, word::Vector{T}) where {T&lt;:Signed}</code></pre><p>Simplify a raw bosonic word into normal-ordered form.</p><p>This is the primary entry point for bosonic simplification. Takes a raw word vector and returns a vector of <code>(coefficient, word)</code> pairs representing the PBW expansion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/bosonic.jl#L149-L156">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.single_mode_normal_form-Union{Tuple{V}, Tuple{T}} where {T&lt;:Signed, V&lt;:AbstractVector{T}}"><a class="docstring-binding" href="#NCTSSoS.single_mode_normal_form-Union{Tuple{V}, Tuple{T}} where {T&lt;:Signed, V&lt;:AbstractVector{T}}"><code>NCTSSoS.single_mode_normal_form</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">single_mode_normal_form(ops::AbstractVector{T}) -&gt; Vector{Tuple{Int,Int,Int}}</code></pre><p>Compute the normal-ordered form of a single-mode operator sequence. Uses the rook number formula from Eq. 1.40 of arXiv:quant-ph/0507206.</p><p>Returns vector of (coefficient, num<em>creations, num</em>annihilations) tuples. Each tuple represents a term in the normal-ordered expansion.</p><p><strong>Formula</strong></p><p>For word ω with m creations and n annihilations:   ω = Σₖ rₖ(Bω) (a†)^{m-k} a^{n-k} where Bω is the Ferrers board and rₖ is the k-th rook number.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">ops = Int32[1, -1]  # a a†
result = single_mode_normal_form(ops)
# result = [(1, 1, 1), (1, 0, 0)]  # a† a + 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/bosonic.jl#L295-L315">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._validate_word-Union{Tuple{T}, Tuple{Type{ProjectorAlgebra}, Vector{T}}} where T&lt;:Unsigned"><a class="docstring-binding" href="#NCTSSoS._validate_word-Union{Tuple{T}, Tuple{Type{ProjectorAlgebra}, Vector{T}}} where T&lt;:Unsigned"><code>NCTSSoS._validate_word</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_validate_word(::Type{ProjectorAlgebra}, word::Vector{T}) where {T&lt;:Unsigned}</code></pre><p>Check that a projector word is in canonical form. Throws <code>ArgumentError</code> if invalid.</p><p>Canonical form requirements:</p><ul><li>Sites sorted in ascending order</li><li>No consecutive identical operators (no P² terms)</li></ul><p>This is used by <code>NormalMonomial{ProjectorAlgebra,T}</code> constructor to enforce invariants.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/projector.jl#L45-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.simplify!-Union{Tuple{T}, Tuple{Type{ProjectorAlgebra}, Vector{T}}} where T&lt;:Unsigned"><a class="docstring-binding" href="#NCTSSoS.simplify!-Union{Tuple{T}, Tuple{Type{ProjectorAlgebra}, Vector{T}}} where T&lt;:Unsigned"><code>NCTSSoS.simplify!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simplify!(::Type{ProjectorAlgebra}, word::Vector{T}) where {T&lt;:Unsigned} -&gt; Vector{T}</code></pre><p>In-place site-aware simplification for projector algebra word vectors.</p><p>Operators on different sites commute and are sorted by site (ascending). Within each site, idempotency applies: consecutive identical operators collapse (P² = P).</p><p>Returns the simplified word vector (mutated in place).</p><p><strong>Algorithm</strong></p><ol><li>Stable sort by site (using <code>decode_site</code>)</li><li>Remove consecutive duplicates (idempotency)</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/projector.jl#L67-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.simplify-Union{Tuple{T}, Tuple{Type{ProjectorAlgebra}, Vector{T}}} where T&lt;:Unsigned"><a class="docstring-binding" href="#NCTSSoS.simplify-Union{Tuple{T}, Tuple{Type{ProjectorAlgebra}, Vector{T}}} where T&lt;:Unsigned"><code>NCTSSoS.simplify</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simplify(::Type{ProjectorAlgebra}, w::Vector{T}) where {T&lt;:Unsigned} -&gt; Vector{T}</code></pre><p>Simplify a raw ProjectorAlgebra word into canonical form.</p><p>This is the primary entry point for ProjectorAlgebra simplification. Takes a raw word vector and returns a simplified copy (sorted by site, idempotency applied).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/projector.jl#L104-L111">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._validate_word-Union{Tuple{T}, Tuple{Type{UnipotentAlgebra}, Vector{T}}} where T&lt;:Unsigned"><a class="docstring-binding" href="#NCTSSoS._validate_word-Union{Tuple{T}, Tuple{Type{UnipotentAlgebra}, Vector{T}}} where T&lt;:Unsigned"><code>NCTSSoS._validate_word</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_validate_word(::Type{UnipotentAlgebra}, word::Vector{T}) where {T&lt;:Unsigned}</code></pre><p>Check that a unipotent word is in canonical form. Throws <code>ArgumentError</code> if invalid.</p><p>Canonical form requirements:</p><ul><li>Sites sorted in ascending order</li><li>No consecutive identical operators (no U² terms - they should cancel to I)</li></ul><p>This is used by <code>NormalMonomial{UnipotentAlgebra,T}</code> constructor to enforce invariants.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/unipotent.jl#L62-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.simplify!-Union{Tuple{T}, Tuple{Type{UnipotentAlgebra}, Vector{T}}} where T&lt;:Unsigned"><a class="docstring-binding" href="#NCTSSoS.simplify!-Union{Tuple{T}, Tuple{Type{UnipotentAlgebra}, Vector{T}}} where T&lt;:Unsigned"><code>NCTSSoS.simplify!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simplify!(::Type{UnipotentAlgebra}, word::Vector{T}) where {T&lt;:Unsigned} -&gt; Vector{T}</code></pre><p>In-place site-aware simplification for unipotent algebra word vectors.</p><p>Operators on different sites commute and are sorted by site (ascending). Within each site, U²=I applies: consecutive identical operators cancel (remove pairs).</p><p>Returns the simplified word vector (mutated in place).</p><p><strong>Algorithm</strong></p><ol><li>Stable sort by site (using <code>decode_site</code>)</li><li>Apply U²=I via stack (remove consecutive pairs)</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/unipotent.jl#L84-L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.simplify-Union{Tuple{T}, Tuple{Type{UnipotentAlgebra}, Vector{T}}} where T&lt;:Unsigned"><a class="docstring-binding" href="#NCTSSoS.simplify-Union{Tuple{T}, Tuple{Type{UnipotentAlgebra}, Vector{T}}} where T&lt;:Unsigned"><code>NCTSSoS.simplify</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simplify(::Type{UnipotentAlgebra}, word::Vector{T}) where {T&lt;:Unsigned} -&gt; Vector{T}</code></pre><p>Simplify a raw UnipotentAlgebra word into canonical form.</p><p>This is the primary entry point for UnipotentAlgebra simplification. Takes a raw word vector and returns a simplified copy (sorted by site, U²=I applied).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/unipotent.jl#L121-L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS._validate_word-Union{Tuple{T}, Tuple{Type{NonCommutativeAlgebra}, Vector{T}}} where T&lt;:Unsigned"><a class="docstring-binding" href="#NCTSSoS._validate_word-Union{Tuple{T}, Tuple{Type{NonCommutativeAlgebra}, Vector{T}}} where T&lt;:Unsigned"><code>NCTSSoS._validate_word</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_validate_word(::Type{NonCommutativeAlgebra}, word::Vector{T}) where {T&lt;:Unsigned}</code></pre><p>Check that a noncommutative word is in canonical form. Throws <code>ArgumentError</code> if invalid.</p><p>Canonical form requirements:</p><ul><li>Sites sorted in ascending order (operators on different sites commute)</li></ul><p>This is used by <code>NormalMonomial{NonCommutativeAlgebra,T}</code> constructor to enforce invariants.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/noncommutative.jl#L42-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.simplify!-Union{Tuple{T}, Tuple{Type{NonCommutativeAlgebra}, Vector{T}}} where T&lt;:Unsigned"><a class="docstring-binding" href="#NCTSSoS.simplify!-Union{Tuple{T}, Tuple{Type{NonCommutativeAlgebra}, Vector{T}}} where T&lt;:Unsigned"><code>NCTSSoS.simplify!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simplify!(::Type{NonCommutativeAlgebra}, word::Vector{T}) where {T&lt;:Unsigned} -&gt; Vector{T}</code></pre><p>In-place site-aware simplification for non-commutative algebra word vectors.</p><p>Operators on different sites commute and are sorted by site (ascending). Within each site, order is preserved exactly (no simplification rules apply).</p><p>Returns the sorted word vector (mutated in place).</p><p><strong>Algorithm</strong></p><ol><li>Filter out zero indices</li><li>Stable sort by site (using <code>decode_site</code>)</li><li>Within each site: preserve order exactly</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/noncommutative.jl#L64-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.simplify-Union{Tuple{T}, Tuple{Type{NonCommutativeAlgebra}, Vector{T}}} where T&lt;:Signed"><a class="docstring-binding" href="#NCTSSoS.simplify-Union{Tuple{T}, Tuple{Type{NonCommutativeAlgebra}, Vector{T}}} where T&lt;:Signed"><code>NCTSSoS.simplify</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simplify(::Type{NonCommutativeAlgebra}, word::Vector{T}) where {T&lt;:Signed}</code></pre><p>Throws <code>ArgumentError</code>. Signed indices are not supported for <code>NonCommutativeAlgebra</code>. Use <code>encode_index</code> with an unsigned integer type to construct site-encoded indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/noncommutative.jl#L99-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.simplify-Union{Tuple{T}, Tuple{Type{NonCommutativeAlgebra}, Vector{T}}} where T&lt;:Unsigned"><a class="docstring-binding" href="#NCTSSoS.simplify-Union{Tuple{T}, Tuple{Type{NonCommutativeAlgebra}, Vector{T}}} where T&lt;:Unsigned"><code>NCTSSoS.simplify</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">simplify(::Type{NonCommutativeAlgebra}, word::Vector{T}) where {T&lt;:Unsigned} -&gt; Vector{T}</code></pre><p>Simplify a raw NonCommutative word into canonical form.</p><p>This is the primary entry point for NonCommutative simplification. Takes a raw word vector and returns the simplified word vector (sorted by site).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/simplification/noncommutative.jl#L89-L96">source</a></section></details></article><h2 id="Utilities"><a class="docs-heading-anchor" href="#Utilities">Utilities</a><a id="Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="NCTSSoS.get_ncbasis-Union{Tuple{T}, Tuple{A}, Tuple{VariableRegistry{A, T}, Int64}} where {A&lt;:AlgebraType, T&lt;:Integer}"><a class="docstring-binding" href="#NCTSSoS.get_ncbasis-Union{Tuple{T}, Tuple{A}, Tuple{VariableRegistry{A, T}, Int64}} where {A&lt;:AlgebraType, T&lt;:Integer}"><code>NCTSSoS.get_ncbasis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_ncbasis(registry::VariableRegistry{A,T}, d::Int) where {A,T} -&gt; Vector{NormalMonomial{A,T}}</code></pre><p>Generate a basis of monomials up to degree <code>d</code> from the variables in <code>registry</code>.</p><p>This function enumerates all words of length 0 to <code>d</code> over the variable indices, applies algebra-specific simplification, and returns the unique simplified monomials in sorted order.</p><p><strong>Arguments</strong></p><ul><li><code>registry</code>: Variable registry containing the variable indices</li><li><code>d</code>: Maximum degree (inclusive)</li></ul><p><strong>Returns</strong></p><p>A sorted vector of unique <code>NormalMonomial{A,T}</code> elements up to degree <code>d</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; reg, (x,) = create_noncommutative_variables([(&quot;x&quot;, 1:2)]);

julia&gt; basis = get_ncbasis(reg, 2);

julia&gt; length(basis)  # 1 + 2 + 4 = 7 monomials
7

julia&gt; degree.(basis)
7-element Vector{Int64}:
 0
 1
 1
 2
 2
 2
 2</code></pre><p>For algebras with simplification (e.g., UnipotentAlgebra where x² = x):</p><pre><code class="language-julia-repl hljs">julia&gt; using NCTSSoS

julia&gt; reg, (u,) = create_unipotent_variables([(&quot;u&quot;, 1:2)]);

julia&gt; basis = get_ncbasis(reg, 2);

julia&gt; length(basis)  # Fewer due to x² = x simplification
5</code></pre><p>See also: <a href="#NCTSSoS.get_state_basis-Union{Tuple{ST}, Tuple{T}, Tuple{A}, Tuple{VariableRegistry{A, T}, Int64}} where {A&lt;:MonoidAlgebra, T&lt;:Integer, ST&lt;:NCTSSoS.StateType}"><code>get_state_basis</code></a>, <a href="#NCTSSoS.VariableRegistry"><code>VariableRegistry</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/02a26131a031dcc4a8c2178202dad53cd9e04502/src/algorithms/basis.jl#L32-L83">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interface/">« User interface</a><a class="docs-footer-nextpage" href="../sparsities/">Sparsities »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 2 February 2026 15:04">Monday 2 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
