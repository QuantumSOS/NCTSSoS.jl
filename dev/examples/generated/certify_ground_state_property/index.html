<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Certifying Ground State Property · NCTSSoS.jl</title><meta name="title" content="Certifying Ground State Property · NCTSSoS.jl"/><meta property="og:title" content="Certifying Ground State Property · NCTSSoS.jl"/><meta property="twitter:title" content="Certifying Ground State Property · NCTSSoS.jl"/><meta name="description" content="Documentation for NCTSSoS.jl."/><meta property="og:description" content="Documentation for NCTSSoS.jl."/><meta property="twitter:description" content="Documentation for NCTSSoS.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">NCTSSoS.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><a class="tocitem" href="../../../quick_start/">Quick Start</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../../manual/polynomials/">Polynomials</a></li><li><a class="tocitem" href="../../../manual/monomials/">Monomials</a></li><li><a class="tocitem" href="../../../manual/polynomial_optimization/">Polynomial Optimization</a></li><li><a class="tocitem" href="../../../manual/sparsities/">Sparsities</a></li><li><a class="tocitem" href="../../../manual/sdp_relaxation/">SDP Relaxation</a></li><li><a class="tocitem" href="../../../manual/optimizers/">Optimizers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../bell/">Bell inequalities</a></li><li><a class="tocitem" href="../trace_poly/">Trace Polynomial</a></li><li><a class="tocitem" href="../ground_state_energy/">Ground State Energy</a></li><li><a class="tocitem" href="../pauli_algebra_interface/">Pauli Algebra Interface</a></li><li class="is-active"><a class="tocitem" href>Certifying Ground State Property</a><ul class="internal"><li><a class="tocitem" href="#Computing-Lower-Bounds-with-Semidefinite-Programming"><span>Computing Lower Bounds with Semidefinite Programming</span></a></li><li><a class="tocitem" href="#Bounding-Ground-State-Correlation-Functions"><span>Bounding Ground-State Correlation Functions</span></a></li><li><a class="tocitem" href="#Computing-Rigorous-Bounds-on-Correlation-Functions"><span>Computing Rigorous Bounds on Correlation Functions</span></a></li><li><a class="tocitem" href="#Visualizing-Certified-Correlation-Function-Bounds"><span>Visualizing Certified Correlation Function Bounds</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../../reference/">References</a></li><li><span class="tocitem">APIs</span><ul><li><a class="tocitem" href="../../../apis/interface/">User interface</a></li><li><a class="tocitem" href="../../../apis/polynomials/">Polynomials</a></li><li><a class="tocitem" href="../../../apis/sparsities/">Sparsities</a></li><li><a class="tocitem" href="../../../apis/relaxations/">SDP Relaxation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Certifying Ground State Property</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Certifying Ground State Property</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumSOS/NCTSSoS.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/main/docs/src/examples/generated/certify_ground_state_property.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Certifying-Ground-State-Properties"><a class="docs-heading-anchor" href="#Certifying-Ground-State-Properties">Certifying Ground State Properties</a><a id="Certifying-Ground-State-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Certifying-Ground-State-Properties" title="Permalink"></a></h1><p>Understanding ground-state properties of quantum many-body systems represents a <strong>fundamental challenge in quantum physics</strong> (<a href="../../../reference/#wang2024Certifying">Wang <em>et al.</em>, 2024</a>). These properties reveal the low-energy phases and quantum correlations that characterize complex quantum systems. However, computing them exactly becomes intractable for large systems due to the exponential growth of the Hilbert space dimension with particle number.</p><p>While exact diagonalization provides precise results for small systems, it quickly becomes computationally prohibitive. Instead, we can obtain rigorous bounds on ground-state properties by combining:</p><ul><li><strong>Upper bounds</strong> from variational methods (or exact diagonalization for small systems)</li><li><strong>Lower bounds</strong> from semidefinite programming (SDP) relaxations</li></ul><p>This approach provides certified intervals that guarantee the true ground-state property lies within computable bounds.</p><p>As a demonstration, we consider the quantum Heisenberg model:</p><p class="math-container">\[\hat{H} = J \sum_{j=1}^{N}\sigma^z_j \sigma^z_{j+1} + h \sum_{j=1}^{N} \sigma^x_j\]</p><p>where we will certify both the ground-state energy and correlation functions.</p><pre><code class="language-julia hljs">using Yao
using LinearAlgebra

# System parameters for exact diagonalization
N = 3                    # Number of spins in the chain
J = 1.0                  # Coupling strength for Z-Z interactions

# Arrays to store results across different magnetic field strengths
ground_state_energy_upper_bounds = Float64[]  # Energy per site
s1s2values = Float64[]                        # S^z_1 * S^z_2 correlation

# Loop over different transverse field strengths
for h in 0.1:0.2:2.0
    # Construct the Heisenberg Hamiltonian with transverse field
    # H = J/4 * Σ Z_i Z_{i+1} + h/2 * Σ X_i
    ham = sum(J / 4 * kron(N, i =&gt; Z, mod1(i + 1, N) =&gt; Z) for i in 1:N) +
          sum(h / 2 * put(N, i =&gt; X) for i in 1:N)

    # Diagonalize the Hamiltonian to find eigenvalues and eigenvectors
    evals, eigves = eigen(Matrix(ham))

    # Calculate S^z_1 * S^z_2 correlation operator
    s1s2 = Matrix(kron(N, 1 =&gt; Z, 2 =&gt; Z)) / 4

    # Store ground state energy per site
    push!(ground_state_energy_upper_bounds, minimum(real(evals)) / N)

    # Calculate and store S^z_1 * S^z_2 expectation value in ground state
    ground_state_idx = argmin(real(evals))
    ground_state = eigves[:, ground_state_idx]
    push!(s1s2values, real(ground_state&#39; * s1s2 * ground_state))
end</code></pre><h2 id="Computing-Lower-Bounds-with-Semidefinite-Programming"><a class="docs-heading-anchor" href="#Computing-Lower-Bounds-with-Semidefinite-Programming">Computing Lower Bounds with Semidefinite Programming</a><a id="Computing-Lower-Bounds-with-Semidefinite-Programming-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-Lower-Bounds-with-Semidefinite-Programming" title="Permalink"></a></h2><p>Now we obtain rigorous lower bounds on the ground-state energy using <code>NCTSSoS.jl</code>. This approach formulates the quantum ground-state problem as a polynomial optimization problem and solves its semidefinite programming relaxation, providing certified lower bounds.</p><p>The NCTSSoS API provides type-safe Pauli algebra with automatic simplification. No explicit commutation constraints are needed - the <code>PauliAlgebra</code> type handles the Pauli operator relations automatically.</p><pre><code class="language-julia hljs">using NCTSSoS
using MosekTools
using JuMP

# Configure Mosek solver with high precision settings
SOLVER = optimizer_with_attributes(Mosek.Optimizer,
    &quot;MSK_DPAR_INTPNT_CO_TOL_PFEAS&quot; =&gt; 1e-8,  # Primal feasibility tolerance
    &quot;MSK_DPAR_INTPNT_CO_TOL_DFEAS&quot; =&gt; 1e-8,  # Dual feasibility tolerance
    &quot;MSK_DPAR_INTPNT_CO_TOL_REL_GAP&quot; =&gt; 1e-8,  # Relative gap tolerance
    &quot;MSK_IPAR_NUM_THREADS&quot; =&gt; 0)            # Use all available threads

# Initialize array to store energy lower bounds
ground_state_energy_lower_bounds = Float64[]

# System parameters (matching the exact diagonalization setup)
N = 3                    # Number of spins
T1 = ComplexF64          # Complex number type for calculations
J = 1.0                  # Coupling strength

# Loop over the same magnetic field values as before
for (i, h) in enumerate(0.1:0.2:2.0)
    # Create Pauli algebra variables
    # PauliAlgebra automatically handles:
    #   - σ² = I (unipotent property)
    #   - Cyclic product rules: σx·σy = iσz, σy·σz = iσx, σz·σx = iσy
    #   - Commutation relations between different sites
    registry, (x, y, z) = create_pauli_variables(1:N)  # x = σx, y = σy, z = σz

    # Objective function: we want to minimize the Hamiltonian
    # H = J/4 * Σ z_i z_{i+1} + h/2 * Σ x_i
    ham = sum(T1(J / 4) * z[i] * z[mod1(i + 1, N)] + T1(h / 2) * x[i] for i in 1:N)

    # Create polynomial optimization problem
    # No explicit algebra constraints needed - PauliAlgebra handles them automatically
    pop = polyopt(ham, registry)

    # Configure solver with second-order moment relaxation
    solver_config = SolverConfig(optimizer=SOLVER, order=2)

    # Solve the semidefinite program to get energy lower bound
    res = cs_nctssos(pop, solver_config)

    # Store energy per site (divide by system size)
    push!(ground_state_energy_lower_bounds, res.objective / N)
end</code></pre><h2 id="Bounding-Ground-State-Correlation-Functions"><a class="docs-heading-anchor" href="#Bounding-Ground-State-Correlation-Functions">Bounding Ground-State Correlation Functions</a><a id="Bounding-Ground-State-Correlation-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Bounding-Ground-State-Correlation-Functions" title="Permalink"></a></h2><p>Beyond energy bounds, we can rigorously bound other ground-state properties such as correlation functions. Here we demonstrate bounding the expectation value of the two-point correlation function <span>$S^z_{1}S^z_{2}$</span>.</p><p>To accomplish this, we need a custom solver that can handle additional constraints on correlation functions. The following function extends the standard NCTSSoS solver to incorporate entry constraints.</p><pre><code class="language-julia hljs">&quot;&quot;&quot;
    cs_nctssos_with_entry(pop, solver_config, entry_constraints; dualize=true)

Extended NCTSSoS solver that incorporates additional entry constraints
for bounding specific correlation functions in quantum systems.

This function builds the moment matrix relaxation with sparsity patterns
and adds semidefinite constraints to bound specific operator expectations.
&quot;&quot;&quot;
function cs_nctssos_with_entry(
    pop::OP,
    solver_config::SolverConfig,
    entry_constraints::Vector{P};
    dualize::Bool=true
) where {A&lt;:AlgebraType, T&lt;:Integer, C&lt;:Number, P&lt;:Polynomial{A,T,C}, OP&lt;:NCTSSoS.OptimizationProblem{P}}

   # Compute sparsity structure (correlative + term sparsity)
   sparsity = NCTSSoS.compute_sparsity(pop, solver_config)

   # Build the moment relaxation problem
   moment_problem = NCTSSoS.moment_relax(pop, sparsity.corr_sparsity, sparsity.cliques_term_sparsities)

   # Add entry constraints for correlation function bounds
   # These are semidefinite constraints that ensure physical validity
   for c in entry_constraints
       push!(moment_problem.constraints,(:HPSD, [c;;]))
   end

   # Dualize and solve (using the same solve_sdp helper as cs_nctssos)
   result = NCTSSoS.solve_sdp(moment_problem, solver_config.optimizer; dualize)

   # Return optimization results
   return NCTSSoS.PolyOptResult(result.objective, sparsity, result.model, result.n_unique_elements)
end</code></pre><h2 id="Computing-Rigorous-Bounds-on-Correlation-Functions"><a class="docs-heading-anchor" href="#Computing-Rigorous-Bounds-on-Correlation-Functions">Computing Rigorous Bounds on Correlation Functions</a><a id="Computing-Rigorous-Bounds-on-Correlation-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-Rigorous-Bounds-on-Correlation-Functions" title="Permalink"></a></h2><p>Now we demonstrate the main result: computing rigorous upper and lower bounds on the two-point correlation function <span>$\langle S^z_1 S^z_2 \rangle$</span>. This showcases how polynomial optimization can certify physical properties beyond just the ground-state energy.</p><p>We use reference energy bounds (computed via high-precision DMRG) to constrain the optimization problem, ensuring our correlation function bounds are physically meaningful.</p><pre><code class="language-julia hljs"># Initialize arrays to store correlation function bounds
lower_bounds = Float64[]
upper_bounds = Float64[]

# System parameters
J = 1.0  # Coupling strength (same as before)

# Loop over magnetic field values
for (i, h) in enumerate(0.1:0.2:2.0)
    # Create Pauli algebra variables
    registry, (x, y, z) = create_pauli_variables(1:N)

    # Objective function: S^z_1 * S^z_2 correlation
    obj = one(T1) * z[1] * z[2]

    # Hamiltonian (same form as before)
    ham = sum(T1(J / 4) * z[j] * z[mod1(j + 1, N)] + T1(h / 2) * x[j] for j in 1:N)

    # Energy constraint: ensure ground state energy is within reference bounds
    # This is crucial for obtaining physically meaningful correlation bounds
    ineq_cons = [ham - ground_state_energy_lower_bounds[i] * N]

    # Create optimization problems for lower and upper bounds
    # We solve two separate problems: minimize and maximize the correlation
    pop_l = polyopt(obj, registry; ineq_constraints=ineq_cons)
    pop_u = polyopt(-obj, registry; ineq_constraints=ineq_cons)

    # Configure solver
    solver_config = SolverConfig(optimizer=SOLVER, order=2)

    # Additional energy constraint for the upper bound problem
    single_ineq_cons = [ground_state_energy_upper_bounds[i] * N - ham]

    # Solve for lower and upper bounds on correlation function
    res_l = cs_nctssos_with_entry(pop_l, solver_config, single_ineq_cons; dualize=true)
    res_u = cs_nctssos_with_entry(pop_u, solver_config, single_ineq_cons; dualize=true)

    # Store bounds (divide by 4 to convert from Pauli to spin operators)
    push!(lower_bounds, res_l.objective / 4)
    push!(upper_bounds, -res_u.objective / 4)
end</code></pre><h2 id="Visualizing-Certified-Correlation-Function-Bounds"><a class="docs-heading-anchor" href="#Visualizing-Certified-Correlation-Function-Bounds">Visualizing Certified Correlation Function Bounds</a><a id="Visualizing-Certified-Correlation-Function-Bounds-1"></a><a class="docs-heading-anchor-permalink" href="#Visualizing-Certified-Correlation-Function-Bounds" title="Permalink"></a></h2><p>Finally, we visualize our results to demonstrate the tightness of the certified bounds. The polynomial optimization approach provides rigorous upper and lower bounds that closely bracket the exact correlation function values, validating the effectiveness of our certification method.</p><pre><code class="language-julia hljs">using CairoMakie

# Create the visualization
f = Figure(size=(800, 600))
ax = Axis(f[1, 1],
    xlabel=&quot;Transverse Field Strength (h)&quot;,
    ylabel=L&quot;\langle S^z_1 S^z_2 \rangle&quot;,
    title=&quot;Certified Bounds on Ground-State Correlation Function&quot;)

# Magnetic field values for plotting
xs = collect(0.1:0.2:2.0)

# Plot the certified bounds
scatterlines!(ax, xs, upper_bounds, color=:red, label=&quot;Upper Bound (SDP)&quot;, linewidth=2, markersize=8)
scatterlines!(ax, xs, lower_bounds, color=:green, label=&quot;Lower Bound (SDP)&quot;, linewidth=2, markersize=8)
scatterlines!(ax, xs, s1s2values, color=:blue, label=&quot;Exact Value (ED)&quot;, linewidth=2, markersize=8)

# Customize the plot
axislegend(ax, position=:rt)
ax.xgridvisible = true
ax.ygridvisible = true
ax.xgridwidth = 0.5
ax.ygridwidth = 0.5
ax.xgridcolor = (:gray, 0.2)
ax.ygridcolor = (:gray, 0.2)

f</code></pre><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>This example demonstrates how polynomial optimization provides rigorous <strong>certified bounds</strong> on quantum ground-state properties. Key insights:</p><ol><li><p><strong>Tight bounds</strong>: The semidefinite programming relaxations yield bounds that closely bracket the exact values, providing high-precision certification.</p></li><li><p><strong>General method</strong>: The approach works for any polynomial Hamiltonian and can bound arbitrary correlation functions, not just energies.</p></li><li><p><strong>Scalability</strong>: By exploiting sparsity patterns (correlative and term sparsity), we can handle larger quantum systems efficiently.</p></li><li><p><strong>Physical constraints</strong>: Energy bounds ensure physically meaningful correlation function bounds, preventing unphysical results.</p></li><li><p><strong>Type-safe algebra</strong>: The <code>PauliAlgebra</code> type automatically handles Pauli operator relations (σ² = I, commutation rules) without requiring explicit constraints.</p></li></ol><p>This certification methodology is particularly valuable for quantum many-body systems where exact solutions are unavailable, providing guaranteed error bars on computed properties.</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../pauli_algebra_interface/">« Pauli Algebra Interface</a><a class="docs-footer-nextpage" href="../../../reference/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 18 January 2026 03:25">Sunday 18 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
