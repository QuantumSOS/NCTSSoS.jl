<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User interface · NCTSSoS.jl</title><meta name="title" content="User interface · NCTSSoS.jl"/><meta property="og:title" content="User interface · NCTSSoS.jl"/><meta property="twitter:title" content="User interface · NCTSSoS.jl"/><meta name="description" content="Documentation for NCTSSoS.jl."/><meta property="og:description" content="Documentation for NCTSSoS.jl."/><meta property="twitter:description" content="Documentation for NCTSSoS.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">NCTSSoS.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../quick_start/">Quick Start</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/polynomials/">Polynomials</a></li><li><a class="tocitem" href="../../manual/monomials/">Monomials</a></li><li><a class="tocitem" href="../../manual/polynomial_optimization/">Polynomial Optimization</a></li><li><a class="tocitem" href="../../manual/sparsities/">Sparsities</a></li><li><a class="tocitem" href="../../manual/sdp_relaxation/">SDP Relaxation</a></li><li><a class="tocitem" href="../../manual/optimizers/">Optimizers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../../examples/generated/bell/">Bell inequalities</a></li><li><a class="tocitem" href="../../examples/generated/trace_poly/">Trace Polynomial</a></li><li><a class="tocitem" href="../../examples/generated/monoid_algebras_showcase/">Monoid Algebra Showcase</a></li><li><a class="tocitem" href="../../examples/generated/ground_state_energy/">Ground State Energy</a></li><li><a class="tocitem" href="../../examples/generated/pauli_algebra_interface/">Pauli Algebra Interface</a></li><li><a class="tocitem" href="../../examples/generated/certify_ground_state_property/">Certifying Ground State Property</a></li></ul></li><li><a class="tocitem" href="../../reference/">References</a></li><li><span class="tocitem">APIs</span><ul><li class="is-active"><a class="tocitem" href>User interface</a><ul class="internal"><li><a class="tocitem" href="#Problem-Definition"><span>Problem Definition</span></a></li><li><a class="tocitem" href="#Variable-Creation"><span>Variable Creation</span></a></li><li><a class="tocitem" href="#Solver-Interface"><span>Solver Interface</span></a></li></ul></li><li><a class="tocitem" href="../polynomials/">Polynomials</a></li><li><a class="tocitem" href="../sparsities/">Sparsities</a></li><li><a class="tocitem" href="../relaxations/">SDP Relaxation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">APIs</a></li><li class="is-active"><a href>User interface</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>User interface</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumSOS/NCTSSoS.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/main/docs/src/apis/interface.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="User-Interface"><a class="docs-heading-anchor" href="#User-Interface">User Interface</a><a id="User-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#User-Interface" title="Permalink"></a></h1><h2 id="Problem-Definition"><a class="docs-heading-anchor" href="#Problem-Definition">Problem Definition</a><a id="Problem-Definition-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Definition" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="NCTSSoS.PolyOpt"><a class="docstring-binding" href="#NCTSSoS.PolyOpt"><code>NCTSSoS.PolyOpt</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">PolyOpt{A&lt;:AlgebraType, T&lt;:Integer, P&lt;:AbstractPolynomial} &lt;: OptimizationProblem{A, P}</code></pre><p>A polynomial optimization problem structure with algebra type tracking. Handles both standard polynomials and state polynomials via the P parameter.</p><p><strong>Type Parameters</strong></p><ul><li><code>A&lt;:AlgebraType</code>: The algebra type governing simplification rules</li><li><code>T&lt;:Integer</code>: The integer type for monomial word indices</li><li><code>P&lt;:AbstractPolynomial</code>: Type of polynomial (Polynomial{A,T,C} or NCStatePolynomial{C,ST,A,T})</li></ul><p><strong>Fields</strong></p><ul><li><code>objective::P</code>: The polynomial objective function to be optimized</li><li><code>eq_constraints::Vector{P}</code>: Vector of equality constraints (p = 0)</li><li><code>ineq_constraints::Vector{P}</code>: Vector of inequality constraints (p &gt;= 0)</li><li><code>registry::VariableRegistry{A,T}</code>: Variable registry mapping symbols to indices</li></ul><p><strong>Notes</strong></p><ul><li>Algebra type determines simplification rules (no manual comm<em>gps, is</em>unipotent, is_projective)</li><li>Registry provides bidirectional symbol &lt;-&gt; index mapping for variable access</li><li>For NCStatePolynomial objectives, the state type (Arbitrary, MaxEntangled) is embedded in P</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Create Pauli algebra
reg, (σx, σy, σz) = create_pauli_variables(1:2)

# Build Hamiltonian
ham = 0.5 * (σx[1]*σx[2] + σy[1]*σy[2] + σz[1]*σz[2])

# Create optimization problem
pop = polyopt(ham, reg)

# State polynomial optimization (Bell inequalities)
reg, (x, y) = create_unipotent_variables([(&quot;x&quot;, 1:2), (&quot;y&quot;, 1:2)])
sp = -1.0 * ς(x[1]*y[1]) - 1.0 * ς(x[1]*y[2]) - 1.0 * ς(x[2]*y[1]) + 1.0 * ς(x[2]*y[2])
pop = polyopt(sp * one(NormalMonomial), reg)</code></pre><p>See also: <a href="#NCTSSoS.polyopt"><code>polyopt</code></a>, <a href="../polynomials/#NCTSSoS.VariableRegistry"><code>VariableRegistry</code></a>, <a href="../polynomials/#NCTSSoS.AlgebraType"><code>AlgebraType</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/ddcee8102892ec36fce42e5f42e47c12c1bad1ed/src/optimization/problem.jl#L20-L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.polyopt"><a class="docstring-binding" href="#NCTSSoS.polyopt"><code>NCTSSoS.polyopt</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">polyopt(objective::P, registry::VariableRegistry{A,T};
        eq_constraints=P[], ineq_constraints=P[]) where {P&lt;:AbstractPolynomial, A, T}</code></pre><p>Create a polynomial optimization problem from objective, registry, and optional constraints.</p><p>Works with any <code>AbstractPolynomial</code> subtype including <code>Polynomial{A,T,C}</code> and <code>NCStatePolynomial{C,ST,A,T}</code>.</p><p><strong>Arguments</strong></p><ul><li><code>objective::P</code>: The polynomial objective function to optimize</li><li><code>registry::VariableRegistry{A,T}</code>: Variable registry for the algebra</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>eq_constraints</code>: Equality constraints as polynomials (p = 0). Default: empty</li><li><code>ineq_constraints</code>: Inequality constraints as polynomials (p &gt;= 0). Default: empty</li></ul><p><strong>Returns</strong></p><p>A <code>PolyOpt{A,T,P}</code> structure representing the optimization problem.</p><p><strong>Notes</strong></p><ul><li>Algebra type <code>A</code> is inferred from the registry</li><li>Coefficient type cannot be an integer subtype (JuMP solver requirement)</li><li>Simplification rules are determined by the algebra type, not manual flags</li><li>For <code>FermionicAlgebra</code>: objectives should have even parity (parity superselection rule). Odd-parity operators have zero expectation value. Validation is done during moment relaxation via <code>_add_parity_constraints!</code>.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Pauli algebra optimization
reg, (σx, σy, σz) = create_pauli_variables(1:3)
ham = 0.5 * (σx[1]*σx[2] + σy[1]*σy[2])
pop = polyopt(ham, reg)

# With equality constraints
constraint = σx[1]*σx[1] - one(typeof(ham))  # σx² = I (auto-simplified anyway)
pop = polyopt(ham, reg; eq_constraints=[constraint])

# State polynomial optimization (Bell inequalities)
reg, (x, y) = create_unipotent_variables([(&quot;x&quot;, 1:2), (&quot;y&quot;, 1:2)])
sp = -1.0 * ς(x[1]*y[1]) - 1.0 * ς(x[1]*y[2]) - 1.0 * ς(x[2]*y[1]) + 1.0 * ς(x[2]*y[2])
pop = polyopt(sp * one(NormalMonomial), reg)</code></pre><p>See also: <a href="#NCTSSoS.PolyOpt"><code>PolyOpt</code></a>, <a href="../polynomials/#NCTSSoS.VariableRegistry"><code>VariableRegistry</code></a>, <a href="../polynomials/#NCTSSoS.NCStatePolynomial"><code>NCStatePolynomial</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/ddcee8102892ec36fce42e5f42e47c12c1bad1ed/src/optimization/problem.jl#L69-L115">source</a></section></details></article><h2 id="Variable-Creation"><a class="docs-heading-anchor" href="#Variable-Creation">Variable Creation</a><a id="Variable-Creation-1"></a><a class="docs-heading-anchor-permalink" href="#Variable-Creation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="NCTSSoS.create_pauli_variables"><a class="docstring-binding" href="#NCTSSoS.create_pauli_variables"><code>NCTSSoS.create_pauli_variables</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_pauli_variables(subscripts)</code></pre><p>Create a variable registry and monomials for Pauli spin matrices σx, σy, σz.</p><p>Pauli matrices satisfy:</p><ul><li>σᵢ² = 1 (each Pauli matrix squares to identity)</li><li>{σᵢ, σⱼ} = 2δᵢⱼ (anticommutation relation)</li></ul><p>The operators are always x, y, z components. This function creates variables for each subscript value.</p><p><strong>Variable Ordering:</strong> Variables are ordered by site first, then by Pauli type (x, y, z). This enables efficient encoding: for index <code>idx</code>, site = <code>(idx - 1) ÷ 3 + 1</code>, pauli_type = <code>(idx - 1) % 3</code> (0=X, 1=Y, 2=Z).</p><p><strong>Arguments</strong></p><ul><li><code>subscripts</code>: Subscript values for different qubits/sites</li></ul><p><strong>Returns</strong></p><p>A tuple of:</p><ul><li><code>VariableRegistry</code>: Registry with Pauli variables σx, σy, σz for each subscript</li><li><code>(σx, σy, σz)</code>: Tuple of monomial vectors grouped by Pauli type</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg, (σx, σy, σz) = create_pauli_variables(1:2);

julia&gt; length(σx)  # One σx per site
2

julia&gt; σx[1]  # monomial for σx₁
NormalMonomial{PauliAlgebra, UInt8}(...)

julia&gt; :σx₁ in reg
true

julia&gt; Int(reg[:σx₁])  # Index 1: site 1, type X
1</code></pre><p>Single qubit:</p><pre><code class="language-julia-repl hljs">julia&gt; reg, (σx, σy, σz) = create_pauli_variables([1]);

julia&gt; length(σx)
1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/ddcee8102892ec36fce42e5f42e47c12c1bad1ed/src/types/registry.jl#L223-L271">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.create_fermionic_variables"><a class="docstring-binding" href="#NCTSSoS.create_fermionic_variables"><code>NCTSSoS.create_fermionic_variables</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_fermionic_variables(subscripts)</code></pre><p>Create a variable registry and monomials for fermionic creation (a⁺) and annihilation (a) operators.</p><p>Fermionic operators satisfy anticommutation relations:</p><ul><li>{aᵢ, aⱼ⁺} = δᵢⱼ (creation-annihilation)</li><li>{aᵢ, aⱼ} = 0 (annihilation-annihilation)</li><li>{aᵢ⁺, aⱼ⁺} = 0 (creation-creation)</li></ul><p><strong>Arguments</strong></p><ul><li><code>subscripts</code>: Subscript values for different modes/sites</li></ul><p><strong>Returns</strong></p><p>A tuple of:</p><ul><li><code>VariableRegistry</code>: Registry with both a and a⁺ operators for each subscript</li><li><code>(a, a⁺)</code>: Tuple of monomial vectors (annihilation, creation)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg, (a, a⁺) = create_fermionic_variables(1:2);

julia&gt; length(a)  # One annihilation per mode
2

julia&gt; a[1]  # monomial for a₁
NormalMonomial{FermionicAlgebra, Int8}(...)

julia&gt; :a₁ in reg  # annihilation operator
true

julia&gt; :a⁺₁ in reg  # creation operator
true</code></pre><p>Multiple modes:</p><pre><code class="language-julia-repl hljs">julia&gt; reg, (a, a⁺) = create_fermionic_variables(1:3);

julia&gt; length(a)
3

julia&gt; length(a⁺)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/ddcee8102892ec36fce42e5f42e47c12c1bad1ed/src/types/registry.jl#L329-L374">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.create_bosonic_variables"><a class="docstring-binding" href="#NCTSSoS.create_bosonic_variables"><code>NCTSSoS.create_bosonic_variables</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_bosonic_variables(subscripts)</code></pre><p>Create a variable registry and monomials for bosonic creation (c⁺) and annihilation (c) operators.</p><p>Bosonic operators satisfy commutation relations:</p><ul><li>[cᵢ, cⱼ⁺] = δᵢⱼ (creation-annihilation)</li><li>[cᵢ, cⱼ] = 0 (annihilation-annihilation)</li><li>[cᵢ⁺, cⱼ⁺] = 0 (creation-creation)</li></ul><p><strong>Arguments</strong></p><ul><li><code>subscripts</code>: Subscript values for different modes/sites</li></ul><p><strong>Returns</strong></p><p>A tuple of:</p><ul><li><code>VariableRegistry</code>: Registry with both c and c⁺ operators for each subscript</li><li><code>(c, c⁺)</code>: Tuple of monomial vectors (annihilation, creation)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg, (c, c⁺) = create_bosonic_variables(1:2);

julia&gt; length(c)  # One annihilation per mode
2

julia&gt; c[1]  # monomial for c₁
NormalMonomial{BosonicAlgebra, Int8}(...)

julia&gt; :c₁ in reg  # annihilation operator
true

julia&gt; :c⁺₁ in reg  # creation operator
true</code></pre><p>Multiple modes:</p><pre><code class="language-julia-repl hljs">julia&gt; reg, (c, c⁺) = create_bosonic_variables(1:3);

julia&gt; length(c)
3

julia&gt; length(c⁺)
3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/ddcee8102892ec36fce42e5f42e47c12c1bad1ed/src/types/registry.jl#L427-L472">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.create_projector_variables"><a class="docstring-binding" href="#NCTSSoS.create_projector_variables"><code>NCTSSoS.create_projector_variables</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_projector_variables(prefix_subscripts::Vector{Tuple{String, VT}})</code></pre><p>Create a variable registry and monomials for projector operators.</p><p>Projector operators satisfy:</p><ul><li>Pi^2 = Pi (idempotency: projectors square to themselves)</li></ul><p>Projectors are self-adjoint and commutativity is NOT enforced.</p><p><strong>Arguments</strong></p><ul><li><code>prefix_subscripts</code>: Vector of <code>(prefix, subscripts)</code> tuples for multi-prefix creation</li></ul><p><strong>Returns</strong></p><p>A tuple of:</p><ul><li><code>VariableRegistry</code>: Registry with projector variables for each subscript</li><li><code>monomial_groups</code>: Tuple of monomial vectors, one per prefix group</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg, (P,) = create_projector_variables([(&quot;P&quot;, 1:3)]);

julia&gt; length(P)
3

julia&gt; P[1]  # monomial for P₁
NormalMonomial{ProjectorAlgebra, UInt8}(...)

julia&gt; reg, (P, Q) = create_projector_variables([(&quot;P&quot;, 1:2), (&quot;Q&quot;, 3:4)]);

julia&gt; length(P), length(Q)
(2, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/ddcee8102892ec36fce42e5f42e47c12c1bad1ed/src/types/registry.jl#L475-L508">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.create_unipotent_variables"><a class="docstring-binding" href="#NCTSSoS.create_unipotent_variables"><code>NCTSSoS.create_unipotent_variables</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_unipotent_variables(prefix_subscripts::Vector{Tuple{String, VT}})</code></pre><p>Create a variable registry and monomials for unipotent operators.</p><p>Unipotent operators satisfy:</p><ul><li>U^2 = I (squares to identity)</li></ul><p>This is simpler than Pauli algebra - no cyclic products or cross-operator interactions.</p><p><strong>Arguments</strong></p><ul><li><code>prefix_subscripts</code>: Vector of <code>(prefix, subscripts)</code> tuples for multi-prefix creation</li></ul><p><strong>Returns</strong></p><p>A tuple of:</p><ul><li><code>VariableRegistry</code>: Registry with unipotent variables for each subscript</li><li><code>monomial_groups</code>: Tuple of monomial vectors, one per prefix group</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg, (U,) = create_unipotent_variables([(&quot;U&quot;, 1:3)]);

julia&gt; length(U)
3

julia&gt; U[1]  # monomial for U₁
NormalMonomial{UnipotentAlgebra, UInt8}(...)

julia&gt; reg, (U, V) = create_unipotent_variables([(&quot;U&quot;, 1:2), (&quot;V&quot;, 3:4)]);

julia&gt; length(U), length(V)
(2, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/ddcee8102892ec36fce42e5f42e47c12c1bad1ed/src/types/registry.jl#L517-L551">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.create_noncommutative_variables"><a class="docstring-binding" href="#NCTSSoS.create_noncommutative_variables"><code>NCTSSoS.create_noncommutative_variables</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">create_noncommutative_variables(prefix_subscripts::Vector{Tuple{String, VT}})</code></pre><p>Create a variable registry and monomials for generic non-commutative variables.</p><p>Non-commutative variables have no simplification rules - word order is preserved exactly as given.</p><p><strong>Arguments</strong></p><ul><li><code>prefix_subscripts</code>: Vector of <code>(prefix, subscripts)</code> tuples for multi-prefix creation</li></ul><p><strong>Returns</strong></p><p>A tuple of:</p><ul><li><code>VariableRegistry</code>: Registry with non-commutative variables for each subscript</li><li><code>monomial_groups</code>: Tuple of monomial vectors, one per prefix group</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg, (x,) = create_noncommutative_variables([(&quot;x&quot;, 1:3)]);

julia&gt; length(x)
3

julia&gt; x[1]  # monomial for x₁
NormalMonomial{NonCommutativeAlgebra, UInt8}(...)

julia&gt; reg, (x, y) = create_noncommutative_variables([(&quot;x&quot;, 1:2), (&quot;y&quot;, 3:4)]);

julia&gt; length(x), length(y)
(2, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/ddcee8102892ec36fce42e5f42e47c12c1bad1ed/src/types/registry.jl#L558-L589">source</a></section></details></article><h2 id="Solver-Interface"><a class="docs-heading-anchor" href="#Solver-Interface">Solver Interface</a><a id="Solver-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-Interface" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="NCTSSoS.SolverConfig"><a class="docstring-binding" href="#NCTSSoS.SolverConfig"><code>NCTSSoS.SolverConfig</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SolverConfig(; optimizer, order, cs_algo=NoElimination(), ts_algo=NoElimination())</code></pre><p>Configuration for solving polynomial optimization problems.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>optimizer</code> (required): The optimizer to use for solving the SDP problem (e.g. Clarabel.Optimizer)</li><li><code>order::Int</code>: The order of the moment relaxation (default: 0)</li><li><code>cs_algo::EliminationAlgorithm</code>: Algorithm for correlative sparsity exploitation (default: NoElimination())</li><li><code>ts_algo::EliminationAlgorithm</code>: Algorithm for term sparsity exploitation (default: NoElimination())</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; solver_config = SolverConfig(optimizer=Clarabel.Optimizer, order=2) # default elimination algorithms
SolverConfig(Clarabel.MOIwrapper.Optimizer, 2, NoElimination(), NoElimination())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/ddcee8102892ec36fce42e5f42e47c12c1bad1ed/src/optimization/interface.jl#L250-L268">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.cs_nctssos"><a class="docstring-binding" href="#NCTSSoS.cs_nctssos"><code>NCTSSoS.cs_nctssos</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cs_nctssos(pop::PolyOpt{P}, solver_config::SolverConfig; dualize::Bool=true) where {P}</code></pre><p>Solve a polynomial optimization problem using the CS-NCTSSOS method with correlative sparsity and term sparsity exploitation.</p><p><strong>Arguments</strong></p><ul><li><code>pop::PolyOpt{P}</code>: The polynomial optimization problem to solve</li><li><code>solver_config::SolverConfig</code>: Configuration containing optimizer, moment order, and sparsity algorithms</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dualize::Bool=true</code>: Whether to dualize the moment relaxation to a sum-of-squares problem</li></ul><p><strong>Returns</strong></p><ul><li><code>PolyOptResult</code>: Result containing the objective value, correlative sparsity structure, and term sparsity information</li></ul><p><strong>Description</strong></p><p>This function solves a polynomial optimization problem by:</p><ol><li>Computing correlative sparsity to decompose the problem into smaller cliques</li><li>Computing term sparsity for each clique to further reduce problem size</li><li>Formulating and solving either the moment relaxation or its SOS dual</li><li>Returning the optimal objective value and sparsity information</li></ol><p>The moment order is automatically determined from the polynomial degrees if not specified in <code>solver_config</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/ddcee8102892ec36fce42e5f42e47c12c1bad1ed/src/optimization/interface.jl#L328-L351">source</a></section><section><div><pre><code class="language-julia hljs">cs_nctssos(pop::PolyOpt{A,T,P}, solver_config::SolverConfig; dualize::Bool=true)</code></pre><p>Solve a state polynomial optimization problem using the CS-NCTSSOS method.</p><p><strong>Arguments</strong></p><ul><li><code>pop::PolyOpt{A,T,P}</code>: The polynomial optimization problem with NCStatePolynomial objective</li><li><code>solver_config::SolverConfig</code>: Configuration containing optimizer, moment order, and sparsity algorithms</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dualize::Bool=true</code>: Whether to dualize the moment relaxation to a sum-of-squares problem</li></ul><p><strong>Returns</strong></p><ul><li><code>PolyOptResult</code>: Result containing the objective value and sparsity information</li></ul><p><strong>Description</strong></p><p>This function solves a state polynomial optimization problem by:</p><ol><li>Computing correlative sparsity to decompose the problem into smaller cliques</li><li>Computing term sparsity for each clique to further reduce problem size</li><li>Formulating and solving the SOS dual of the moment relaxation</li><li>Returning the optimal objective value and sparsity information</li></ol><p><strong>Note on order selection</strong></p><p>The relaxation order should be at least <code>ceil(max_objective_degree / 2)</code> to properly capture the objective. For state polynomials with degree-2 terms like ⟨x₁y₁⟩, use <code>order &gt;= 1</code>. If <code>order=0</code> is specified, it will be automatically computed from the maximum polynomial degree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/ddcee8102892ec36fce42e5f42e47c12c1bad1ed/src/optimization/interface.jl#L413-L440">source</a></section></details></article><article><details class="docstring" open="true"><summary id="NCTSSoS.cs_nctssos_higher"><a class="docstring-binding" href="#NCTSSoS.cs_nctssos_higher"><code>NCTSSoS.cs_nctssos_higher</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cs_nctssos_higher(pop::PolyOpt{T}, prev_res::PolyOptResult, solver_config::SolverConfig; dualize::Bool=true) where {T}</code></pre><p>Solve a polynomial optimization problem using higher-order term sparsity based on a previous result.</p><p><strong>Arguments</strong></p><ul><li><code>pop::PolyOpt{T}</code>: The polynomial optimization problem to solve</li><li><code>prev_res::PolyOptResult</code>: Previous optimization result containing sparsity information to build upon</li><li><code>solver_config::SolverConfig</code>: Configuration containing optimizer and sparsity algorithms</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dualize::Bool=true</code>: Whether to dualize the moment relaxation to a sum-of-squares problem</li></ul><p><strong>Returns</strong></p><ul><li><code>PolyOptResult</code>: Result containing the objective value, correlative sparsity structure, and updated term sparsity information</li></ul><p><strong>Description</strong></p><p>This function performs a higher-order iteration of the CS-NCTSSOS method by:</p><ol><li>Using the correlative sparsity structure from the previous result</li><li>Computing new term sparsity based on the union of previously activated supports</li><li>Formulating and solving either the moment relaxation or its SOS dual with the refined sparsity</li><li>Returning the optimal objective value and updated sparsity information</li></ol><p>This is typically used when the previous relaxation was not tight enough and a higher-order relaxation is needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/ddcee8102892ec36fce42e5f42e47c12c1bad1ed/src/optimization/interface.jl#L359-L383">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../reference/">« References</a><a class="docs-footer-nextpage" href="../polynomials/">Polynomials »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Tuesday 24 February 2026 04:24">Tuesday 24 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
