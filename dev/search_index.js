var documenterSearchIndex = {"docs":
[{"location":"manual/sparsities/#sparsities","page":"Sparsities","title":"Sparsities","text":"The main goal is to reduce the number of monomials used in indexing the moment matrix. This is a crucial step in making the semidefinite programs more efficient, as the size of the moment matrix directly affects the computational cost of solving the problem. By exploiting the structure of the problem, we can often significantly reduce the number of monomials needed, leading to substantial performance improvements.\n\n(Image: Overview of how sparsity is exploited)","category":"section"},{"location":"manual/sparsities/#correlative-sparsity","page":"Sparsities","title":"Correlative Sparsity","text":"Correlative sparsity, also known as chordal sparsity, arises from the underlying structure of the problem's variables. In many physical systems, not all variables are directly coupled. This lack of coupling can be represented by a graph, where the vertices are the variables and the edges represent direct interactions. The correlative sparsity pattern is then determined by the maximal cliques of this graph. A clique is a subset of vertices where every two distinct vertices are adjacent. By only considering monomials within these maximal cliques, we can significantly reduce the size of the moment matrix. This is because the moment matrix will be block-diagonal, with each block corresponding to a maximal clique.\n\n(Image: Hand waving effect of Correlative Sparsity)","category":"section"},{"location":"manual/sparsities/#term-sparsity","page":"Sparsities","title":"Term Sparsity","text":"Term sparsity, also known as ideal sparsity, is a more direct way of exploiting the structure of the polynomials involved in the problem. If a certain monomial does not appear in any of the polynomial constraints, then it can be safely removed from the basis of the moment matrix. This is because the corresponding entry in the moment matrix will not be constrained by the problem, and thus can be set to zero without affecting the solution. This type of sparsity is particularly effective when the polynomials are sparse, i.e., they have only a few non-zero terms.\n\n(Image: Hand waving effect of Term Sparsity)","category":"section"},{"location":"apis/interface/#User-Interface","page":"User interface","title":"User Interface","text":"","category":"section"},{"location":"apis/interface/#Problem-Definition","page":"User interface","title":"Problem Definition","text":"","category":"section"},{"location":"apis/interface/#Variable-Creation","page":"User interface","title":"Variable Creation","text":"","category":"section"},{"location":"apis/interface/#Solver-Interface","page":"User interface","title":"Solver Interface","text":"","category":"section"},{"location":"apis/interface/#NCTSSoS.PolyOpt","page":"User interface","title":"NCTSSoS.PolyOpt","text":"PolyOpt{A<:AlgebraType, T<:Integer, P<:AbstractPolynomial} <: OptimizationProblem{A, P}\n\nA polynomial optimization problem structure with algebra type tracking. Handles both standard polynomials and state polynomials via the P parameter.\n\nType Parameters\n\nA<:AlgebraType: The algebra type governing simplification rules\nT<:Integer: The integer type for monomial word indices\nP<:AbstractPolynomial: Type of polynomial (Polynomial{A,T,C} or NCStatePolynomial{C,ST,A,T})\n\nFields\n\nobjective::P: The polynomial objective function to be optimized\neq_constraints::Vector{P}: Vector of equality constraints (p = 0)\nineq_constraints::Vector{P}: Vector of inequality constraints (p >= 0)\nregistry::VariableRegistry{A,T}: Variable registry mapping symbols to indices\n\nNotes\n\nAlgebra type determines simplification rules (no manual commgps, isunipotent, is_projective)\nRegistry provides bidirectional symbol <-> index mapping for variable access\nFor NCStatePolynomial objectives, the state type (Arbitrary, MaxEntangled) is embedded in P\n\nExamples\n\n# Create Pauli algebra\nreg, (œÉx, œÉy, œÉz) = create_pauli_variables(1:2)\n\n# Build Hamiltonian\nham = 0.5 * (œÉx[1]*œÉx[2] + œÉy[1]*œÉy[2] + œÉz[1]*œÉz[2])\n\n# Create optimization problem\npop = polyopt(ham, reg)\n\n# State polynomial optimization (Bell inequalities)\nreg, (x, y) = create_unipotent_variables([(\"x\", 1:2), (\"y\", 1:2)])\nsp = -1.0 * œÇ(x[1]*y[1]) - 1.0 * œÇ(x[1]*y[2]) - 1.0 * œÇ(x[2]*y[1]) + 1.0 * œÇ(x[2]*y[2])\npop = polyopt(sp * one(NormalMonomial), reg)\n\nSee also: polyopt, VariableRegistry, AlgebraType\n\n\n\n\n\n","category":"type"},{"location":"apis/interface/#NCTSSoS.polyopt","page":"User interface","title":"NCTSSoS.polyopt","text":"polyopt(objective::P, registry::VariableRegistry{A,T};\n        eq_constraints=P[], ineq_constraints=P[]) where {P<:AbstractPolynomial, A, T}\n\nCreate a polynomial optimization problem from objective, registry, and optional constraints.\n\nWorks with any AbstractPolynomial subtype including Polynomial{A,T,C} and NCStatePolynomial{C,ST,A,T}.\n\nArguments\n\nobjective::P: The polynomial objective function to optimize\nregistry::VariableRegistry{A,T}: Variable registry for the algebra\n\nKeyword Arguments\n\neq_constraints: Equality constraints as polynomials (p = 0). Default: empty\nineq_constraints: Inequality constraints as polynomials (p >= 0). Default: empty\n\nReturns\n\nA PolyOpt{A,T,P} structure representing the optimization problem.\n\nNotes\n\nAlgebra type A is inferred from the registry\nCoefficient type cannot be an integer subtype (JuMP solver requirement)\nSimplification rules are determined by the algebra type, not manual flags\nFor FermionicAlgebra: objectives should have even parity (parity superselection rule). Odd-parity operators have zero expectation value. Validation is done during moment relaxation via _add_parity_constraints!.\n\nExamples\n\n# Pauli algebra optimization\nreg, (œÉx, œÉy, œÉz) = create_pauli_variables(1:3)\nham = 0.5 * (œÉx[1]*œÉx[2] + œÉy[1]*œÉy[2])\npop = polyopt(ham, reg)\n\n# With equality constraints\nconstraint = œÉx[1]*œÉx[1] - one(typeof(ham))  # œÉx¬≤ = I (auto-simplified anyway)\npop = polyopt(ham, reg; eq_constraints=[constraint])\n\n# State polynomial optimization (Bell inequalities)\nreg, (x, y) = create_unipotent_variables([(\"x\", 1:2), (\"y\", 1:2)])\nsp = -1.0 * œÇ(x[1]*y[1]) - 1.0 * œÇ(x[1]*y[2]) - 1.0 * œÇ(x[2]*y[1]) + 1.0 * œÇ(x[2]*y[2])\npop = polyopt(sp * one(NormalMonomial), reg)\n\nSee also: PolyOpt, VariableRegistry, NCStatePolynomial\n\n\n\n\n\n","category":"function"},{"location":"apis/interface/#NCTSSoS.create_pauli_variables","page":"User interface","title":"NCTSSoS.create_pauli_variables","text":"create_pauli_variables(subscripts)\n\nCreate a variable registry and monomials for Pauli spin matrices œÉx, œÉy, œÉz.\n\nPauli matrices satisfy:\n\nœÉ·µ¢¬≤ = 1 (each Pauli matrix squares to identity)\n{œÉ·µ¢, œÉ‚±º} = 2Œ¥·µ¢‚±º (anticommutation relation)\n\nThe operators are always x, y, z components. This function creates variables for each subscript value.\n\nVariable Ordering: Variables are ordered by site first, then by Pauli type (x, y, z). This enables efficient encoding: for index idx, site = (idx - 1) √∑ 3 + 1, pauli_type = (idx - 1) % 3 (0=X, 1=Y, 2=Z).\n\nArguments\n\nsubscripts: Subscript values for different qubits/sites\n\nReturns\n\nA tuple of:\n\nVariableRegistry: Registry with Pauli variables œÉx, œÉy, œÉz for each subscript\n(œÉx, œÉy, œÉz): Tuple of monomial vectors grouped by Pauli type\n\nExamples\n\njulia> reg, (œÉx, œÉy, œÉz) = create_pauli_variables(1:2);\n\njulia> length(œÉx)  # One œÉx per site\n2\n\njulia> œÉx[1]  # monomial for œÉx‚ÇÅ\nNormalMonomial{PauliAlgebra, UInt8}(...)\n\njulia> :œÉx‚ÇÅ in reg\ntrue\n\njulia> Int(reg[:œÉx‚ÇÅ])  # Index 1: site 1, type X\n1\n\nSingle qubit:\n\njulia> reg, (œÉx, œÉy, œÉz) = create_pauli_variables([1]);\n\njulia> length(œÉx)\n1\n\n\n\n\n\n","category":"function"},{"location":"apis/interface/#NCTSSoS.create_fermionic_variables","page":"User interface","title":"NCTSSoS.create_fermionic_variables","text":"create_fermionic_variables(subscripts)\n\nCreate a variable registry and monomials for fermionic creation (a‚Å∫) and annihilation (a) operators.\n\nFermionic operators satisfy anticommutation relations:\n\n{a·µ¢, a‚±º‚Å∫} = Œ¥·µ¢‚±º (creation-annihilation)\n{a·µ¢, a‚±º} = 0 (annihilation-annihilation)\n{a·µ¢‚Å∫, a‚±º‚Å∫} = 0 (creation-creation)\n\nArguments\n\nsubscripts: Subscript values for different modes/sites\n\nReturns\n\nA tuple of:\n\nVariableRegistry: Registry with both a and a‚Å∫ operators for each subscript\n(a, a‚Å∫): Tuple of monomial vectors (annihilation, creation)\n\nExamples\n\njulia> reg, (a, a‚Å∫) = create_fermionic_variables(1:2);\n\njulia> length(a)  # One annihilation per mode\n2\n\njulia> a[1]  # monomial for a‚ÇÅ\nNormalMonomial{FermionicAlgebra, Int8}(...)\n\njulia> :a‚ÇÅ in reg  # annihilation operator\ntrue\n\njulia> :a‚Å∫‚ÇÅ in reg  # creation operator\ntrue\n\nMultiple modes:\n\njulia> reg, (a, a‚Å∫) = create_fermionic_variables(1:3);\n\njulia> length(a)\n3\n\njulia> length(a‚Å∫)\n3\n\n\n\n\n\n","category":"function"},{"location":"apis/interface/#NCTSSoS.create_bosonic_variables","page":"User interface","title":"NCTSSoS.create_bosonic_variables","text":"create_bosonic_variables(subscripts)\n\nCreate a variable registry and monomials for bosonic creation (c‚Å∫) and annihilation (c) operators.\n\nBosonic operators satisfy commutation relations:\n\n[c·µ¢, c‚±º‚Å∫] = Œ¥·µ¢‚±º (creation-annihilation)\n[c·µ¢, c‚±º] = 0 (annihilation-annihilation)\n[c·µ¢‚Å∫, c‚±º‚Å∫] = 0 (creation-creation)\n\nArguments\n\nsubscripts: Subscript values for different modes/sites\n\nReturns\n\nA tuple of:\n\nVariableRegistry: Registry with both c and c‚Å∫ operators for each subscript\n(c, c‚Å∫): Tuple of monomial vectors (annihilation, creation)\n\nExamples\n\njulia> reg, (c, c‚Å∫) = create_bosonic_variables(1:2);\n\njulia> length(c)  # One annihilation per mode\n2\n\njulia> c[1]  # monomial for c‚ÇÅ\nNormalMonomial{BosonicAlgebra, Int8}(...)\n\njulia> :c‚ÇÅ in reg  # annihilation operator\ntrue\n\njulia> :c‚Å∫‚ÇÅ in reg  # creation operator\ntrue\n\nMultiple modes:\n\njulia> reg, (c, c‚Å∫) = create_bosonic_variables(1:3);\n\njulia> length(c)\n3\n\njulia> length(c‚Å∫)\n3\n\n\n\n\n\n","category":"function"},{"location":"apis/interface/#NCTSSoS.create_projector_variables","page":"User interface","title":"NCTSSoS.create_projector_variables","text":"create_projector_variables(prefix_subscripts::Vector{Tuple{String, VT}})\n\nCreate a variable registry and monomials for projector operators.\n\nProjector operators satisfy:\n\nPi^2 = Pi (idempotency: projectors square to themselves)\n\nProjectors are self-adjoint and commutativity is NOT enforced.\n\nArguments\n\nprefix_subscripts: Vector of (prefix, subscripts) tuples for multi-prefix creation\n\nReturns\n\nA tuple of:\n\nVariableRegistry: Registry with projector variables for each subscript\nmonomial_groups: Tuple of monomial vectors, one per prefix group\n\nExamples\n\njulia> reg, (P,) = create_projector_variables([(\"P\", 1:3)]);\n\njulia> length(P)\n3\n\njulia> P[1]  # monomial for P‚ÇÅ\nNormalMonomial{ProjectorAlgebra, UInt8}(...)\n\njulia> reg, (P, Q) = create_projector_variables([(\"P\", 1:2), (\"Q\", 3:4)]);\n\njulia> length(P), length(Q)\n(2, 2)\n\n\n\n\n\n","category":"function"},{"location":"apis/interface/#NCTSSoS.create_unipotent_variables","page":"User interface","title":"NCTSSoS.create_unipotent_variables","text":"create_unipotent_variables(prefix_subscripts::Vector{Tuple{String, VT}})\n\nCreate a variable registry and monomials for unipotent operators.\n\nUnipotent operators satisfy:\n\nU^2 = I (squares to identity)\n\nThis is simpler than Pauli algebra - no cyclic products or cross-operator interactions.\n\nArguments\n\nprefix_subscripts: Vector of (prefix, subscripts) tuples for multi-prefix creation\n\nReturns\n\nA tuple of:\n\nVariableRegistry: Registry with unipotent variables for each subscript\nmonomial_groups: Tuple of monomial vectors, one per prefix group\n\nExamples\n\njulia> reg, (U,) = create_unipotent_variables([(\"U\", 1:3)]);\n\njulia> length(U)\n3\n\njulia> U[1]  # monomial for U‚ÇÅ\nNormalMonomial{UnipotentAlgebra, UInt8}(...)\n\njulia> reg, (U, V) = create_unipotent_variables([(\"U\", 1:2), (\"V\", 3:4)]);\n\njulia> length(U), length(V)\n(2, 2)\n\n\n\n\n\n","category":"function"},{"location":"apis/interface/#NCTSSoS.create_noncommutative_variables","page":"User interface","title":"NCTSSoS.create_noncommutative_variables","text":"create_noncommutative_variables(prefix_subscripts::Vector{Tuple{String, VT}})\n\nCreate a variable registry and monomials for generic non-commutative variables.\n\nNon-commutative variables have no simplification rules - word order is preserved exactly as given.\n\nArguments\n\nprefix_subscripts: Vector of (prefix, subscripts) tuples for multi-prefix creation\n\nReturns\n\nA tuple of:\n\nVariableRegistry: Registry with non-commutative variables for each subscript\nmonomial_groups: Tuple of monomial vectors, one per prefix group\n\nExamples\n\njulia> reg, (x,) = create_noncommutative_variables([(\"x\", 1:3)]);\n\njulia> length(x)\n3\n\njulia> x[1]  # monomial for x‚ÇÅ\nNormalMonomial{NonCommutativeAlgebra, UInt8}(...)\n\njulia> reg, (x, y) = create_noncommutative_variables([(\"x\", 1:2), (\"y\", 3:4)]);\n\njulia> length(x), length(y)\n(2, 2)\n\n\n\n\n\n","category":"function"},{"location":"apis/interface/#NCTSSoS.SolverConfig","page":"User interface","title":"NCTSSoS.SolverConfig","text":"SolverConfig(; optimizer, order, cs_algo=NoElimination(), ts_algo=NoElimination())\n\nConfiguration for solving polynomial optimization problems.\n\nKeyword Arguments\n\noptimizer (required): The optimizer to use for solving the SDP problem (e.g. Clarabel.Optimizer)\norder::Int: The order of the moment relaxation (default: 0)\ncs_algo::EliminationAlgorithm: Algorithm for correlative sparsity exploitation (default: NoElimination())\nts_algo::EliminationAlgorithm: Algorithm for term sparsity exploitation (default: NoElimination())\n\nExamples\n\njulia> solver_config = SolverConfig(optimizer=Clarabel.Optimizer, order=2) # default elimination algorithms\nSolverConfig(Clarabel.MOIwrapper.Optimizer, 2, NoElimination(), NoElimination())\n\n\n\n\n\n","category":"type"},{"location":"apis/interface/#NCTSSoS.cs_nctssos","page":"User interface","title":"NCTSSoS.cs_nctssos","text":"cs_nctssos(pop::PolyOpt{P}, solver_config::SolverConfig; dualize::Bool=true) where {P}\n\nSolve a polynomial optimization problem using the CS-NCTSSOS method with correlative sparsity and term sparsity exploitation.\n\nArguments\n\npop::PolyOpt{P}: The polynomial optimization problem to solve\nsolver_config::SolverConfig: Configuration containing optimizer, moment order, and sparsity algorithms\n\nKeyword Arguments\n\ndualize::Bool=true: Whether to dualize the moment relaxation to a sum-of-squares problem\n\nReturns\n\nPolyOptResult: Result containing the objective value, correlative sparsity structure, and term sparsity information\n\nDescription\n\nThis function solves a polynomial optimization problem by:\n\nComputing correlative sparsity to decompose the problem into smaller cliques\nComputing term sparsity for each clique to further reduce problem size\nFormulating and solving either the moment relaxation or its SOS dual\nReturning the optimal objective value and sparsity information\n\nThe moment order is automatically determined from the polynomial degrees if not specified in solver_config.\n\n\n\n\n\ncs_nctssos(pop::PolyOpt{A,T,P}, solver_config::SolverConfig; dualize::Bool=true)\n\nSolve a state polynomial optimization problem using the CS-NCTSSOS method.\n\nArguments\n\npop::PolyOpt{A,T,P}: The polynomial optimization problem with NCStatePolynomial objective\nsolver_config::SolverConfig: Configuration containing optimizer, moment order, and sparsity algorithms\n\nKeyword Arguments\n\ndualize::Bool=true: Whether to dualize the moment relaxation to a sum-of-squares problem\n\nReturns\n\nPolyOptResult: Result containing the objective value and sparsity information\n\nDescription\n\nThis function solves a state polynomial optimization problem by:\n\nComputing correlative sparsity to decompose the problem into smaller cliques\nComputing term sparsity for each clique to further reduce problem size\nFormulating and solving the SOS dual of the moment relaxation\nReturning the optimal objective value and sparsity information\n\nNote on order selection\n\nThe relaxation order should be at least ceil(max_objective_degree / 2) to properly capture the objective. For state polynomials with degree-2 terms like ‚ü®x‚ÇÅy‚ÇÅ‚ü©, use order >= 1. If order=0 is specified, it will be automatically computed from the maximum polynomial degree.\n\n\n\n\n\n","category":"function"},{"location":"apis/interface/#NCTSSoS.cs_nctssos_higher","page":"User interface","title":"NCTSSoS.cs_nctssos_higher","text":"cs_nctssos_higher(pop::PolyOpt{T}, prev_res::PolyOptResult, solver_config::SolverConfig; dualize::Bool=true) where {T}\n\nSolve a polynomial optimization problem using higher-order term sparsity based on a previous result.\n\nArguments\n\npop::PolyOpt{T}: The polynomial optimization problem to solve\nprev_res::PolyOptResult: Previous optimization result containing sparsity information to build upon\nsolver_config::SolverConfig: Configuration containing optimizer and sparsity algorithms\n\nKeyword Arguments\n\ndualize::Bool=true: Whether to dualize the moment relaxation to a sum-of-squares problem\n\nReturns\n\nPolyOptResult: Result containing the objective value, correlative sparsity structure, and updated term sparsity information\n\nDescription\n\nThis function performs a higher-order iteration of the CS-NCTSSOS method by:\n\nUsing the correlative sparsity structure from the previous result\nComputing new term sparsity based on the union of previously activated supports\nFormulating and solving either the moment relaxation or its SOS dual with the refined sparsity\nReturning the optimal objective value and updated sparsity information\n\nThis is typically used when the previous relaxation was not tight enough and a higher-order relaxation is needed.\n\n\n\n\n\n","category":"function"},{"location":"manual/polynomial_optimization/#polynomial-optimization","page":"Polynomial Optimization","title":"Polynomial Optimization","text":"Polynomial optimization is a mathematical optimization problem where the objective function is a polynomial of variable unknowns and the constraints are polynomial inequalities and equalities. In general, finding the exact solution to a polynomial optimization problem is NP-hard(Wang and Magron, 2021). However, moment and sum-of-squares relaxations can be applied to obtain lower/upper bounds to polynomial optimization problems efficiently.","category":"section"},{"location":"manual/polynomial_optimization/#noncommutative-polynomial-optimization","page":"Polynomial Optimization","title":"Noncommutative Polynomial Optimization","text":"Noncommutative polynomial optimization concerns when variables are noncommuting. These variables can be thought of as matrices or operators acting on an (infinite dimension) separable Hilbert space mathcalH. The numerical value of the objective function may take two meanings.\n\nThe eigenvalue of the polynomial of operators, giving a general form of minimization problem as\n\nmathrminf_mathbfxinmathcalB(mathcalH)^n lambda_min(f(mathbfx))  text st  g_1(mathbfx)ge0ldotsg_m(mathbfx)ge0h_1(mathbfx)=0ldotsh_ell(mathbfx)=0\n\nThe trace of the polynomial of operators, giving a general form of minimization problem as\n\nmathrminf_mathbfxinmathcalB(mathcalH)^n mathrmtr(f(mathbfx))  text st  g_1(mathbfx)ge0ldotsg_m(mathbfx)ge0h_1(mathbfx)=0ldotsh_ell(mathbfx)=0\n\nwhere\n\nfg_1ldotsg_mh_1ldotsh_ellinmathbbRlanglemathbfxrangle\n\nare noncommutative polynomials in noncommuting variables mathbfx.","category":"section"},{"location":"examples/generated/pauli_algebra_interface/#Simplified-Quantum-Spin-Models-with-Pauli-Algebra","page":"Pauli Algebra Interface","title":"Simplified Quantum Spin Models with Pauli Algebra","text":"NCTSSoS.jl provides a convenient interface for working with common quantum algebras, eliminating the need to manually specify commutation relations and constraints. This tutorial demonstrates the create_pauli_variables function for quantum spin systems, which significantly simplifies the problem setup for polynomial optimization problems in quantum many-body physics (Wang et al., 2024).","category":"section"},{"location":"examples/generated/pauli_algebra_interface/#The-Problem:-Manual-Constraint-Specification-(Legacy-API-Deprecated)","page":"Pauli Algebra Interface","title":"The Problem: Manual Constraint Specification (Legacy API - Deprecated)","text":"Deprecated APIThe following example demonstrates the legacy API using @ncpolyvar and manual constraint specification. This API is deprecated and will be removed in a future version. Please use the new typed algebra API demonstrated in the next section.\n\nWhen working with quantum spin systems, the old approach required manually defining all Pauli operator commutation relations. This was tedious, error-prone, and obscured the physics of the problem. Let's see this with a concrete example.","category":"section"},{"location":"examples/generated/pauli_algebra_interface/#Traditional-Approach:-Heisenberg-XXX-Model-(Deprecated)","page":"Pauli Algebra Interface","title":"Traditional Approach: Heisenberg XXX Model (Deprecated)","text":"The Heisenberg XXX Hamiltonian for a 1D chain with periodic boundary conditions is:\n\nH = frac14 sum_i=1^N left( sigma_i^x sigma_i+1^x + sigma_i^y sigma_i+1^y + sigma_i^z sigma_i+1^z right)\n\nwhere sigma_i^xyz are the Pauli operators at site i. In the legacy API, solving for the ground state energy using polynomial optimization required:\n\n# DEPRECATED - Do not use in new code\nusing NCTSSoS, MosekTools\nN = 6  # Number of spins in the chain\n\n# Step 1: Declare non-commutative variables for Pauli operators\n@ncpolyvar x[1:N] y[1:N] z[1:N]  # Requires DynamicPolynomials\n\n# Step 2: Construct the Hamiltonian\nham = sum(ComplexF64(1/4) * op[i] * op[mod1(i+1, N)] for op in [x, y, z] for i in 1:N)\n\n# Step 3: Manually specify all 36 Pauli commutation relations (!)\neq_cons = reduce(vcat, [\n    [x[i] * y[i] - im * z[i],   # sigma_x * sigma_y = i*sigma_z\n     y[i] * x[i] + im * z[i],   # sigma_y * sigma_x = -i*sigma_z\n     ...  # and so on for all 6 relations at each site\n    ]\n    for i in 1:N\n])\n\n# Step 4: Create the optimization problem with all constraints\npop_old = cpolyopt(ham;\n    eq_constraints=eq_cons,                     # Pauli commutation relations\n    comm_gps=[[x[i], y[i], z[i]] for i in 1:N], # Operators on different sites commute\n    is_unipotent=true                           # Pauli operators square to identity\n)\n\nThis approach required 36 constraint equations for just 6 spins! As the system size grew, this became increasingly cumbersome and error-prone.","category":"section"},{"location":"examples/generated/pauli_algebra_interface/#The-Solution:-Typed-Algebra-Variables-(Recommended-API)","page":"Pauli Algebra Interface","title":"The Solution: Typed Algebra Variables (Recommended API)","text":"The create_pauli_variables function encapsulates all these constraints automatically through Julia's type system, allowing you to focus on the physics rather than the algebra.","category":"section"},{"location":"examples/generated/pauli_algebra_interface/#Simplified-Approach-with-create_pauli_variables","page":"Pauli Algebra Interface","title":"Simplified Approach with create_pauli_variables","text":"The same problem can be solved much more concisely:\n\nusing NCTSSoS, MosekTools\nN = 6  # Number of spins in the chain\n\nregistry, (œÉx, œÉy, œÉz) = create_pauli_variables(1:N)\n\nConstruct the Hamiltonian (same formula, cleaner variables)\n\nham = sum(ComplexF64(1/4) * op[i] * op[mod1(i+1, N)]\n          for op in [œÉx, œÉy, œÉz] for i in 1:N)\n\nCreate the optimization problem - constraints are handled automatically by the algebra type!\n\npop = polyopt(ham, registry)\n\nThe new interface is much cleaner: just 4 lines instead of 40+, and eliminates the possibility of typos in constraint equations.","category":"section"},{"location":"examples/generated/pauli_algebra_interface/#Computing-Ground-State-Energy","page":"Pauli Algebra Interface","title":"Computing Ground State Energy","text":"Now we can solve for the ground state energy lower bound using the cs_nctssos solver. We configure it to use a second-order moment relaxation (Wang et al., 2024).\n\nsolver_config = SolverConfig(\n    optimizer=Mosek.Optimizer,  # SDP solver backend\n    order=2                     # Relaxation order (higher = tighter bound)\n)\n\nres = cs_nctssos(pop, solver_config)\nenergy_per_site = res.objective / N\n\nThe result provides a certified lower bound on the ground state energy per site. For the 6-site XXX Heisenberg chain, this yields approximately -0.467129, which matches the exact value to high precision (Wang et al., 2024).","category":"section"},{"location":"examples/generated/pauli_algebra_interface/#Advantages-of-Typed-Algebra-Variables","page":"Pauli Algebra Interface","title":"Advantages of Typed Algebra Variables","text":"The create_pauli_variables interface provides several key benefits:\n\nAutomatic constraint generation: All Pauli commutation relations are encoded correctly through the PauliAlgebra type without manual specification.\nError prevention: Eliminates typos and sign errors in constraint equations.\nCode clarity: The physics intent is immediately clear from the function name.\nScalability: Works seamlessly for any system size without code modification.\nConsistency: Ensures the same algebraic structure across different problems.\nExtensibility: Can still add custom constraints when needed for specific physical scenarios.","category":"section"},{"location":"examples/generated/pauli_algebra_interface/#Other-Algebra-Types","page":"Pauli Algebra Interface","title":"Other Algebra Types","text":"Similar functions exist for other quantum algebras:\n\ncreate_fermionic_variables: Fermionic operators with anticommutation relations\ncreate_bosonic_variables: Bosonic operators with commutation relations\ncreate_projector_variables: Projector operators (P¬≤ = P)\ncreate_unipotent_variables: Unipotent operators (U¬≤ = I)\ncreate_noncommutative_variables: Generic non-commutative variables","category":"section"},{"location":"examples/generated/pauli_algebra_interface/#Next-Steps","page":"Pauli Algebra Interface","title":"Next Steps","text":"This interface extends naturally to other quantum systems:\n\nFor systems with more complex geometries, see the 2D lattice examples\nFor correlation function bounds, see certifying ground state properties\nFor non-local correlations, explore Bell inequalities\n\nThe typed algebra approach demonstrates how NCTSSoS.jl bridges the gap between physical intuition and mathematical formalism, making quantum many-body optimization more accessible and reliable.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/generated/trace_poly/#tracial-polynomial-optimization","page":"Trace Polynomial","title":"Tracial Polynomial Optimization","text":"Tracial polynomial optimization minimizes polynomial expressions involving traces of noncommutative operators ‚Äî a natural formulation for optimizing over quantum states via the moment-SOS hierarchy (Klep et al., 2022).\n\nThis example covers three problems of increasing complexity:\n\nA toy problem with projector variables ‚Äî minimal setup to learn the API.\nThe CHSH Bell inequality ‚Äî recovering the Tsirelson bound 2sqrt2.\nA covariance Bell inequality ‚Äî nonlinear objective involving products of trace moments.\n\nPrerequisites: familiarity with tracial polynomial concepts and the polynomial optimization API.","category":"section"},{"location":"examples/generated/trace_poly/#Setup","page":"Trace Polynomial","title":"Setup","text":"We use Mosek as the SDP solver. The MOI.Silent() attribute suppresses solver output.\n\nusing NCTSSoS, MosekTools\n\nconst MOI = NCTSSoS.MOI\nconst SILENT_MOSEK = MOI.OptimizerWithAttributes(Mosek.Optimizer, MOI.Silent() => true);\n\n","category":"section"},{"location":"examples/generated/trace_poly/#Toy-Example:-Projector-Trace-Polynomial","page":"Trace Polynomial","title":"Toy Example: Projector Trace Polynomial","text":"Minimize a tracial polynomial over three projector variables P_1 P_2 P_3 satisfying P_i^2 = P_i:\n\nf = operatornametr(P_1 P_2 P_3)\n  + operatornametr(P_1 P_2)operatornametr(P_3)","category":"section"},{"location":"examples/generated/trace_poly/#Step-1-‚Äî-Create-projector-variables","page":"Trace Polynomial","title":"Step 1 ‚Äî Create projector variables","text":"Each tuple (\"x\", 1:3) declares a label group: the string is a name prefix and the range gives the indices, producing variables x[1], x[2], x[3]. The returned registry stores the symbol ‚Üî index mapping and algebra constraints; it is passed to polyopt so the solver knows the variable structure.\n\nregistry, (x,) = create_projector_variables([(\"x\", 1:3)]);","category":"section"},{"location":"examples/generated/trace_poly/#Step-2-‚Äî-Build-the-tracial-objective","page":"Trace Polynomial","title":"Step 2 ‚Äî Build the tracial objective","text":"tr wraps a Polynomial into a StatePolynomial ‚Äî a symbolic expression over trace moments. To feed it to polyopt, multiply by the identity monomial ùüô to obtain an NCStatePolynomial.\n\nùüô = one(NormalMonomial{ProjectorAlgebra, UInt8})\np = (tr(x[1] * x[2] * x[3]) + tr(x[1] * x[2]) * tr(x[3])) * ùüô;","category":"section"},{"location":"examples/generated/trace_poly/#Step-3-‚Äî-Formulate-and-solve","page":"Trace Polynomial","title":"Step 3 ‚Äî Formulate and solve","text":"SolverConfig sets the SDP backend and hierarchy order. Higher orders yield tighter bounds at the cost of larger SDPs.\n\nspop = polyopt(p, registry);\n\nsolver_config = SolverConfig(; optimizer=SILENT_MOSEK, order=2);\nresult = cs_nctssos(spop, solver_config);\n\n@show result.objective\n@assert isapprox(result.objective, -0.046717378455438933, atol=1e-6)\n\nresult.objective = -0.046717378455481205\n","category":"section"},{"location":"examples/generated/trace_poly/#Step-4-‚Äî-Tighten-the-bound-at-order-3","page":"Trace Polynomial","title":"Step 4 ‚Äî Tighten the bound at order 3","text":"solver_config = SolverConfig(; optimizer=SILENT_MOSEK, order=3);\nresult = cs_nctssos(spop, solver_config);\n\n@show result.objective\n@assert isapprox(result.objective, -0.03124998978001017, atol=1e-6)\n\nresult.objective = -0.03124998978003755\n\n\nThe literature values are -00467 (order 2) and -00312 (order 3); our results match within 10^-6 (Klep et al., 2022).\n\n","category":"section"},{"location":"examples/generated/trace_poly/#CHSH-Bell-Inequality-(Tracial-Form)","page":"Trace Polynomial","title":"CHSH Bell Inequality (Tracial Form)","text":"The CHSH inequality bounds correlations between two parties whose pm 1 observables are A_1 A_2 (Alice) and B_1 B_2 (Bob):\n\nmathcalB_textCHSH\n  = operatornametr(A_1 B_1) + operatornametr(A_1 B_2)\n  + operatornametr(A_2 B_1) - operatornametr(A_2 B_2)\n\nClassical bound: mathcalB leq 2. Quantum bound (Tsirelson): mathcalB leq 2sqrt2 approx 2828.\n\nWe model the observables with UnipotentAlgebra (U^2 = I). Since cs_nctssos minimizes, we negate the Bell expression and expect approx -2sqrt2.","category":"section"},{"location":"examples/generated/trace_poly/#Step-1-‚Äî-Create-unipotent-variables-(single-group)","page":"Trace Polynomial","title":"Step 1 ‚Äî Create unipotent variables (single group)","text":"Variables in the same label group do not commute. We place all four observables in one group, then split into Alice/Bob symbols.\n\nnote: Why non-commuting? The transpose trick\nIn the tracial formulation, bipartite expectations over a maximally entangled state are rewritten via the identity langlephi^+Aotimes Bphi^+rangle = tfrac1koperatornameTr(AB^mathsf T) (Klep et al., 2022). When we write tr(x·µ¢ * y‚±º), the variable y‚±º represents the transposed Bob operator B_j^mathsf T. Placing Alice and Bob in separate label groups would impose A_i B_j^mathsf T = 0, which is stronger than the physical tensor-product commutation A_i otimes I I otimes B_j = 0. Using a single group leaves the variables non-commuting, matching the correct constraint set. See the Bell inequalities example for the state-polynomial formulation, where separate groups are appropriate.\n\nregistry, (vars,) = create_unipotent_variables([(\"v\", 1:4)]);\nx = vars[1:2];  # Alice: A‚ÇÅ, A‚ÇÇ\ny = vars[3:4];  # Bob:   B‚ÇÅ, B‚ÇÇ","category":"section"},{"location":"examples/generated/trace_poly/#Step-2-‚Äî-Define-the-negated-CHSH-expression","page":"Trace Polynomial","title":"Step 2 ‚Äî Define the negated CHSH expression","text":"ùüô = one(NormalMonomial{UnipotentAlgebra, UInt8})\n\np = -1.0 * tr(x[1] * y[1]) +  ## ‚àítr(A‚ÇÅB‚ÇÅ)\n    -1.0 * tr(x[1] * y[2]) +  ## ‚àítr(A‚ÇÅB‚ÇÇ)\n    -1.0 * tr(x[2] * y[1]) +  ## ‚àítr(A‚ÇÇB‚ÇÅ)\n     1.0 * tr(x[2] * y[2]);   ## +tr(A‚ÇÇB‚ÇÇ)","category":"section"},{"location":"examples/generated/trace_poly/#Step-3-‚Äî-Solve-with-term-sparsity-exploitation","page":"Trace Polynomial","title":"Step 3 ‚Äî Solve with term-sparsity exploitation","text":"Setting ts_algo = MaximalElimination() decomposes the SDP into smaller blocks via connected components of the variable interaction graph.\n\ntpop = polyopt(p * ùüô, registry);\n\nsolver_config = SolverConfig(; optimizer=SILENT_MOSEK, order=1, ts_algo=MaximalElimination());\nresult = cs_nctssos(tpop, solver_config);\n\n@show result.objective\n@assert isapprox(result.objective, -2 * sqrt(2), atol=1e-5)\n\nresult.objective = -2.8284271321623193\n\n\nThe result recovers the Tsirelson bound -2sqrt2 approx -2828 (Klep et al., 2022).\n\n","category":"section"},{"location":"examples/generated/trace_poly/#Covariance-Bell-Inequality","page":"Trace Polynomial","title":"Covariance Bell Inequality","text":"Nonlinear Bell inequalities involve products of trace moments. The covariance of observables A_i B_j is:\n\noperatornameCov(A_i B_j)\n  = operatornametr(A_i B_j)\n  - operatornametr(A_i)operatornametr(B_j)\n\nWe maximize the covariance Bell expression from (Pozsgay et al., 2017):\n\nf = sum_(ij)in S^+ operatornameCov(A_i B_j)\n  - sum_(ij)in S^- operatornameCov(A_i B_j)\n\nwhere S^+ = (11)(12)(13)(21)(22)(31) and S^- = (23)(32). Classical bound: f leq 45.  Quantum bound: f = 5.","category":"section"},{"location":"examples/generated/trace_poly/#Step-1-‚Äî-Create-unipotent-variables-(single-group)-2","page":"Trace Polynomial","title":"Step 1 ‚Äî Create unipotent variables (single group)","text":"As with CHSH above, the tracial formulation requires non-commuting variables (see the note on the transpose trick). We place all six observables in one group and split afterward.\n\nregistry, (vars,) = create_unipotent_variables([(\"v\", 1:6)]);\nx = vars[1:3];  # Alice: A‚ÇÅ, A‚ÇÇ, A‚ÇÉ\ny = vars[4:6];  # Bob:   B‚ÇÅ, B‚ÇÇ, B‚ÇÉ\n\nùüô = one(typeof(x[1]));","category":"section"},{"location":"examples/generated/trace_poly/#Step-2-‚Äî-Define-the-covariance-helper","page":"Trace Polynomial","title":"Step 2 ‚Äî Define the covariance helper","text":"cov(a, b) = 1.0 * tr(x[a] * y[b]) - 1.0 * tr(x[a]) * tr(y[b]);","category":"section"},{"location":"examples/generated/trace_poly/#Step-3-‚Äî-Build-and-solve-the-negated-objective","page":"Trace Polynomial","title":"Step 3 ‚Äî Build and solve the negated objective","text":"p = -1.0 * (\n    cov(1, 1) + cov(1, 2) + cov(1, 3) +   ## S‚Å∫ terms\n    cov(2, 1) + cov(2, 2) - cov(2, 3) +   ## mixed signs\n    cov(3, 1) - cov(3, 2)                  ## S‚Åª term: ‚àíCov(A‚ÇÉ,B‚ÇÇ)\n);\n\ntpop = polyopt(p * ùüô, registry);\n\nsolver_config = SolverConfig(; optimizer=SILENT_MOSEK, order=2);\nresult = cs_nctssos(tpop, solver_config);\n\n@show result.objective\nabs_error = abs(result.objective + 5.0)\n@show abs_error\n@assert abs_error < 1e-3\n\nresult.objective = -4.999999995209357\nabs_error = 4.79064343750224e-9\n\n\nThe quantum value -5 is recovered within 10^-3 (Pozsgay et al., 2017).\n\n","category":"section"},{"location":"examples/generated/trace_poly/#Summary","page":"Trace Polynomial","title":"Summary","text":"Problem Algebra Classical Quantum\nToy trace polynomial ProjectorAlgebra (P^2 = P) ‚Äî ‚àí0.0312 (order 3)\nCHSH (tracial) UnipotentAlgebra (U^2 = I) 2 2sqrt2 approx 2828\nCovariance Bell UnipotentAlgebra (U^2 = I) 4.5 5\n\nKey API:\n\ncreate_projector_variables / create_unipotent_variables: create operators with P^2 = P or U^2 = I constraints\ntr: build trace moments (tracial state)\npolyopt: formulate the optimization problem\nSolverConfig: set solver backend, hierarchy order, and sparsity options\ncs_nctssos: solve via the moment-SOS hierarchy\n\nFor linear (non-tracial) Bell inequalities, see the Bell inequalities example.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/generated/bell/#Bell-inequalities","page":"Bell inequalities","title":"Bell inequalities","text":"Bell inequalities test whether quantum mechanics can be explained by local hidden variable theories. They are linear combinations of expectation values with bounds that differ between classical and quantum theories.\n\nThe general form of a Bell inequality is:\n\nsum_ij c_ij langle A_i B_j rangle leq C\n\nwhere A_i and B_j are observables measured by Alice and Bob, c_ij are coefficients, and C is the classical bound. Quantum mechanics can exceed this bound.","category":"section"},{"location":"examples/generated/bell/#Setup","page":"Bell inequalities","title":"Setup","text":"We use NCTSSoS.jl for polynomial optimization and COSMO as the SDP solver backend.\n\nusing NCTSSoS, COSMO","category":"section"},{"location":"examples/generated/bell/#Key-Concepts:-Unipotent-and-Projector-Variables","page":"Bell inequalities","title":"Key Concepts: Unipotent and Projector Variables","text":"Bell inequalities use two types of measurement operators:\n\nUnipotent operators (U^2 = I): Model ¬±1-valued observables like Pauli matrices\nProjector operators (P^2 = P): Model projection measurements like 0ranglelangle 0\n\nLet's demonstrate both:","category":"section"},{"location":"examples/generated/bell/#Unipotent-Variables-(U-I)","page":"Bell inequalities","title":"Unipotent Variables (U¬≤ = I)","text":"Create operators that square to identity:\n\nreg_unip, (A, B) = create_unipotent_variables([(\"A\", 1:2), (\"B\", 1:2)])\n\nreg_unip: registry storing variable names and algebra type A: Alice's measurement operators [A‚ÇÅ, A‚ÇÇ] on site 1 B: Bob's measurement operators [B‚ÇÅ, B‚ÇÇ] on site 2\n\nVerify the unipotent property (U¬≤ = I):\n\nA[1] * A[1]  # should simplify to identity\n\nCheck that operators on different sites commute:\n\nA[1] * B[1] == B[1] * A[1]  # true: different sites commute","category":"section"},{"location":"examples/generated/bell/#Projector-Variables-(P-P)","page":"Bell inequalities","title":"Projector Variables (P¬≤ = P)","text":"Create operators that are idempotent:\n\nreg_proj, (P, Q) = create_projector_variables([(\"P\", 1:2), (\"Q\", 1:2)])\n\nreg_proj: registry for projector algebra P: Alice's projectors [P‚ÇÅ, P‚ÇÇ] on site 1 Q: Bob's projectors [Q‚ÇÅ, Q‚ÇÇ] on site 2\n\nVerify the idempotent property (P¬≤ = P):\n\nmonomials(P[1] * P[1])  # should be [P[1]]\n\n","category":"section"},{"location":"examples/generated/bell/#Linear-Bell-Inequalities","page":"Bell inequalities","title":"Linear Bell Inequalities","text":"","category":"section"},{"location":"examples/generated/bell/#CHSH-Inequality","page":"Bell inequalities","title":"CHSH Inequality","text":"The CHSH inequality involves two parties with two ¬±1-valued observables each. The objective function is:\n\nf(A_1 A_2 B_1 B_2) = langle A_1 B_1 rangle + langle A_1 B_2 rangle + langle A_2 B_1 rangle - langle A_2 B_2 rangle\n\nClassical bound: f leq 2. Quantum bound (Tsirelson): f leq 2sqrt2 approx 2828.","category":"section"},{"location":"examples/generated/bell/#Step-1:-Create-unipotent-variables-for-CHSH","page":"Bell inequalities","title":"Step 1: Create unipotent variables for CHSH","text":"registry, (x, y) = create_unipotent_variables([(\"x\", 1:2), (\"y\", 1:2)])\n\nregistry: variable registry encoding U¬≤ = I constraint x: Alice's observables [x‚ÇÅ, x‚ÇÇ] = [A‚ÇÅ, A‚ÇÇ] y: Bob's observables [y‚ÇÅ, y‚ÇÇ] = [B‚ÇÅ, B‚ÇÇ]","category":"section"},{"location":"examples/generated/bell/#Step-2:-Define-the-CHSH-objective-function","page":"Bell inequalities","title":"Step 2: Define the CHSH objective function","text":"f = 1.0 * x[1] * y[1] +  # ‚ü®A‚ÇÅB‚ÇÅ‚ü© term\n    1.0 * x[1] * y[2] +  # ‚ü®A‚ÇÅB‚ÇÇ‚ü© term\n    1.0 * x[2] * y[1] -  # ‚ü®A‚ÇÇB‚ÇÅ‚ü© term\n    1.0 * x[2] * y[2]    # -‚ü®A‚ÇÇB‚ÇÇ‚ü© term\n\nf: polynomial representing the CHSH Bell operator\n\nInspect the polynomial structure:\n\n(monomials(f),      # list of monomials in f\n coefficients(f))   # corresponding coefficients","category":"section"},{"location":"examples/generated/bell/#Step-3:-Create-the-optimization-problem","page":"Bell inequalities","title":"Step 3: Create the optimization problem","text":"pop = polyopt(f, registry)\n\npop: polynomial optimization problem maximizing f      subject to the algebraic constraints in registry (U¬≤ = I)","category":"section"},{"location":"examples/generated/bell/#Step-4:-Configure-and-run-the-SDP-solver","page":"Bell inequalities","title":"Step 4: Configure and run the SDP solver","text":"solver_config = SolverConfig(\n    optimizer = COSMO.Optimizer,  # SDP solver backend\n    order = 1                      # relaxation order (hierarchy level)\n)\n\nsolver_config: specifies solver and relaxation parameters\n\nresult = cs_nctssos(pop, solver_config)\n\nresult: optimization result containing objective value and solver info","category":"section"},{"location":"examples/generated/bell/#Step-5:-Extract-the-upper-bound","page":"Bell inequalities","title":"Step 5: Extract the upper bound","text":"chsh_bound = result.objective\n\nchsh_bound: upper bound on maximal quantum violation\n\nCompare with Tsirelson's bound:\n\ntsirelson_bound = 2 * sqrt(2)\n\ntsirelson_bound: theoretical maximum = 2‚àö2 ‚âà 2.828\n\nabs(chsh_bound - tsirelson_bound)  # difference (should be ~1e-7)\n\n","category":"section"},{"location":"examples/generated/bell/#I_{3322}-Inequality","page":"Bell inequalities","title":"I_3322 Inequality","text":"The I_3322 inequality uses projector observables (P¬≤ = P) with three measurements per party (P√°l and V√©rtesi, 2010).\n\nf = langle A_1(B_1+B_2+B_3) rangle + langle A_2(B_1+B_2-B_3) rangle + langle A_3(B_1-B_2) rangle - langle A_1 rangle - 2langle B_1 rangle - langle B_2 rangle\n\nClassical bound: f leq 0. Quantum bound: f leq 025.","category":"section"},{"location":"examples/generated/bell/#Step-1:-Create-projector-variables","page":"Bell inequalities","title":"Step 1: Create projector variables","text":"registry, (x, y) = create_projector_variables([(\"x\", 1:3), (\"y\", 1:3)])\n\nregistry: variable registry encoding P¬≤ = P constraint x: Alice's projectors [x‚ÇÅ, x‚ÇÇ, x‚ÇÉ] = [A‚ÇÅ, A‚ÇÇ, A‚ÇÉ] y: Bob's projectors [y‚ÇÅ, y‚ÇÇ, y‚ÇÉ] = [B‚ÇÅ, B‚ÇÇ, B‚ÇÉ]","category":"section"},{"location":"examples/generated/bell/#Step-2:-Define-the-I-objective-function","page":"Bell inequalities","title":"Step 2: Define the I‚ÇÉ‚ÇÉ‚ÇÇ‚ÇÇ objective function","text":"f = 1.0 * x[1] * (y[1] + y[2] + y[3]) +  # A‚ÇÅ(B‚ÇÅ+B‚ÇÇ+B‚ÇÉ)\n    1.0 * x[2] * (y[1] + y[2] - y[3]) +  # A‚ÇÇ(B‚ÇÅ+B‚ÇÇ-B‚ÇÉ)\n    1.0 * x[3] * (y[1] - y[2]) -         # A‚ÇÉ(B‚ÇÅ-B‚ÇÇ)\n    1.0 * x[1] -                          # -A‚ÇÅ\n    2.0 * y[1] -                          # -2B‚ÇÅ\n    1.0 * y[2]                            # -B‚ÇÇ\n\nf: I‚ÇÉ‚ÇÉ‚ÇÇ‚ÇÇ Bell polynomial\n\nCheck the number of terms:\n\nlength(monomials(f))  # number of monomials","category":"section"},{"location":"examples/generated/bell/#Step-3:-Solve-(minimizing-f-to-find-maximum-of-f)","page":"Bell inequalities","title":"Step 3: Solve (minimizing -f to find maximum of f)","text":"pop = polyopt(-f, registry)\n\npop: minimize -f (equivalent to maximize f)\n\nsolver_config = SolverConfig(optimizer=COSMO.Optimizer, order=2)\n\norder=2: second level of the moment hierarchy\n\nresult = cs_nctssos(pop, solver_config)\ni3322_bound = -result.objective\n\ni3322_bound: upper bound on I‚ÇÉ‚ÇÉ‚ÇÇ‚ÇÇ violation (negate since we minimized -f)\n\ni3322_bound  # should be close to 0.25\n\n","category":"section"},{"location":"examples/generated/bell/#Exploiting-Sparsity-for-Larger-Problems","page":"Bell inequalities","title":"Exploiting Sparsity for Larger Problems","text":"Higher relaxation orders improve bounds but increase SDP size. Sparsity exploitation reduces computational cost:\n\nCorrelative Sparsity (CS): Decomposes problem by variable interactions\nTerm Sparsity (TS): Removes unnecessary monomials from moment matrices\n\nLet's solve I‚ÇÉ‚ÇÉ‚ÇÇ‚ÇÇ at order=6 using correlative sparsity:","category":"section"},{"location":"examples/generated/bell/#Without-sparsity-(for-comparison,-order3)","page":"Bell inequalities","title":"Without sparsity (for comparison, order=3)","text":"registry, (x, y) = create_projector_variables([(\"x\", 1:3), (\"y\", 1:3)])\nf = 1.0 * x[1] * (y[1] + y[2] + y[3]) + x[2] * (y[1] + y[2] - y[3]) +\n    x[3] * (y[1] - y[2]) - x[1] - 2 * y[1] - y[2]\npop = polyopt(-f, registry)\n\nsolver_config_dense = SolverConfig(optimizer=COSMO.Optimizer, order=3)\n\nsolverconfigdense: no sparsity exploitation\n\n@time result_dense = cs_nctssos(pop, solver_config_dense)\nbound_dense = -result_dense.objective\n\nbound_dense: bound without sparsity\n\nbound_dense","category":"section"},{"location":"examples/generated/bell/#With-correlative-sparsity-(order6)","page":"Bell inequalities","title":"With correlative sparsity (order=6)","text":"solver_config_sparse = SolverConfig(\n    optimizer = COSMO.Optimizer,\n    order = 6,             # higher order for better bound\n    cs_algo = MF()         # use MaxFlow algorithm for correlative sparsity\n)\n\ncs_algo=MF(): enables correlative sparsity via chordal graph decomposition\n\n@time result_sparse = cs_nctssos(pop, solver_config_sparse)\nbound_sparse = -result_sparse.objective\n\nbound_sparse: improved bound using sparsity\n\nbound_sparse  # closer to theoretical 0.25\n\nImprovement in bound:\n\nbound_dense - bound_sparse  # positive = improvement\n\n","category":"section"},{"location":"examples/generated/bell/#Nonlinear-Bell-Inequalities","page":"Bell inequalities","title":"Nonlinear Bell Inequalities","text":"Nonlinear Bell inequalities involve polynomial functions of expectation values, not just linear combinations. They can detect non-locality where linear inequalities fail.","category":"section"},{"location":"examples/generated/bell/#Covariance-Bell-Inequality","page":"Bell inequalities","title":"Covariance Bell Inequality","text":"The covariance between observables A and B is:\n\ntextCov(A B) = langle AB rangle - langle A rangle langle B rangle\n\nThis is nonlinear because it involves products of expectation values.\n\nThe covariance Bell inequality (Pozsgay et al., 2017):\n\nf = sum_ij s_ij textCov(A_i B_j)\n\nwith signs s_ij in +1 -1. Classical bound: f leq 45. Quantum bound: f = 5.","category":"section"},{"location":"examples/generated/bell/#Step-1:-Create-unipotent-variables","page":"Bell inequalities","title":"Step 1: Create unipotent variables","text":"registry, (x, y) = create_unipotent_variables([(\"x\", 1:3), (\"y\", 1:3)])\n\nx: Alice's observables [A‚ÇÅ, A‚ÇÇ, A‚ÇÉ] y: Bob's observables [B‚ÇÅ, B‚ÇÇ, B‚ÇÉ]","category":"section"},{"location":"examples/generated/bell/#Step-2:-Define-the-identity-monomial","page":"Bell inequalities","title":"Step 2: Define the identity monomial","text":"ID = one(NormalMonomial{UnipotentAlgebra, UInt8})\n\nID: identity element (ùüô) needed for state polynomial arithmetic\n\nID  # display the identity","category":"section"},{"location":"examples/generated/bell/#Step-3:-Define-the-covariance-function-using-state-polynomials","page":"Bell inequalities","title":"Step 3: Define the covariance function using state polynomials","text":"State polynomials use œÇ(¬∑) to denote expectation values ‚ü®¬∑‚ü©.\n\ncov(a, b) = 1.0 * œÇ(x[a] * y[b]) * ID -  # ‚ü®A·µ¢B‚±º‚ü©\n            1.0 * œÇ(x[a]) * œÇ(y[b]) * ID  # -‚ü®A·µ¢‚ü©‚ü®B‚±º‚ü©\n\ncov(a,b): covariance Cov(A‚Çê, B·µ¶) as a state polynomial œÇ (varsigma): expectation value operator, type \\varsigma + Tab\n\nExample: Cov(A‚ÇÅ, B‚ÇÅ)\n\ncov(1, 1)","category":"section"},{"location":"examples/generated/bell/#Step-4:-Build-the-objective-function","page":"Bell inequalities","title":"Step 4: Build the objective function","text":"sp = cov(1,1) + cov(1,2) + cov(1,3) +  # Cov(A‚ÇÅ, B‚ÇÅ) + Cov(A‚ÇÅ, B‚ÇÇ) + Cov(A‚ÇÅ, B‚ÇÉ)\n     cov(2,1) + cov(2,2) - cov(2,3) +  # Cov(A‚ÇÇ, B‚ÇÅ) + Cov(A‚ÇÇ, B‚ÇÇ) - Cov(A‚ÇÇ, B‚ÇÉ)\n     cov(3,1) - cov(3,2)               # Cov(A‚ÇÉ, B‚ÇÅ) - Cov(A‚ÇÉ, B‚ÇÇ)\n\nsp: state polynomial for covariance Bell inequality","category":"section"},{"location":"examples/generated/bell/#Step-5:-Create-optimization-problem-and-solve","page":"Bell inequalities","title":"Step 5: Create optimization problem and solve","text":"spop = polyopt(sp, registry)\n\nspop: state polynomial optimization problem\n\nsolver_config = SolverConfig(\n    optimizer = COSMO.Optimizer,\n    order = 2\n)\n\nresult = cs_nctssos(spop, solver_config)\ncov_bound = -result.objective\n\ncov_bound: upper bound on covariance Bell violation\n\ncov_bound  # should be close to 5.0\n\nCompare with known quantum value:\n\nabs(cov_bound - 5.0)  # difference from theoretical value","category":"section"},{"location":"examples/generated/bell/#Step-6:-Improve-bound-using-term-sparsity-and-higher-order-iteration","page":"Bell inequalities","title":"Step 6: Improve bound using term sparsity and higher-order iteration","text":"solver_config_ts = SolverConfig(\n    optimizer = COSMO.Optimizer,\n    order = 3,\n    ts_algo = MF()  # term sparsity\n)\n\nts_algo=MF(): enables term sparsity exploitation\n\nresult_ts = cs_nctssos(spop, solver_config_ts)\n\nresult_ts: first iteration with term sparsity\n\nresult_higher = cs_nctssos_higher(spop, result_ts, solver_config_ts)\n\nresult_higher: higher-order iteration refining the bound\n\nimproved_bound = -result_higher.objective\n\nimproved_bound: refined upper bound\n\n(improved_bound,               # closer to 5.0\n abs(improved_bound - 5.0))    # very small difference from theoretical value\n\n","category":"section"},{"location":"examples/generated/bell/#Summary","page":"Bell inequalities","title":"Summary","text":"Inequality Operator Type Classical Bound Quantum Bound API\nCHSH Unipotent (U¬≤=I) 2 2‚àö2 ‚âà 2.828 create_unipotent_variables\nI‚ÇÉ‚ÇÉ‚ÇÇ‚ÇÇ Projector (P¬≤=P) 0 0.25 create_projector_variables\nCovariance Unipotent + State 4.5 5 œÇ(¬∑) state polynomials\n\nKey functions:\n\ncreate_unipotent_variables: Create U¬≤ = I operators\ncreate_projector_variables: Create P¬≤ = P operators\npolyopt: Create optimization problem\nSolverConfig: Configure solver and sparsity options\ncs_nctssos: Solve using moment-SOS hierarchy\nœÇ(¬∑): Expectation value for state polynomials\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"manual/sdp_relaxation/#semidefinite-programming","page":"SDP Relaxation","title":"Semidefinite Programming","text":"Semidefinite Programming (SDP) is a powerful optimization technique that can be used to solve a wide variety of problems in science and engineering, including many problems in quantum physics (Vandenberghe and Boyd, 1996). It is a generalization of linear programming, where instead of optimizing a linear function over a set of linear inequalities, we optimize a linear function over a set of \"semidefinite\" constraints.\n\nA semidefinite constraint is a condition on a matrix to be \"positive semidefinite\". A matrix is positive semidefinite if it is symmetric and all its eigenvalues are non-negative. This condition is a generalization of the concept of a non-negative number to matrices.\n\nSDP is particularly useful for problems involving sums of squares of polynomials, like the one we discussed in the previous section. This is because the condition that a polynomial is a sum of squares can be expressed as a semidefinite constraint. This allows us to use powerful numerical algorithms to solve these problems.","category":"section"},{"location":"manual/sdp_relaxation/#moment-sohs-hierarchy","page":"SDP Relaxation","title":"Moment Sum-of-Hermitian-Square Hierarchy","text":"The \"Moment Sum-of-Hermitian-Square Hierarchy\" is a powerful technique for approximating the solution to polynomial optimization problems (Lasserre, 2010). The solution is approximated by a sequence of easier problems. Each problem in the sequence is a semidefinite program, which can be solved efficiently.\n\nThe basic idea is to relax the original problem by considering \"moments\" of the variables. The moments are related to the average values of the powers of the variables. In quantum physics, these moments are related to the expectation values of the powers of the operators. The constraints on the moments can be expressed as semidefinite constraints. By adding more and more moments, we get a tighter and tighter relaxation of the original problem, and the solution to the relaxed problem gets closer and closer to the solution of the original problem.\n\nThis technique has been applied to many problems in quantum information theory, such as calculating the ground state energy of a quantum system or determining whether a quantum state is entangled.","category":"section"},{"location":"manual/sdp_relaxation/#moment-problem","page":"SDP Relaxation","title":"Moment Problem","text":"In physics, the \"moment problem\" is a classic mathematical puzzle that has surprising connections to quantum mechanics. Imagine you have a physical system, like a particle, and you can measure certain properties of that system, like its position or momentum. The results of these measurements will have a certain statistical distribution. The \"moments\" of this distribution are the average values of the powers of the measured quantity. For example, the first moment is the average value, the second moment is related to the variance (how spread out the values are), and so on.\n\nThe moment problem asks the following question: if you know all the moments of a distribution, can you uniquely determine the distribution itself? In other words, if you know all the average values of the powers of a physical quantity, do you know everything there is to know about the probability of measuring a certain value?\n\nIt turns out that the answer is not always yes. There are cases where different distributions can have the same set of moments. This has important implications in quantum mechanics, where the state of a system is described by a wave function, which is related to a probability distribution. The moment problem helps us understand what information is needed to fully characterize a quantum state.","category":"section"},{"location":"manual/sdp_relaxation/#sohs-problem","page":"SDP Relaxation","title":"Sum-of-Hermitian-Square Problem","text":"The \"Sum-of-Hermitian-Square Problem\" is a mathematical problem that arises in quantum information theory and quantum computing. In this context, we are often interested in optimizing certain quantities that are described by polynomials in non-commuting variables. These variables represent physical observables that do not commute with each other, like position and momentum in quantum mechanics.\n\nA key question is to determine whether a given polynomial is always non-negative. One way to prove that a polynomial is non-negative is to show that it can be written as a sum of squares of other polynomials. In the case of non-commuting variables, we consider sums of \"Hermitian squares\". A Hermitian square is a product of a polynomial and its \"Hermitian conjugate\", which is a generalization of the complex conjugate for matrices.\n\nThe paper Sums of hermitian squares and the BMV conjecture by Igor Klep and Markus Schweighofer, explores the connection between this problem and the Bessis-Moussa-Villani (BMV) conjecture, a famous open problem in mathematical physics. The authors use techniques from semidefinite programming to make progress on this conjecture.","category":"section"},{"location":"quick_start/#quick-start","page":"Quick Start","title":"Quick Start","text":"The non-commutative Broyden banded function is a generalization of the classical Broyden banded function to non-commuting variables. It is often used in optimization and numerical analysis to test the performance of algorithms. We will use it as an example.\n\nThe function is defined as:\n\nf(x_1 dots x_n) = sum_i=1^n f_i(x_1 dots x_n)^2\n\nwhere\n\nf_i(x_1 dots x_n) = 2x_i + 5x_i^3 + 1 - sum_j in J_i (x_j + x_j^2)\n\nwith\n\nJ_i = j  j neq i max(1 i-5) leq j leq min(n i+1)\n\nThe variables x_i are non-commuting. You may think of them as matrices or operators that is assigned with a representation. It's possible to put constraints on the variables in the form of polynomial inequalities. For example, we may require:\n\n1 - x_i^2 geq 0 quad textand quad x_i - frac13 geq 0 quad forall i in 1n","category":"section"},{"location":"quick_start/#Setting-Up-the-Problem","page":"Quick Start","title":"Setting Up the Problem","text":"First, create non-commutative variables using create_noncommutative_variables. Then use NCTSSoS.polyopt to define the optimization problem with inequality constraints.\n\nusing NCTSSoS, MosekTools\n\nfunction broyden_banded(n::Int)\n    # Create non-commutative variables\n    registry, (x,) = create_noncommutative_variables([(\"x\", 1:n)])\n\n    # Build the objective function using sum\n    f = sum(1:n) do i\n        jset = setdiff(max(1, i-5):min(n, i+1), i)\n        g = isempty(jset) ? 0.0 * x[1] : sum(x[j] + x[j]^2 for j in jset)\n        (2.0*x[i] + 5.0*x[i]^3 + 1 - g)^2\n    end\n\n    # Define inequality constraints\n    ineq_cons = [[1.0 - x[i]^2 for i in 1:n]; [x[i] - 1//3 for i in 1:n]]\n\n    return polyopt(f, registry; ineq_constraints=ineq_cons)\nend\n\npop = broyden_banded(6)\n\nThe create_noncommutative_variables function returns a registry and variable arrays. All algebraic constraints are automatically encoded through the type system.\n\nPolynomial Optimization is NP-hard, therefore it is considered impossible to solve them efficiently in general. However, it is possible to relax the problem into Semidefinite Programming. The solution of the Semidefinite program will be the lower/upper bound of the original minimization/maximization polynomial optimziation problem.\n\nThe relaxation can be done in two different forms, moment relaxation and sum of hermitian square relaxation. The relaxation is tight in the limit of a parameter, moment order, reaching infinity. However, you may get lucky and be able to sovle the problem at finite moment order.\n\nInformation about the relaxation is encoded in NCTSSoS.SolverConfig. Besides moment order, it also needs to be provided with a SDP Solver. Different optimizers may have different performance characteristics and may be more or less suitable for a given problem.\n\nsolver_config = SolverConfig(optimizer=Mosek.Optimizer, order=3)","category":"section"},{"location":"quick_start/#Solving-the-Problem","page":"Quick Start","title":"Solving the Problem","text":"Finally, we are ready to solve this problem using NCTSSoS.cs_nctssos.\n\nresult = cs_nctssos(pop, solver_config)\n# Objective: ~2.979657977586228\n\nAlthough we have reached a tight bound, time to solve the problem can still be significant. As a remedy, Sparsities can be utilized to reduce the problem size. This is achieved by supplying an EliminationAlgorithm to NCTSSoS.SolverConfig.\n\nsolver_config = SolverConfig(optimizer=Mosek.Optimizer, order=3, cs_algo=MF(), ts_algo=MMD())\n\nresult_sparse = cs_nctssos(pop, solver_config)\n# Objective: ~2.979657981888441\n\nAs expected, the time taken to solve the problem is significantly reduced. However, the result may no longer be a tight lower bound since sparsity is itself a kind of relaxation. Luckily, we can tighten the relaxation in the Term Sparsity sense using NCTSSoS.cs_nctssos_higher.\n\nresult_higher = cs_nctssos_higher(pop, result_sparse, solver_config)\n# Objective: ~2.9796579998271047","category":"section"},{"location":"quick_start/#Workflow","page":"Quick Start","title":"Workflow","text":"To summarize, the workflow for solving polynomial optimization can be summarized as\n\n(Image: `Workflow for solving Polynomial Optimization problem`)\n\nIf you would like to understand more please refer to examples section in the document.","category":"section"},{"location":"manual/optimizers/#overview-of-optimizers","page":"Optimizers","title":"Overview of Optimizer","text":"A brief overview of different Semideinite Program optimizers are provided below.","category":"section"},{"location":"manual/optimizers/#mosek","page":"Optimizers","title":"Mosek","text":"Mosek (ApS, 2025) is a high-performance commercial solver for convex optimization problems, including linear, conic, and semidefinite programming. It is known for its speed and reliability, making it a popular choice for academic and industrial applications. While it is a closed-source product, it offers free licenses for academic use.\n\nusing MosekTools\nSolverConfig(optimizer=Mosek.Optimizer) # using Mosek as the optimizer","category":"section"},{"location":"manual/optimizers/#clarabel","page":"Optimizers","title":"Clarabel","text":"Clarabel (Goulart and Chen, 2024) is a modern, open-source interior-point solver for convex optimization. It is written in Rust and Julia and is designed to be fast, reliable, and easy to use. It has a growing community of users and developers and is a promising alternative to commercial solvers like Mosek. For performance, you may need to install closed-source linear system solvers.\n\nusing Clarabel\nSolverConfig(optimizer=Clarabel.Optimizer) # using Clarabel as the optimizer","category":"section"},{"location":"manual/optimizers/#cosmo","page":"Optimizers","title":"COSMO","text":"COSMO (Garstka et al., 2021) (Conic Operator Splitting Method) is a first-order solver for convex conic optimization problems. It is based on the alternating direction method of multipliers (ADMM) and is designed to be fast and scalable, especially for large-scale problems. However, it may not be as accurate as interior-point methods like Mosek and Clarabel.\n\nusing COSMO\nSolverConfig(optimizer=COSMO.Optimizer) # using COSMO as the optimizer","category":"section"},{"location":"examples/generated/ground_state_energy/#Obtaining-Ground-State-Energy-Lower-Bound","page":"Ground State Energy","title":"Obtaining Ground State Energy Lower Bound","text":"Finding the ground state of a quantum system is a fundamental problem in quantum mechanics (Wang et al., 2024). Variational methods are commonly used to approximate the ground state. Due to the variational nature of these methods, only an upper bound can be obtained (Kull et al., 2024). Polynomial optimization techniques provides a way to find the lower bound of the ground state energy.\n\nIn general, we consider the following Hamiltonian:\n\nH = frac14 sum_i u003c j J_ij sum_ a in xyz sigma_i^a sigma_j^a","category":"section"},{"location":"examples/generated/ground_state_energy/#1D-Heisenberg-Model-with-Nearest-Neighbor-Interaction","page":"Ground State Energy","title":"1D Heisenberg Model with Nearest Neighbor Interaction","text":"Firstly, let's consider the simplest case of 1D Heisenberg chain with nearest neighbor interaction and periodic boundary condition.\n\nusing NCTSSoS, MosekTools\nN = 6\n\nCreate Pauli variables using the typed algebra system This automatically encodes all Pauli commutation relations\n\nregistry, (œÉx, œÉy, œÉz) = create_pauli_variables(1:N)\n\nham = sum(ComplexF64(1 / 4) * op[i] * op[mod1(i + 1, N)] for op in [œÉx, œÉy, œÉz] for i in 1:N)\n\nNo need to manually specify constraints - they're encoded in the algebra type!\n\npop = polyopt(ham, registry)\n\nsolver_config = SolverConfig(\n                    optimizer=Mosek.Optimizer,          # the solver backend\n                    order=2,                            # moment matrix order\n                    ts_algo = MMD(),                    # term sparsity algorithm\n                    )\n\nres = cs_nctssos(pop, solver_config)\n\nres = cs_nctssos_higher(\n            pop,                                        # Polynomial Optimization Problem\n            res,                                        # Solution of First Order Term Sparsity Iteration\n            solver_config                               # Solver Configuration\n        )\nres.objective / N\n\nThe returned result matches the actual ground state energy -0467129 to 6 digits. (Wang et al., 2024)","category":"section"},{"location":"examples/generated/ground_state_energy/#1D-Heisenberg-Model-with-next-nearest-neighbor-interaction","page":"Ground State Energy","title":"1D Heisenberg Model with next nearest neighbor interaction","text":"Polynomial Optimization framework is quite general. Almost no modification is required to handle more complex Hamiltonian. 1D Heisenberg Model with geometric frustration induced by next nearest neighbor interaction can be solved as:\n\nusing NCTSSoS, MosekTools\nN = 6\nJ1 = 1.0                            # Nearest Neighbor Interaction\nJ2 = 0.2                            # Next Nearest Neighbor Interaction\n\nregistry, (œÉx, œÉy, œÉz) = create_pauli_variables(1:N)\n\nham = sum(ComplexF64(J1 / 4) * op[i] * op[mod1(i + 1, N)] + ComplexF64(J2 / 4) * op[i] * op[mod1(i + 2, N)] for op in [œÉx, œÉy, œÉz] for i in 1:N)\n\npop = polyopt(ham, registry)\n\nsolver_config = SolverConfig(optimizer=Mosek.Optimizer, order=2, ts_algo = MMD())\n\nres = cs_nctssos(pop, solver_config)\n\nres = cs_nctssos_higher(pop, res, solver_config)\nres.objective / N\n\nWe are able to obtain the ground state energy of -04270083225302217, accurate to 6 digits!","category":"section"},{"location":"examples/generated/ground_state_energy/#2D-Square-Lattice","page":"Ground State Energy","title":"2D Square Lattice","text":"Extending Heisenberg model to 2-D case is also straightforward. However NCTSSoS.jl is not efficient enough to handle system at this size.\n\nusing NCTSSoS, MosekTools\nNx = 3\nNy = 3\nN = Nx * Ny\nJ1 = 1.0\nJ2 = 0.0\n\nregistry, (œÉx, œÉy, œÉz) = create_pauli_variables(1:N)\n\nLI = LinearIndices((1:Nx, 1:Ny))\n\nham = sum(ComplexF64(J1 / 4) * op[LI[CartesianIndex(i, j)]] * op[LI[CartesianIndex(i, mod1(j + 1, Ny))]] + ComplexF64(J1 / 4) * op[LI[CartesianIndex(i, j)]] * op[LI[CartesianIndex(mod1(i + 1, Nx), j)]] + ComplexF64(J2 / 4) * op[LI[CartesianIndex(i, j)]] * op[LI[CartesianIndex(mod1(i + 1, Nx), mod1(j + 1, Ny))]] + ComplexF64(J2 / 4) * op[LI[CartesianIndex(i, j)]] * op[LI[CartesianIndex(mod1(i + 1, Nx), mod1(j - 1, Ny))]] for op in [œÉx, œÉy, œÉz] for i in 1:Nx for j in 1:Ny)\n\npop = polyopt(ham, registry)\n\nsolver_config = SolverConfig(optimizer=Mosek.Optimizer, order=3, cs_algo=MF(), ts_algo=MMD())","category":"section"},{"location":"examples/generated/ground_state_energy/#Next-step","page":"Ground State Energy","title":"Next step","text":"With such lower bounds, estimates of properties of the ground state, correlations functions, structure factors and order parameters, can also be obtained. We provide examples in another section.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/generated/certify_ground_state_property/#Certifying-Ground-State-Properties","page":"Certifying Ground State Property","title":"Certifying Ground State Properties","text":"Understanding ground-state properties of quantum many-body systems represents a fundamental challenge in quantum physics (Wang et al., 2024). These properties reveal the low-energy phases and quantum correlations that characterize complex quantum systems. However, computing them exactly becomes intractable for large systems due to the exponential growth of the Hilbert space dimension with particle number.\n\nWhile exact diagonalization provides precise results for small systems, it quickly becomes computationally prohibitive. Instead, we can obtain rigorous bounds on ground-state properties by combining:\n\nUpper bounds from variational methods (or exact diagonalization for small systems)\nLower bounds from semidefinite programming (SDP) relaxations\n\nThis approach provides certified intervals that guarantee the true ground-state property lies within computable bounds.\n\nAs a demonstration, we consider the quantum Heisenberg model:\n\nhatH = J sum_j=1^Nsigma^z_j sigma^z_j+1 + h sum_j=1^N sigma^x_j\n\nwhere we will certify both the ground-state energy and correlation functions.\n\nusing Yao\nusing LinearAlgebra\n\n# System parameters for exact diagonalization\nN = 3                    # Number of spins in the chain\nJ = 1.0                  # Coupling strength for Z-Z interactions\n\n# Arrays to store results across different magnetic field strengths\nground_state_energy_upper_bounds = Float64[]  # Energy per site\ns1s2values = Float64[]                        # S^z_1 * S^z_2 correlation\n\n# Loop over different transverse field strengths\nfor h in 0.1:0.2:2.0\n    # Construct the Heisenberg Hamiltonian with transverse field\n    # H = J/4 * Œ£ Z_i Z_{i+1} + h/2 * Œ£ X_i\n    ham = sum(J / 4 * kron(N, i => Z, mod1(i + 1, N) => Z) for i in 1:N) +\n          sum(h / 2 * put(N, i => X) for i in 1:N)\n\n    # Diagonalize the Hamiltonian to find eigenvalues and eigenvectors\n    evals, eigves = eigen(Matrix(ham))\n\n    # Calculate S^z_1 * S^z_2 correlation operator\n    s1s2 = Matrix(kron(N, 1 => Z, 2 => Z)) / 4\n\n    # Store ground state energy per site\n    push!(ground_state_energy_upper_bounds, minimum(real(evals)) / N)\n\n    # Calculate and store S^z_1 * S^z_2 expectation value in ground state\n    ground_state_idx = argmin(real(evals))\n    ground_state = eigves[:, ground_state_idx]\n    push!(s1s2values, real(ground_state' * s1s2 * ground_state))\nend","category":"section"},{"location":"examples/generated/certify_ground_state_property/#Computing-Lower-Bounds-with-Semidefinite-Programming","page":"Certifying Ground State Property","title":"Computing Lower Bounds with Semidefinite Programming","text":"Now we obtain rigorous lower bounds on the ground-state energy using NCTSSoS.jl. This approach formulates the quantum ground-state problem as a polynomial optimization problem and solves its semidefinite programming relaxation, providing certified lower bounds.\n\nThe NCTSSoS API provides type-safe Pauli algebra with automatic simplification. No explicit commutation constraints are needed - the PauliAlgebra type handles the Pauli operator relations automatically.\n\nusing NCTSSoS\nusing MosekTools\nusing JuMP\n\n# Configure Mosek solver with high precision settings\nSOLVER = optimizer_with_attributes(Mosek.Optimizer,\n    \"MSK_DPAR_INTPNT_CO_TOL_PFEAS\" => 1e-8,  # Primal feasibility tolerance\n    \"MSK_DPAR_INTPNT_CO_TOL_DFEAS\" => 1e-8,  # Dual feasibility tolerance\n    \"MSK_DPAR_INTPNT_CO_TOL_REL_GAP\" => 1e-8,  # Relative gap tolerance\n    \"MSK_IPAR_NUM_THREADS\" => 0)            # Use all available threads\n\n# Initialize array to store energy lower bounds\nground_state_energy_lower_bounds = Float64[]\n\n# System parameters (matching the exact diagonalization setup)\nN = 3                    # Number of spins\nT1 = ComplexF64          # Complex number type for calculations\nJ = 1.0                  # Coupling strength\n\n# Loop over the same magnetic field values as before\nfor (i, h) in enumerate(0.1:0.2:2.0)\n    # Create Pauli algebra variables\n    # PauliAlgebra automatically handles:\n    #   - œÉ¬≤ = I (unipotent property)\n    #   - Cyclic product rules: œÉx¬∑œÉy = iœÉz, œÉy¬∑œÉz = iœÉx, œÉz¬∑œÉx = iœÉy\n    #   - Commutation relations between different sites\n    registry, (x, y, z) = create_pauli_variables(1:N)  # x = œÉx, y = œÉy, z = œÉz\n\n    # Objective function: we want to minimize the Hamiltonian\n    # H = J/4 * Œ£ z_i z_{i+1} + h/2 * Œ£ x_i\n    ham = sum(T1(J / 4) * z[i] * z[mod1(i + 1, N)] + T1(h / 2) * x[i] for i in 1:N)\n\n    # Create polynomial optimization problem\n    # No explicit algebra constraints needed - PauliAlgebra handles them automatically\n    pop = polyopt(ham, registry)\n\n    # Configure solver with second-order moment relaxation\n    solver_config = SolverConfig(optimizer=SOLVER, order=2)\n\n    # Solve the semidefinite program to get energy lower bound\n    res = cs_nctssos(pop, solver_config)\n\n    # Store energy per site (divide by system size)\n    push!(ground_state_energy_lower_bounds, res.objective / N)\nend","category":"section"},{"location":"examples/generated/certify_ground_state_property/#Bounding-Ground-State-Correlation-Functions","page":"Certifying Ground State Property","title":"Bounding Ground-State Correlation Functions","text":"Beyond energy bounds, we can rigorously bound other ground-state properties such as correlation functions. Here we demonstrate bounding the expectation value of the two-point correlation function S^z_1S^z_2.\n\nTo accomplish this, we need a custom solver that can handle additional constraints on correlation functions. The following function extends the standard NCTSSoS solver to incorporate entry constraints.\n\n\"\"\"\n    cs_nctssos_with_entry(pop, solver_config, entry_constraints; dualize=true)\n\nExtended NCTSSoS solver that incorporates additional entry constraints\nfor bounding specific correlation functions in quantum systems.\n\nThis function builds the moment matrix relaxation with sparsity patterns\nand adds semidefinite constraints to bound specific operator expectations.\n\"\"\"\nfunction cs_nctssos_with_entry(\n    pop::OP,\n    solver_config::SolverConfig,\n    entry_constraints::Vector{P};\n    dualize::Bool=true\n) where {A<:AlgebraType, T<:Integer, C<:Number, P<:Polynomial{A,T,C}, OP<:NCTSSoS.OptimizationProblem{P}}\n\n   # Compute sparsity structure (correlative + term sparsity)\n   sparsity = NCTSSoS.compute_sparsity(pop, solver_config)\n\n   # Build the moment relaxation problem\n   moment_problem = NCTSSoS.moment_relax(pop, sparsity.corr_sparsity, sparsity.cliques_term_sparsities)\n\n   # Add entry constraints for correlation function bounds\n   # These are semidefinite constraints that ensure physical validity\n   for c in entry_constraints\n       push!(moment_problem.constraints,(:HPSD, [c;;]))\n   end\n\n   # Dualize and solve (using the same solve_sdp helper as cs_nctssos)\n   result = NCTSSoS.solve_sdp(moment_problem, solver_config.optimizer; dualize)\n\n   # Return optimization results\n   return NCTSSoS.PolyOptResult(result.objective, sparsity, result.model, result.n_unique_elements)\nend","category":"section"},{"location":"examples/generated/certify_ground_state_property/#Computing-Rigorous-Bounds-on-Correlation-Functions","page":"Certifying Ground State Property","title":"Computing Rigorous Bounds on Correlation Functions","text":"Now we demonstrate the main result: computing rigorous upper and lower bounds on the two-point correlation function langle S^z_1 S^z_2 rangle. This showcases how polynomial optimization can certify physical properties beyond just the ground-state energy.\n\nWe use reference energy bounds (computed via high-precision DMRG) to constrain the optimization problem, ensuring our correlation function bounds are physically meaningful.\n\n# Initialize arrays to store correlation function bounds\nlower_bounds = Float64[]\nupper_bounds = Float64[]\n\n# System parameters\nJ = 1.0  # Coupling strength (same as before)\n\n# Loop over magnetic field values\nfor (i, h) in enumerate(0.1:0.2:2.0)\n    # Create Pauli algebra variables\n    registry, (x, y, z) = create_pauli_variables(1:N)\n\n    # Objective function: S^z_1 * S^z_2 correlation\n    obj = one(T1) * z[1] * z[2]\n\n    # Hamiltonian (same form as before)\n    ham = sum(T1(J / 4) * z[j] * z[mod1(j + 1, N)] + T1(h / 2) * x[j] for j in 1:N)\n\n    # Energy constraint: ensure ground state energy is within reference bounds\n    # This is crucial for obtaining physically meaningful correlation bounds\n    ineq_cons = [ham - ground_state_energy_lower_bounds[i] * N]\n\n    # Create optimization problems for lower and upper bounds\n    # We solve two separate problems: minimize and maximize the correlation\n    pop_l = polyopt(obj, registry; ineq_constraints=ineq_cons)\n    pop_u = polyopt(-obj, registry; ineq_constraints=ineq_cons)\n\n    # Configure solver\n    solver_config = SolverConfig(optimizer=SOLVER, order=2)\n\n    # Additional energy constraint for the upper bound problem\n    single_ineq_cons = [ground_state_energy_upper_bounds[i] * N - ham]\n\n    # Solve for lower and upper bounds on correlation function\n    res_l = cs_nctssos_with_entry(pop_l, solver_config, single_ineq_cons; dualize=true)\n    res_u = cs_nctssos_with_entry(pop_u, solver_config, single_ineq_cons; dualize=true)\n\n    # Store bounds (divide by 4 to convert from Pauli to spin operators)\n    push!(lower_bounds, res_l.objective / 4)\n    push!(upper_bounds, -res_u.objective / 4)\nend","category":"section"},{"location":"examples/generated/certify_ground_state_property/#Visualizing-Certified-Correlation-Function-Bounds","page":"Certifying Ground State Property","title":"Visualizing Certified Correlation Function Bounds","text":"Finally, we visualize our results to demonstrate the tightness of the certified bounds. The polynomial optimization approach provides rigorous upper and lower bounds that closely bracket the exact correlation function values, validating the effectiveness of our certification method.\n\nusing CairoMakie\n\n# Create the visualization\nf = Figure(size=(800, 600))\nax = Axis(f[1, 1],\n    xlabel=\"Transverse Field Strength (h)\",\n    ylabel=L\"\\langle S^z_1 S^z_2 \\rangle\",\n    title=\"Certified Bounds on Ground-State Correlation Function\")\n\n# Magnetic field values for plotting\nxs = collect(0.1:0.2:2.0)\n\n# Plot the certified bounds\nscatterlines!(ax, xs, upper_bounds, color=:red, label=\"Upper Bound (SDP)\", linewidth=2, markersize=8)\nscatterlines!(ax, xs, lower_bounds, color=:green, label=\"Lower Bound (SDP)\", linewidth=2, markersize=8)\nscatterlines!(ax, xs, s1s2values, color=:blue, label=\"Exact Value (ED)\", linewidth=2, markersize=8)\n\n# Customize the plot\naxislegend(ax, position=:rt)\nax.xgridvisible = true\nax.ygridvisible = true\nax.xgridwidth = 0.5\nax.ygridwidth = 0.5\nax.xgridcolor = (:gray, 0.2)\nax.ygridcolor = (:gray, 0.2)\n\nf","category":"section"},{"location":"examples/generated/certify_ground_state_property/#Summary","page":"Certifying Ground State Property","title":"Summary","text":"This example demonstrates how polynomial optimization provides rigorous certified bounds on quantum ground-state properties. Key insights:\n\nTight bounds: The semidefinite programming relaxations yield bounds that closely bracket the exact values, providing high-precision certification.\nGeneral method: The approach works for any polynomial Hamiltonian and can bound arbitrary correlation functions, not just energies.\nScalability: By exploiting sparsity patterns (correlative and term sparsity), we can handle larger quantum systems efficiently.\nPhysical constraints: Energy bounds ensure physically meaningful correlation function bounds, preventing unphysical results.\nType-safe algebra: The PauliAlgebra type automatically handles Pauli operator relations (œÉ¬≤ = I, commutation rules) without requiring explicit constraints.\n\nThis certification methodology is particularly valuable for quantum many-body systems where exact solutions are unavailable, providing guaranteed error bars on computed properties.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"reference/","page":"References","title":"References","text":"ApS,¬†M. (2025). The MOSEK Python Fusion API manual. Version 11.0.\n\n\n\nBurgdorf,¬†S.; Klep,¬†I. and Povh,¬†J. (2016). Optimization of Polynomials in Non-Commuting Variables. SpringerBriefs in Mathematics (Springer International Publishing, Cham). Accessed on Dec 1, 2024.\n\n\n\nGarstka,¬†M.; Cannon,¬†M. and Goulart,¬†P. (2021). COSMO: A Conic Operator Splitting Method for Convex Conic Problems. Journal¬†of¬†Optimization¬†Theory¬†and¬†Applications 190, 779‚Äì810.\n\n\n\nGoulart,¬†P.¬†J. and Chen,¬†Y. (2024). Clarabel: An interior-point solver for conic programs with quadratic objectives, arXiv:2405.12762 [math.OC].\n\n\n\nKlep,¬†I.; Magron,¬†V. and Volcic,¬†J. (2022). Optimization over Trace Polynomials. Annales¬†Henri¬†Poincar√© 23, 67‚Äì100, arXiv:2006.12510 [math-ph]. Accessed on Mar 25, 2025.\n\n\n\nKlep,¬†I.; Magron,¬†V.; Volcic,¬†J. and Wang,¬†J. (2024). State Polynomials: Positivity, Optimization and Nonlinear Bell Inequalities. Mathematical¬†Programming 207, 645‚Äì691, arXiv:2301.12513 [math]. Accessed on Jan 16, 2025.\n\n\n\nKull,¬†I.; Schuch,¬†N.; Dive,¬†B. and Navascu√©s,¬†M. (2024). Lower Bounds on Ground-State Energies of Local Hamiltonians through the Renormalization Group. Physical¬†Review¬†X 14, 021008. Accessed on May 14, 2024.\n\n\n\nLasserre,¬†J.-B. (2010). Moments, Positive Polynomials and Their Applications. V. 1 of Imperial College Press Optimization Series (Imperial College Press ; Distributed by World Scientific Publishing Co, London : Signapore ; Hackensack, NJ).\n\n\n\nMagron,¬†V. and Wang,¬†J. (2023). Sparse Polynomial Optimization: Theory and Practice. Vol. 5 of Series on Optimization and Its Applications (World Scientific Publishing Europe Ltd, London).\n\n\n\nNavascu√©s,¬†M.; Pironio,¬†S. and Ac√≠n,¬†A. (2007). Bounding the set of quantum correlations. Physical¬†Review¬†Letters 98, 010401.\n\n\n\nNavascu√©s,¬†M.; Pironio,¬†S. and Ac√≠n,¬†A. (2008). A convergent hierarchy of semidefinite programs characterizing the set of quantum correlations. New¬†Journal¬†of¬†Physics 10, 073013.\n\n\n\nNielsen,¬†M.¬†A. and Chuang,¬†I.¬†L. (2010). Quantum Computation and Quantum Information: 10th Anniversary Edition (Cambridge University Press, Cambridge).\n\n\n\nP√°l,¬†K.¬†F. and V√©rtesi,¬†T. (2010). Maximal violation of a bipartite three-setting, two-outcome Bell inequality using infinite-dimensional quantum systems. Phys.¬†Rev.¬†A 82, 022116.\n\n\n\nPozsgay,¬†V.; Hirsch,¬†F.; Branciard,¬†C. and Brunner,¬†N. (2017). Covariance Bell inequalities. Phys.¬†Rev.¬†A 96, 062128.\n\n\n\nSachdev,¬†S. (2011). Quantum Phase Transitions (Cambridge University Press).\n\n\n\nVandenberghe,¬†L. and Boyd,¬†S. (1996). Semidefinite programming. SIAM¬†review 38, 49‚Äì95.\n\n\n\nWang,¬†J. and Magron,¬†V. (2021). Exploiting Term Sparsity in Noncommutative Polynomial Optimization. Computational¬†Optimization¬†and¬†Applications 80, 483‚Äì521. Accessed on Jan 18, 2025.\n\n\n\nWang,¬†J.; Surace,¬†J.; Fr√©rot,¬†I.; Legat,¬†B.; Renou,¬†M.-O.; Magron,¬†V. and Ac√≠n,¬†A. (2024). Certifying Ground-State Properties of Quantum Many-Body Systems. Physical¬†Review¬†X 14, 031006, arXiv:2310.05844 [quant-ph]. Accessed on Dec 29, 2024.\n\n\n\n","category":"section"},{"location":"manual/monomials/#monomials","page":"Monomials","title":"Monomials and Normal Forms","text":"This page describes the implementation-level design of monomials in NCTSSoS.jl. The goal is:\n\nCanonical representation on construction: algebraically equivalent inputs normalize to an identical representation immediately.\nNo unnecessary allocations: simple monomials store as Vector{T} words.\nType-safe dispatch: algebra type A drives method specialization.","category":"section"},{"location":"manual/monomials/#Core-Types","page":"Monomials","title":"Core Types","text":"","category":"section"},{"location":"manual/monomials/#NormalMonomial{A,T}","page":"Monomials","title":"NormalMonomial{A,T}","text":"NormalMonomial{A,T} represents an immutable word (a product of generators) stored as a Vector{T}:\n\nstruct NormalMonomial{A<:AlgebraType, T<:Integer} <: AbstractMonomial{A,T}\n    word::Vector{T}\nend\n\nInvariant: A NormalMonomial is always in the algebra-specific normal form for A. This is enforced via _validate_word(A, word) (extended by the simplification code in src/simplification/*.jl).\n\nThe create_*_variables functions (e.g., create_pauli_variables, create_fermionic_variables) return NormalMonomial objects directly. When you use these in arithmetic operations (multiplication, addition), they produce Polynomial results.","category":"section"},{"location":"manual/monomials/#Polynomial{A,T,C}","page":"Monomials","title":"Polynomial{A,T,C}","text":"Polynomial{A,T,C} represents a sum of monomials with coefficients:\n\nstruct Polynomial{A<:AlgebraType, T<:Integer, C<:Number} <: AbstractPolynomial{C}\n    terms::Vector{Tuple{C, NormalMonomial{A,T}}}\nend\n\nKey invariants:\n\nterms is sorted by the NormalMonomial ordering\nEach monomial appears at most once (like terms are combined)\nZero coefficients are removed","category":"section"},{"location":"manual/monomials/#Algebra-Categories","page":"Monomials","title":"Algebra Categories","text":"The storage and simplification behavior depends on the algebra category:","category":"section"},{"location":"manual/monomials/#1)-MonoidAlgebra:-single-terms","page":"Monomials","title":"1) MonoidAlgebra: single terms","text":"Algebras where multiplication of monomials yields a single monomial:\n\nNonCommutativeAlgebra (no relations)\nProjectorAlgebra (P¬≤ = P)\nUnipotentAlgebra (U¬≤ = I)\n\nMultiplication returns a Polynomial with exactly one term.","category":"section"},{"location":"manual/monomials/#2)-TwistedGroupAlgebra:-phase-monomial","page":"Monomials","title":"2) TwistedGroupAlgebra: phase √ó monomial","text":"Algebras where multiplication yields a scalar phase times a monomial:\n\nPauliAlgebra (œÉ·µ¢œÉ‚±º = iŒµ·µ¢‚±º‚ÇñœÉ‚Çñ)\n\nPhases are tracked as (im)^k where k ‚àà 0:3.","category":"section"},{"location":"manual/monomials/#3)-PBWAlgebra:-sum-of-monomials","page":"Monomials","title":"3) PBWAlgebra: sum of monomials","text":"Algebras where multiplication can expand into multiple terms:\n\nFermionicAlgebra (anticommutation: a·µ¢a‚±º + a‚±ºa·µ¢ = Œ¥·µ¢‚±º)\nBosonicAlgebra (commutation: [a·µ¢, a‚±º‚Ä†] = Œ¥·µ¢‚±º)\n\nResults require Vector-based storage for multiple terms.","category":"section"},{"location":"manual/monomials/#Simplification","page":"Monomials","title":"Simplification","text":"To ensure immediate canonical forms, the simplification functions:\n\nsimplify(::Type{A}, word::Vector{T}) where {A<:AlgebraType}\n\nBuild an internal NormalMonomial from the raw word, apply algebra-specific rules, and return a Polynomial in canonical form.\n\nThis means:\n\nTwo words that are algebraically equal (under the relations of A) become equal Polynomials right after construction.","category":"section"},{"location":"manual/monomials/#Term-Interface","page":"Monomials","title":"Term Interface","text":"Polynomial exposes a lightweight term API:\n\nterms(p::Polynomial) returns an iterable of (coefficient, NormalMonomial) pairs\nmonomials(p) returns a vector of the monomials\ncoefficients(p) returns a vector of the coefficients\n\nUsage:\n\nfor (coef, mono) in p.terms\n    # coef is the coefficient (Number)\n    # mono is a NormalMonomial{A,T} in canonical word form\nend","category":"section"},{"location":"manual/monomials/#Why-This-Design","page":"Monomials","title":"Why This Design","text":"Julian dispatch: A and T drive method specialization\nPerformance: simple algebra elements stay compact, PBW expands only when mathematically necessary\nErgonomics: consistent zero/one/iszero semantics across all algebras","category":"section"},{"location":"apis/relaxations/#Moment-Relaxation","page":"SDP Relaxation","title":"Moment Relaxation","text":"","category":"section"},{"location":"apis/relaxations/#Sum-of-Squares-Relaxation","page":"SDP Relaxation","title":"Sum-of-Squares Relaxation","text":"","category":"section"},{"location":"apis/relaxations/#NCTSSoS.moment_relax","page":"SDP Relaxation","title":"NCTSSoS.moment_relax","text":"moment_relax(pop::PolyOpt{A,TI,P}, corr_sparsity::CorrelativeSparsity, cliques_term_sparsities::Vector{Vector{TermSparsity{M}}})\n\nConstruct a symbolic moment relaxation of a polynomial optimization problem.\n\nArguments\n\npop::PolyOpt{A,TI,P}: The polynomial optimization problem\ncorr_sparsity::CorrelativeSparsity: Correlative sparsity structure with cliques\ncliques_term_sparsities: Term sparsity for each clique\n\nReturns\n\nMomentProblem{A,T,M,P}: Symbolic moment problem ready for dualization or direct solving\n\nDescription\n\nThis function creates a symbolic representation of the moment relaxation by:\n\nComputing total basis from all clique term sparsities\nBuilding constraint matrices as polynomial-valued matrices\nSelecting cone type based on algebra (PSD for real, HPSD for complex)\n\nThe cone type is automatically determined by _is_complex_problem(A):\n\nReal algebras (NonCommutative, Projector, Unipotent): :PSD cone\nComplex algebras (Pauli, Fermionic, Bosonic): :HPSD cone\n\nExamples\n\n# Build moment relaxation\nmp = moment_relax(pop, corr_sparsity, cliques_term_sparsities)\n\n# Can then dualize or solve directly\nsos = sos_dualize(mp)\n\nSee also: MomentProblem, sos_dualize\n\n\n\n\n\nmoment_relax(pop::PolyOpt, corr_sparsity, cliques_term_sparsities) -> StateMomentProblem\n\nConstruct a symbolic moment relaxation of a state polynomial optimization problem.\n\nArguments\n\npop::PolyOpt{A,TI,P}: The polynomial optimization problem with NCStatePolynomial objective\ncorr_sparsity::CorrelativeSparsity: Correlative sparsity structure\ncliques_term_sparsities: Term sparsity for each clique\n\nReturns\n\nStateMomentProblem{A,ST,T,M,P}: Symbolic state moment problem\n\n\n\n\n\n","category":"function"},{"location":"apis/relaxations/#NCTSSoS.MomentProblem","page":"SDP Relaxation","title":"NCTSSoS.MomentProblem","text":"MomentProblem{A<:AlgebraType, T<:Integer, M<:NormalMonomial{A,T}, P<:Polynomial{A,T}}\n\nA symbolic representation of a moment relaxation problem.\n\nThis unified type handles both real and complex (Hermitian) moment problems. The algebra type A determines which cone type to use when solving:\n\nReal algebras (NonCommutative, Projector, Unipotent): PSD cone\nComplex algebras (Pauli, Fermionic, Bosonic): Hermitian PSD cone\n\nType Parameters\n\nA: Algebra type determining simplification rules and cone type\nT: Integer type for monomial word representation\nM: Monomial type for basis elements (may expand for PBW algebras)\nP: Polynomial type Polynomial{A,T,C} for some coefficient type C\n\nFields\n\nobjective::P: The polynomial objective function\nconstraints::Vector{Tuple{Symbol, Matrix{P}}}: Constraint matrices with cone types\n:Zero - equality constraint (zeros cone)\n:PSD - real positive semidefinite cone\n:HPSD - Hermitian positive semidefinite cone\ntotal_basis::Vector{M}: Union of all basis monomials across constraints\n\nNotes\n\nThis is a purely symbolic representation with no JuMP model. Use solve_moment_problem to instantiate and solve, or sos_dualize to convert to the dual SOS problem.\n\nExamples\n\n# After moment_relax, moment_problem is symbolic:\nmp = moment_relax(pop, corr_sparsity, cliques_term_sparsities)\n\n# Dualize to SOS form and solve\nsos = sos_dualize(mp)\nset_optimizer(sos.model, Clarabel.Optimizer)\noptimize!(sos.model)\n\nSee also: moment_relax, sos_dualize\n\n\n\n\n\n","category":"type"},{"location":"apis/relaxations/#NCTSSoS.sos_dualize","page":"SDP Relaxation","title":"NCTSSoS.sos_dualize","text":"sos_dualize(mp::MomentProblem{A,T,M,P}) where {A,T,M,P} -> SOSProblem\n\nConvert a symbolic moment problem into its dual SOS (Sum of Squares) problem.\n\nArguments\n\nmp::MomentProblem{A,T,M,P}: The symbolic primal moment problem to dualize\n\nReturns\n\nSOSProblem: The dual SOS problem with matrix variables and constraints\n\nDescription\n\nThe dualization process involves:\n\nCreating matrix variables (G_j) for each constraint:\n:Zero constraints -> SymmetricMatrixSpace (equality)\n:PSD constraints -> PSDCone (real positive semidefinite)\n:HPSD constraints -> PSDCone of size 2n x 2n (Hermitian embedding)\nIntroducing scalar variable b to bound the minimum value of the primal\nSetting up polynomial equality constraints by matching coefficients\nReturning the maximization of b\n\nFor complex algebras (Pauli, Fermionic, Bosonic), Hermitian PSD constraints are embedded as real 2n x 2n PSD constraints using the standard construction:\n\nH in HPSD <=> [Re(H), -Im(H); Im(H), Re(H)] in PSD\n\nExamples\n\nmp = moment_relax(pop, corr_sparsity, term_sparsities)\nsos = sos_dualize(mp)\nset_optimizer(sos.model, Clarabel.Optimizer)\noptimize!(sos.model)\nobj = objective_value(sos.model)\n\nSee also: MomentProblem, moment_relax, SOSProblem\n\n\n\n\n\nsos_dualize(mp::StateMomentProblem{A,ST,TI,M,P}) -> SOSProblem\n\nConvert a symbolic state moment problem into its dual SOS problem.\n\nState polynomial optimization problems (with Unipotent, Projector algebras) use real PSD constraints without complex embedding.\n\nArguments\n\nmp::StateMomentProblem: The symbolic state moment problem\n\nReturns\n\nSOSProblem: The dual SOS problem\n\n\n\n\n\n","category":"function"},{"location":"apis/relaxations/#NCTSSoS.SOSProblem","page":"SDP Relaxation","title":"NCTSSoS.SOSProblem","text":"SOSProblem{T}\n\nA Sum of Squares (SOS) optimization problem in JuMP form.\n\nThis is the dual formulation of a moment problem. The SOS problem is typically smaller and faster to solve than the primal moment problem.\n\nType Parameters\n\nT: Coefficient type (Float64 for real problems)\n\nFields\n\nmodel::GenericModel{T}: The JuMP model ready to be optimized\nn_unique_elements::Int: Number of unique moment variables after canonicalization\n\nUsage\n\n# From moment problem\nmp = moment_relax(pop, corr_sparsity, term_sparsities)\nsos = sos_dualize(mp)\n\n# Solve\nset_optimizer(sos.model, Clarabel.Optimizer)\noptimize!(sos.model)\nobj = objective_value(sos.model)\n\nSee also: sos_dualize, MomentProblem\n\n\n\n\n\n","category":"type"},{"location":"examples/generated/pauli_gns_construction/#GNS-Construction-for-Operator-Reconstruction","page":"GNS Construction for Operator Reconstruction","title":"GNS Construction for Operator Reconstruction","text":"The Gelfand-Naimark-Segal (GNS) construction is a fundamental mathematical tool in quantum mechanics that allows us to represent abstract quantum states and operators as concrete matrices acting on a Hilbert space. For physicists, this provides a systematic way to reconstruct operator representations from expectation values (moments).","category":"section"},{"location":"examples/generated/pauli_gns_construction/#Background:-From-Expectation-Values-to-Matrix-Representations","page":"GNS Construction for Operator Reconstruction","title":"Background: From Expectation Values to Matrix Representations","text":"In quantum mechanics, we often know the expectation values of operators in a given state:\n\nlangle A  rangle = textTr(rho A)\n\nwhere rho is the density matrix and A is an operator.\n\nThe GNS construction answers the question: Can we reconstruct the actual matrices representing operators from just these expectation values?\n\nThe key insight is that the collection of all expectation values defines a moment matrix (also called a Hankel matrix in the context of polynomial optimization):\n\nH_ij = langle b_i^dagger b_j rangle\n\nwhere b_i is a basis of operators (monomials in our variables).","category":"section"},{"location":"examples/generated/pauli_gns_construction/#The-reconstruct-Function","page":"GNS Construction for Operator Reconstruction","title":"The reconstruct Function","text":"NCTSSoS provides a reconstruct function that performs GNS construction. Given a moment matrix H and a registry of variables, it returns matrix representations of the variables.\n\nThe function signature is:\n\nreconstruct(H::Matrix, registry::VariableRegistry, degree::Int; atol=1e-3)","category":"section"},{"location":"examples/generated/pauli_gns_construction/#Example:-Simple-Non-Commutative-Variables","page":"GNS Construction for Operator Reconstruction","title":"Example: Simple Non-Commutative Variables","text":"Let's demonstrate with a simple example using two non-commuting variables.\n\nusing NCTSSoS\nusing LinearAlgebra\n\nCreate two non-commutative variables\n\nregistry, (x,) = create_noncommutative_variables([(\"x\", 1:2)])\n\nGenerate a basis of monomials up to degree 2\n\nbasis = get_ncbasis(registry, 2)\nprintln(\"Basis monomials (degree ‚â§ 2): \", length(basis))\n\nFor GNS reconstruction, we need a moment matrix that encodes expectation values of all products of basis elements. The matrix entry H[i,j] = ‚ü®basis[i]‚Ä† ¬∑ basis[j]‚ü©.\n\nHere we'll use a simple positive definite moment matrix as an example:\n\nn = length(basis)\nH = zeros(Float64, n, n)\n\nCreate a simple valid moment matrix (identity-like with some correlations)\n\nfor i in 1:n\n    H[i,i] = 1.0\nend\n\nAdd small off-diagonal terms for correlation structure\n\nH[1,2] = H[2,1] = 0.3\nH[1,3] = H[3,1] = 0.3\nH[2,3] = H[3,2] = 0.2\n\nThe moment matrix should be positive semidefinite\n\n@assert isposdef(Hermitian(H)) \"Moment matrix must be positive definite\"\n\nPerform GNS reconstruction\n\nmatrices = reconstruct(H, registry, 2; atol=0.001)\n\nAccess the reconstructed matrix for each variable\n\nvar_indices = collect(NCTSSoS.indices(registry))\nX1 = matrices[var_indices[1]]\nX2 = matrices[var_indices[2]]\n\nprintln(\"Reconstructed X‚ÇÅ matrix:\")\ndisplay(round.(X1, digits=4))\n\nprintln(\"\\nReconstructed X‚ÇÇ matrix:\")\ndisplay(round.(X2, digits=4))","category":"section"},{"location":"examples/generated/pauli_gns_construction/#Verifying-the-Reconstruction","page":"GNS Construction for Operator Reconstruction","title":"Verifying the Reconstruction","text":"The reconstructed matrices should be consistent with the moment data. Specifically, the GNS construction guarantees that these matrices satisfy the algebraic relations encoded by the algebra type.\n\n@show size(X1)\n@show size(X2)","category":"section"},{"location":"examples/generated/pauli_gns_construction/#Key-Properties-of-GNS-Reconstruction","page":"GNS Construction for Operator Reconstruction","title":"Key Properties of GNS Reconstruction","text":"Unitary Freedom: Reconstructed matrices are unique only up to unitary transformations. Different moment matrices from the same state can yield unitarily equivalent matrices.\nRank Determines Dimension: The rank of the Hankel matrix determines the dimension of the reconstructed Hilbert space. Pure states give lower-rank matrices.\nFlatness Condition: For valid reconstruction, the moment matrix should satisfy the \"flat extension\" property (rank should stabilize at lower degrees).","category":"section"},{"location":"examples/generated/pauli_gns_construction/#Using-GNS-with-Polynomial-Optimization","page":"GNS Construction for Operator Reconstruction","title":"Using GNS with Polynomial Optimization","text":"The primary use of GNS reconstruction in NCTSSoS is to extract optimal solutions from semidefinite programming relaxations. When solving polynomial optimization:\n\nThe SDP relaxation produces a moment matrix as part of its dual solution\nreconstruct extracts matrix representations of variables\nThese matrices can be used to verify or extract the optimal point\n\nSee the optimization examples for practical applications of GNS reconstruction in the context of polynomial optimization over non-commutative variables.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"apis/polynomials/#Fast-Polynomials","page":"Polynomials","title":"Fast Polynomials","text":"","category":"section"},{"location":"apis/polynomials/#Algebra-Types","page":"Polynomials","title":"Algebra Types","text":"","category":"section"},{"location":"apis/polynomials/#Categories","page":"Polynomials","title":"Categories","text":"NCTSSoS.jl groups algebras by the normal form of monomials (i.e. what simplify(m::Monomial) returns):\n\nMonoidAlgebra: normal form stays a single monomial (monoid ring viewpoint). [@monoidRing]\nTwistedGroupAlgebra: normal form is a scalar/phase times a monomial (twisted group algebra). [@twistedGroupAlgebra]\nPBWAlgebra: normal form can expand into a sum of monomials (PBW-type rewriting/normal ordering). [@pbwAlgebraOscar]","category":"section"},{"location":"apis/polynomials/#Variables","page":"Polynomials","title":"Variables","text":"","category":"section"},{"location":"apis/polynomials/#Monomials","page":"Polynomials","title":"Monomials","text":"","category":"section"},{"location":"apis/polynomials/#Polynomials","page":"Polynomials","title":"Polynomials","text":"","category":"section"},{"location":"apis/polynomials/#State-Polynomial","page":"Polynomials","title":"State Polynomial","text":"","category":"section"},{"location":"apis/polynomials/#Simplification-Interface","page":"Polynomials","title":"Simplification Interface","text":"","category":"section"},{"location":"apis/polynomials/#Utilities","page":"Polynomials","title":"Utilities","text":"","category":"section"},{"location":"apis/polynomials/#NCTSSoS.AlgebraType","page":"Polynomials","title":"NCTSSoS.AlgebraType","text":"AlgebraType\n\nAbstract type representing different algebraic structures with their commutation/anticommutation relations.\n\nEach concrete algebra type is a singleton struct that enables multiple dispatch for simplification algorithms.\n\nSubtypes\n\nNonCommutativeAlgebra: Standard non-commutative variables (xy ‚â† yx)\nPauliAlgebra: Pauli spin matrices satisfying œÉ·µ¢¬≤ = I and {œÉ·µ¢, œÉ‚±º} = 2Œ¥·µ¢‚±º\nFermionicAlgebra: Fermionic creation/annihilation operators with {a·µ¢, a‚±º‚Ä†} = Œ¥·µ¢‚±º\nBosonicAlgebra: Bosonic creation/annihilation operators with [c·µ¢, c‚±º‚Ä†] = Œ¥·µ¢‚±º\nProjectorAlgebra: Projector operators satisfying P·µ¢¬≤ = P·µ¢ (idempotent)\nUnipotentAlgebra: Unipotent operators satisfying P¬≤ = I\n\nDesign\n\nSingleton types enable zero-cost dispatch on algebra operations:\n\nsimplify(::Type{PauliAlgebra}, m::NormalMonomial) = ...\n\nExamples\n\njulia> PauliAlgebra()\nPauliAlgebra()\n\njulia> FermionicAlgebra() isa AlgebraType\ntrue\n\n\n\n\n\n","category":"type"},{"location":"apis/polynomials/#NCTSSoS.BosonicAlgebra","page":"Polynomials","title":"NCTSSoS.BosonicAlgebra","text":"BosonicAlgebra <: PBWAlgebra\n\nBosonic creation/annihilation operator algebra.\n\nAlgebraic Rules\n\n[c·µ¢, c‚±º‚Ä†] = Œ¥·µ¢‚±º (commutation: creation-annihilation)\n[c·µ¢, c‚±º] = 0 (commutation: annihilation-annihilation)\n[c·µ¢‚Ä†, c‚±º‚Ä†] = 0 (commutation: creation-creation)\n\nNormal ordering places all creation operators (c‚Ä†) to the LEFT of all annihilation operators (c).\n\nKey difference from fermions: Commutation does not introduce sign changes, but adds correction terms. Simplification may return multiple terms.\n\nVariable Encoding\n\nAnnihilation c·µ¢: positive index i\nCreation c·µ¢‚Ä†: negative index -i\n\nInteger Type\n\nUses signed integer types (sign distinguishes creation/annihilation). Concrete type determined by VariableRegistry.\n\n\n\n\n\n","category":"type"},{"location":"apis/polynomials/#NCTSSoS.FermionicAlgebra","page":"Polynomials","title":"NCTSSoS.FermionicAlgebra","text":"FermionicAlgebra <: PBWAlgebra\n\nFermionic creation/annihilation operator algebra.\n\nAlgebraic Rules\n\n{a·µ¢, a‚±º‚Ä†} = Œ¥·µ¢‚±º (anticommutation: creation-annihilation)\n{a·µ¢, a‚±º} = 0 (anticommutation: annihilation-annihilation)\n{a·µ¢‚Ä†, a‚±º‚Ä†} = 0 (anticommutation: creation-creation)\n\nNormal ordering places all creation operators (a‚Ä†) to the LEFT of all annihilation operators (a).\n\nVariable Encoding\n\nAnnihilation a·µ¢: positive index i\nCreation a·µ¢‚Ä†: negative index -i\n\nInteger Type\n\nUses signed integer types (sign distinguishes creation/annihilation). Concrete type determined by VariableRegistry.\n\n\n\n\n\n","category":"type"},{"location":"apis/polynomials/#NCTSSoS.MonoidAlgebra","page":"Polynomials","title":"NCTSSoS.MonoidAlgebra","text":"MonoidAlgebra <: AlgebraType\n\nAlgebra category where the normal form of a monomial is still a single monomial (i.e. closed on monomials).\n\nThis matches a monoid algebra / monoid ring viewpoint: basis elements are indexed by elements of a monoid, and multiplying basis elements yields another basis element in the same basis (extended linearly to polynomials). [@monoidRing]\n\nIn NCTSSoS.jl, this category includes:\n\nNonCommutativeAlgebra (free/noncommutative words)\nProjectorAlgebra (idempotency P¬≤ = P)\nUnipotentAlgebra (involution U¬≤ = I)\n\n\n\n\n\n","category":"type"},{"location":"apis/polynomials/#NCTSSoS.NonCommutativeAlgebra","page":"Polynomials","title":"NCTSSoS.NonCommutativeAlgebra","text":"NonCommutativeAlgebra <: MonoidAlgebra\n\nGeneric non-commutative algebra used when no specific algebra is specified.\n\nThis algebra is site-aware: operators on different sites commute, while operators on the same site remain non-commutative.\n\nAlgebraic Rules\n\nWithin a site: no simplification rules; operator order is preserved exactly.\nAcross sites: operators commute; the canonical word is stable-sorted by site (stable sort preserves within-site order).\n\nIndex Encoding\n\nVariable indices must be unsigned and include bit-packed site information; see encode_index / decode_site.\n\n\n\n\n\n","category":"type"},{"location":"apis/polynomials/#NCTSSoS.PBWAlgebra","page":"Polynomials","title":"NCTSSoS.PBWAlgebra","text":"PBWAlgebra <: AlgebraType\n\nAlgebra category where the normal form of a monomial expands to a sum of monomials.\n\nThis matches the computational noncommutative algebra pattern of PBW algebras: there is an ordered monomial basis and a rewriting/normal-ordering procedure, but reordering introduces lower terms, so a product may expand into multiple normal-form monomials. [@pbwAlgebraOscar]\n\nIn NCTSSoS.jl, this category includes:\n\nFermionicAlgebra (CAR / anticommutation)\nBosonicAlgebra (CCR / commutation)\n\n\n\n\n\n","category":"type"},{"location":"apis/polynomials/#NCTSSoS.PauliAlgebra","page":"Polynomials","title":"NCTSSoS.PauliAlgebra","text":"PauliAlgebra <: TwistedGroupAlgebra\n\nPauli spin matrix algebra.\n\nAlgebraic Rules\n\nœÉ·µ¢¬≤ = I (involution: squares to identity)\n{œÉ·µ¢, œÉ‚±º} = 2Œ¥·µ¢‚±º (anticommutation)\nœÉ‚Çì œÉ·µß = i œÉ·µ§, œÉ·µß œÉ·µ§ = i œÉ‚Çì, œÉ·µ§ œÉ‚Çì = i œÉ·µß (cyclic products)\nOperators on different sites commute\n\nVariable Encoding\n\nVariables are ordered by site first: œÉx‚ÇÅ, œÉy‚ÇÅ, œÉz‚ÇÅ, œÉx‚ÇÇ, œÉy‚ÇÇ, œÉz‚ÇÇ, ... For index idx: site = (idx - 1) √∑ 3 + 1, pauli_type = (idx - 1) % 3 (0=X, 1=Y, 2=Z)\n\nInteger Type\n\nTypically uses unsigned integer types (self-adjoint operators). Concrete type determined by VariableRegistry.\n\n\n\n\n\n","category":"type"},{"location":"apis/polynomials/#NCTSSoS.ProjectorAlgebra","page":"Polynomials","title":"NCTSSoS.ProjectorAlgebra","text":"ProjectorAlgebra <: MonoidAlgebra\n\nProjector operator algebra.\n\nAlgebraic Rules\n\nP·µ¢¬≤ = P·µ¢ (idempotency: projectors square to themselves)\nCommutativity NOT enforced (treat as non-commutative)\n\nVariable Naming\n\nVariables use symbols P‚ÇÅ, P‚ÇÇ, P‚ÇÉ, ... Projectors are self-adjoint.\n\nInteger Type\n\nTypically uses unsigned integer types (self-adjoint operators). Concrete type determined by VariableRegistry.\n\n\n\n\n\n","category":"type"},{"location":"apis/polynomials/#NCTSSoS.TwistedGroupAlgebra","page":"Polynomials","title":"NCTSSoS.TwistedGroupAlgebra","text":"TwistedGroupAlgebra <: AlgebraType\n\nAlgebra category where the normal form of a monomial is a scalar/phase times a single monomial.\n\nThis matches a twisted group algebra viewpoint: basis elements are indexed by a group, but multiplication is twisted by a scalar 2-cocycle, so products satisfy u_g * u_h = Œ±(g,h) u_{gh}. [@twistedGroupAlgebra]\n\nIn NCTSSoS.jl, this category includes:\n\nPauliAlgebra (Pauli products generate phases {¬±1, ¬±i})\n\n\n\n\n\n","category":"type"},{"location":"apis/polynomials/#NCTSSoS.UnipotentAlgebra","page":"Polynomials","title":"NCTSSoS.UnipotentAlgebra","text":"UnipotentAlgebra <: MonoidAlgebra\n\nUnipotent operator algebra.\n\nAlgebraic Rules\n\nP¬≤ = I (squares to identity)\nNo cyclic products or cross-operator interactions\n\nNote: This is simpler than Pauli algebra which also has cyclic product rules. Unipotent only removes consecutive pairs.\n\nInteger Type\n\nTypically uses unsigned integer types (self-adjoint operators). Concrete type determined by VariableRegistry.\n\n\n\n\n\n","category":"type"},{"location":"apis/polynomials/#NCTSSoS.coeff_type-Tuple{Type{<:AlgebraType}}","page":"Polynomials","title":"NCTSSoS.coeff_type","text":"coeff_type(::Type{A}) where {A<:AlgebraType} -> Type{<:Number}\n\nReturn the default coefficient type for a given algebra type.\n\nDifferent algebras naturally work with different coefficient types:\n\nPauliAlgebra: ComplexF64 (Pauli products generate complex phases)\nAll others: Float64 (real coefficients suffice)\n\nThis is used by constructors like Polynomial(m::NormalMonomial) to infer the appropriate coefficient type when not explicitly specified.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> coeff_type(PauliAlgebra)\nComplexF64\n\njulia> coeff_type(NonCommutativeAlgebra)\nFloat64\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.decode_operator_id-Tuple{T} where T<:Unsigned","page":"Polynomials","title":"NCTSSoS.decode_operator_id","text":"decode_operator_id(idx::T) where {T<:Unsigned} -> Int\n\nExtract operator ID from encoded index.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.decode_site-Tuple{T} where T<:Unsigned","page":"Polynomials","title":"NCTSSoS.decode_site","text":"decode_site(idx::T) where {T<:Unsigned} -> Int\n\nExtract site from encoded index (1-indexed).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.encode_index-Union{Tuple{T}, Tuple{Type{T}, Integer, Integer}} where T<:Unsigned","page":"Polynomials","title":"NCTSSoS.encode_index","text":"encode_index(::Type{T}, operator_id::Int, site::Int) where {T<:Unsigned} -> T\n\nEncode operator_id and site into a single index of type T. Site is 1-indexed and stored directly in the lower bits.\n\nArguments\n\nT: The unsigned integer type to use for encoding\noperator_id: Operator identifier (1-indexed, must be ‚â§ max_operators(T))\nsite: Physical site (1-indexed, must be ‚â§ max_sites(T))\n\nExamples\n\nidx = encode_index(UInt16, 1, 3)  # 0x0013 (operator 1, site 3)\ndecode_site(idx)                   # 3\ndecode_operator_id(idx)            # 1\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.max_operators-Union{Tuple{Type{T}}, Tuple{T}} where T<:Unsigned","page":"Polynomials","title":"NCTSSoS.max_operators","text":"max_operators(::Type{T}) where {T<:Unsigned} -> Int\n\nMaximum number of operators per site supported by unsigned type T. Since operator IDs are 1-indexed, the maximum is 2^(n-k) - 1 where n is bit width and k is site bits.\n\nExamples\n\nmax_operators(UInt16)  # 4095\nmax_operators(UInt32)  # 16777215\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.max_sites-Union{Tuple{Type{T}}, Tuple{T}} where T<:Unsigned","page":"Polynomials","title":"NCTSSoS.max_sites","text":"max_sites(::Type{T}) where {T<:Unsigned} -> Int\n\nMaximum number of sites supported by unsigned type T. Since sites are 1-indexed and stored directly, max is 2^k - 1 where k is site_bits.\n\nExamples\n\nmax_sites(UInt8)   # 3 (2 bits can store 1,2,3)\nmax_sites(UInt16)  # 15 (4 bits can store 1-15)\nmax_sites(UInt32)  # 255 (8 bits can store 1-255)\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.select_uint_type-Tuple{Integer, Integer}","page":"Polynomials","title":"NCTSSoS.select_uint_type","text":"select_uint_type(n_operators::Integer, n_sites::Integer) -> Type{<:Unsigned}\n\nSelect the smallest unsigned integer type that can encode the given number of operators and sites.\n\nnote: Type Stability\nThis function returns a Type, not a value. The returned type depends on runtime values, so callers should use a function barrier or type annotation to maintain type stability in performance-critical code:T = select_uint_type(n_ops, n_sites)\n_inner_loop(T, data)  # function barrier\n\nArguments\n\nn_operators: Number of distinct operators per site\nn_sites: Number of physical sites\n\nReturns\n\nThe smallest UInt type (UInt8, UInt16, UInt32, or UInt64) that can fit the encoding.\n\nExamples\n\nselect_uint_type(10, 4)    # UInt16\nselect_uint_type(100, 10)  # UInt16\nselect_uint_type(1000, 100) # UInt32\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.site_bits-Union{Tuple{Type{T}}, Tuple{T}} where T<:Unsigned","page":"Polynomials","title":"NCTSSoS.site_bits","text":"site_bits(::Type{T}) where {T<:Unsigned} -> Int\n\nNumber of bits used for site encoding. Fixed at n/4 where n is bit width. Equivalently: sizeof(T) * 8 √∑ 4 = sizeof(T) * 2.\n\nExamples\n\nsite_bits(UInt8)   # 2\nsite_bits(UInt16)  # 4\nsite_bits(UInt32)  # 8\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.VariableRegistry","page":"Polynomials","title":"NCTSSoS.VariableRegistry","text":"VariableRegistry\n\nA registry that maps between variable symbols and their indices. Supports both contiguous (Vector-like) and sparse (Dict-based) indices.\n\nFields\n\nidx_to_variables::Dict{T, Symbol}: Maps index to symbol\nvariables_to_idx::Dict{Symbol, T}: Maps symbol to index\n\nExamples\n\njulia> reg = create_pauli_variables(1:2)\nVariableRegistry with 6 variables: œÉx‚ÇÅ, œÉy‚ÇÅ, œÉz‚ÇÅ, œÉx‚ÇÇ, œÉy‚ÇÇ, œÉz‚ÇÇ\n\njulia> length(reg)\n6\n\njulia> reg[1]  # Access by index\n:œÉx‚ÇÅ\n\njulia> Int(reg[:œÉx‚ÇÅ])  # Access by symbol (convert typed index to Int for display)\n1\n\njulia> :œÉx‚ÇÅ in reg\ntrue\n\n\n\n\n\n","category":"type"},{"location":"apis/polynomials/#Base.getindex-Tuple{VariableRegistry, Symbol}","page":"Polynomials","title":"Base.getindex","text":"Base.getindex(reg::VariableRegistry, sym::Symbol) -> Int\n\nGet the index of the given variable symbol.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.getindex-Union{Tuple{T}, Tuple{A}, Tuple{VariableRegistry{A, T}, Integer}} where {A, T}","page":"Polynomials","title":"Base.getindex","text":"Base.getindex(reg::VariableRegistry{A,T}, idx::Integer) -> Symbol\n\nGet the variable symbol at the given index (converts to type T).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.getindex-Union{Tuple{T}, Tuple{A}, Tuple{VariableRegistry{A, T}, T}} where {A, T}","page":"Polynomials","title":"Base.getindex","text":"Base.getindex(reg::VariableRegistry{A,T}, idx::T) -> Symbol\n\nGet the variable symbol at the given index.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.in-Tuple{Symbol, VariableRegistry}","page":"Polynomials","title":"Base.in","text":"Base.in(sym::Symbol, reg::VariableRegistry) -> Bool\n\nCheck if a variable symbol exists in the registry.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.length-Tuple{VariableRegistry}","page":"Polynomials","title":"Base.length","text":"Base.length(reg::VariableRegistry) -> Int\n\nReturn the number of variables in the registry.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.show-Tuple{IO, VariableRegistry}","page":"Polynomials","title":"Base.show","text":"Base.show(io::IO, reg::VariableRegistry)\n\nDisplay a variable registry showing its variables in order.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._create_noncommutative_variables-Union{Tuple{VT}, Tuple{T}, Tuple{A}, Tuple{Type{A}, Array{Tuple{String, VT}, 1}}} where {A<:AlgebraType, T<:Integer, VT<:AbstractVector{T}}","page":"Polynomials","title":"NCTSSoS._create_noncommutative_variables","text":"_create_noncommutative_variables(::Type{A}, prefix_subscripts::Vector{Tuple{String, VT}})\n\nInternal function to create variables with multiple prefixes and site-encoded grouped indices. Each tuple (prefix, subscripts) defines a group of variables with a specific prefix. Variables from each group are assigned to a distinct physical site (1-indexed by group order).\n\nArguments\n\nA: The algebra type for the monomials\nprefix_subscripts: Vector of tuples, each containing a prefix string and subscript collection\n\nReturns\n\nA tuple of:\n\nVariableRegistry: Registry mapping symbols to encoded indices\nmonomial_groups: Tuple of Vector{NormalMonomial{A,T}} for each prefix group\n\nExamples\n\n# Create P‚ÇÅ, P‚ÇÇ, P‚ÇÉ (site 1) and Q‚ÇÑ, Q‚ÇÖ (site 2)\n_create_noncommutative_variables(ProjectorAlgebra, [(\"P\", 1:3), (\"Q\", 4:5)])\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._select_pauli_type-Tuple{Int64}","page":"Polynomials","title":"NCTSSoS._select_pauli_type","text":"_select_pauli_type(n_sites::Int) -> Type{<:Unsigned}\n\nSelect smallest unsigned type for Pauli variables. Pauli uses contiguous indices: 3 operators per site (œÉx, œÉy, œÉz). Total indices = 3 * n_sites.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._select_signed_index_type-Tuple{Int64}","page":"Polynomials","title":"NCTSSoS._select_signed_index_type","text":"_select_signed_index_type(n::Int) -> Type{<:Signed}\n\nSelect smallest signed type that can hold ¬±n (for fermionic/bosonic).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._subscript_string-Tuple{Int64}","page":"Polynomials","title":"NCTSSoS._subscript_string","text":"_subscript_string(n::Int) -> String\n\nConvert an integer to its Unicode subscript representation.\n\nExample\n\n_subscript_string(42)  # \"‚ÇÑ‚ÇÇ\"\n_subscript_string(0)   # \"‚ÇÄ\"\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.create_bosonic_variables-Tuple{Any}","page":"Polynomials","title":"NCTSSoS.create_bosonic_variables","text":"create_bosonic_variables(subscripts)\n\nCreate a variable registry and monomials for bosonic creation (c‚Å∫) and annihilation (c) operators.\n\nBosonic operators satisfy commutation relations:\n\n[c·µ¢, c‚±º‚Å∫] = Œ¥·µ¢‚±º (creation-annihilation)\n[c·µ¢, c‚±º] = 0 (annihilation-annihilation)\n[c·µ¢‚Å∫, c‚±º‚Å∫] = 0 (creation-creation)\n\nArguments\n\nsubscripts: Subscript values for different modes/sites\n\nReturns\n\nA tuple of:\n\nVariableRegistry: Registry with both c and c‚Å∫ operators for each subscript\n(c, c‚Å∫): Tuple of monomial vectors (annihilation, creation)\n\nExamples\n\njulia> reg, (c, c‚Å∫) = create_bosonic_variables(1:2);\n\njulia> length(c)  # One annihilation per mode\n2\n\njulia> c[1]  # monomial for c‚ÇÅ\nNormalMonomial{BosonicAlgebra, Int8}(...)\n\njulia> :c‚ÇÅ in reg  # annihilation operator\ntrue\n\njulia> :c‚Å∫‚ÇÅ in reg  # creation operator\ntrue\n\nMultiple modes:\n\njulia> reg, (c, c‚Å∫) = create_bosonic_variables(1:3);\n\njulia> length(c)\n3\n\njulia> length(c‚Å∫)\n3\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.create_fermionic_variables-Tuple{Any}","page":"Polynomials","title":"NCTSSoS.create_fermionic_variables","text":"create_fermionic_variables(subscripts)\n\nCreate a variable registry and monomials for fermionic creation (a‚Å∫) and annihilation (a) operators.\n\nFermionic operators satisfy anticommutation relations:\n\n{a·µ¢, a‚±º‚Å∫} = Œ¥·µ¢‚±º (creation-annihilation)\n{a·µ¢, a‚±º} = 0 (annihilation-annihilation)\n{a·µ¢‚Å∫, a‚±º‚Å∫} = 0 (creation-creation)\n\nArguments\n\nsubscripts: Subscript values for different modes/sites\n\nReturns\n\nA tuple of:\n\nVariableRegistry: Registry with both a and a‚Å∫ operators for each subscript\n(a, a‚Å∫): Tuple of monomial vectors (annihilation, creation)\n\nExamples\n\njulia> reg, (a, a‚Å∫) = create_fermionic_variables(1:2);\n\njulia> length(a)  # One annihilation per mode\n2\n\njulia> a[1]  # monomial for a‚ÇÅ\nNormalMonomial{FermionicAlgebra, Int8}(...)\n\njulia> :a‚ÇÅ in reg  # annihilation operator\ntrue\n\njulia> :a‚Å∫‚ÇÅ in reg  # creation operator\ntrue\n\nMultiple modes:\n\njulia> reg, (a, a‚Å∫) = create_fermionic_variables(1:3);\n\njulia> length(a)\n3\n\njulia> length(a‚Å∫)\n3\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.create_noncommutative_variables-Union{Tuple{Array{Tuple{String, VT}, 1}}, Tuple{VT}, Tuple{T}} where {T<:Integer, VT<:AbstractVector{T}}","page":"Polynomials","title":"NCTSSoS.create_noncommutative_variables","text":"create_noncommutative_variables(prefix_subscripts::Vector{Tuple{String, VT}})\n\nCreate a variable registry and monomials for generic non-commutative variables.\n\nNon-commutative variables have no simplification rules - word order is preserved exactly as given.\n\nArguments\n\nprefix_subscripts: Vector of (prefix, subscripts) tuples for multi-prefix creation\n\nReturns\n\nA tuple of:\n\nVariableRegistry: Registry with non-commutative variables for each subscript\nmonomial_groups: Tuple of monomial vectors, one per prefix group\n\nExamples\n\njulia> reg, (x,) = create_noncommutative_variables([(\"x\", 1:3)]);\n\njulia> length(x)\n3\n\njulia> x[1]  # monomial for x‚ÇÅ\nNormalMonomial{NonCommutativeAlgebra, UInt8}(...)\n\njulia> reg, (x, y) = create_noncommutative_variables([(\"x\", 1:2), (\"y\", 3:4)]);\n\njulia> length(x), length(y)\n(2, 2)\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.create_pauli_variables-Tuple{Any}","page":"Polynomials","title":"NCTSSoS.create_pauli_variables","text":"create_pauli_variables(subscripts)\n\nCreate a variable registry and monomials for Pauli spin matrices œÉx, œÉy, œÉz.\n\nPauli matrices satisfy:\n\nœÉ·µ¢¬≤ = 1 (each Pauli matrix squares to identity)\n{œÉ·µ¢, œÉ‚±º} = 2Œ¥·µ¢‚±º (anticommutation relation)\n\nThe operators are always x, y, z components. This function creates variables for each subscript value.\n\nVariable Ordering: Variables are ordered by site first, then by Pauli type (x, y, z). This enables efficient encoding: for index idx, site = (idx - 1) √∑ 3 + 1, pauli_type = (idx - 1) % 3 (0=X, 1=Y, 2=Z).\n\nArguments\n\nsubscripts: Subscript values for different qubits/sites\n\nReturns\n\nA tuple of:\n\nVariableRegistry: Registry with Pauli variables œÉx, œÉy, œÉz for each subscript\n(œÉx, œÉy, œÉz): Tuple of monomial vectors grouped by Pauli type\n\nExamples\n\njulia> reg, (œÉx, œÉy, œÉz) = create_pauli_variables(1:2);\n\njulia> length(œÉx)  # One œÉx per site\n2\n\njulia> œÉx[1]  # monomial for œÉx‚ÇÅ\nNormalMonomial{PauliAlgebra, UInt8}(...)\n\njulia> :œÉx‚ÇÅ in reg\ntrue\n\njulia> Int(reg[:œÉx‚ÇÅ])  # Index 1: site 1, type X\n1\n\nSingle qubit:\n\njulia> reg, (œÉx, œÉy, œÉz) = create_pauli_variables([1]);\n\njulia> length(œÉx)\n1\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.create_projector_variables-Union{Tuple{Array{Tuple{String, VT}, 1}}, Tuple{VT}, Tuple{T}} where {T<:Integer, VT<:AbstractVector{T}}","page":"Polynomials","title":"NCTSSoS.create_projector_variables","text":"create_projector_variables(prefix_subscripts::Vector{Tuple{String, VT}})\n\nCreate a variable registry and monomials for projector operators.\n\nProjector operators satisfy:\n\nPi^2 = Pi (idempotency: projectors square to themselves)\n\nProjectors are self-adjoint and commutativity is NOT enforced.\n\nArguments\n\nprefix_subscripts: Vector of (prefix, subscripts) tuples for multi-prefix creation\n\nReturns\n\nA tuple of:\n\nVariableRegistry: Registry with projector variables for each subscript\nmonomial_groups: Tuple of monomial vectors, one per prefix group\n\nExamples\n\njulia> reg, (P,) = create_projector_variables([(\"P\", 1:3)]);\n\njulia> length(P)\n3\n\njulia> P[1]  # monomial for P‚ÇÅ\nNormalMonomial{ProjectorAlgebra, UInt8}(...)\n\njulia> reg, (P, Q) = create_projector_variables([(\"P\", 1:2), (\"Q\", 3:4)]);\n\njulia> length(P), length(Q)\n(2, 2)\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.create_unipotent_variables-Union{Tuple{Array{Tuple{String, VT}, 1}}, Tuple{VT}, Tuple{T}} where {T<:Integer, VT<:AbstractVector{T}}","page":"Polynomials","title":"NCTSSoS.create_unipotent_variables","text":"create_unipotent_variables(prefix_subscripts::Vector{Tuple{String, VT}})\n\nCreate a variable registry and monomials for unipotent operators.\n\nUnipotent operators satisfy:\n\nU^2 = I (squares to identity)\n\nThis is simpler than Pauli algebra - no cyclic products or cross-operator interactions.\n\nArguments\n\nprefix_subscripts: Vector of (prefix, subscripts) tuples for multi-prefix creation\n\nReturns\n\nA tuple of:\n\nVariableRegistry: Registry with unipotent variables for each subscript\nmonomial_groups: Tuple of monomial vectors, one per prefix group\n\nExamples\n\njulia> reg, (U,) = create_unipotent_variables([(\"U\", 1:3)]);\n\njulia> length(U)\n3\n\njulia> U[1]  # monomial for U‚ÇÅ\nNormalMonomial{UnipotentAlgebra, UInt8}(...)\n\njulia> reg, (U, V) = create_unipotent_variables([(\"U\", 1:2), (\"V\", 3:4)]);\n\njulia> length(U), length(V)\n(2, 2)\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.indices-Tuple{VariableRegistry}","page":"Polynomials","title":"NCTSSoS.indices","text":"indices(reg::VariableRegistry{A,T}) -> Vector{T}\n\nReturn all indices in sorted order.\n\nExamples\n\njulia> reg = create_projector_variables(1:3)\nVariableRegistry with 3 variables: P‚ÇÅ, P‚ÇÇ, P‚ÇÉ\n\njulia> indices(reg)\n3-element Vector{UInt8}:\n 0x01\n 0x02\n 0x03\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.subregistry-Union{Tuple{VT}, Tuple{T}, Tuple{A}, Tuple{VariableRegistry{A, T}, VT}} where {A<:AlgebraType, T<:Integer, VT<:AbstractVector{T}}","page":"Polynomials","title":"NCTSSoS.subregistry","text":"subregistry(reg::VariableRegistry{A,T}, subset_indices::VT) where {A,T,VT<:AbstractVector{T}}\n\nCreate a new VariableRegistry containing only the specified subset of indices.\n\nThis is useful for creating clique-local registries for basis generation in correlative sparsity decomposition.\n\nArguments\n\nreg::VariableRegistry{A,T}: The parent registry\nsubset_indices::AbstractVector{T}: Indices to include in the sub-registry (must match registry's index type)\n\nReturns\n\nA new VariableRegistry{A,T} containing only the variables at the specified indices.\n\nExamples\n\njulia> reg, (x,) = create_noncommutative_variables([(\"x\", 1:5)]);\n\njulia> sorted_idxs = sort(collect(keys(reg.idx_to_variables)));\n\njulia> sub_reg = subregistry(reg, sorted_idxs[1:3]);\n\njulia> length(sub_reg)\n3\n\nNotes\n\nIndices not present in the parent registry are silently ignored\nThe returned registry has the same algebra type as the parent\nThis is a copy operation, not a view - modifications to the sub-registry do not affect the parent registry\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.symbols-Tuple{VariableRegistry}","page":"Polynomials","title":"NCTSSoS.symbols","text":"symbols(reg::VariableRegistry) -> Vector{Symbol}\n\nReturn all symbols in index-sorted order.\n\nExamples\n\njulia> reg = create_projector_variables(1:3)\nVariableRegistry with 3 variables: P‚ÇÅ, P‚ÇÇ, P‚ÇÉ\n\njulia> symbols(reg)\n3-element Vector{Symbol}:\n :P‚ÇÅ\n :P‚ÇÇ\n :P‚ÇÉ\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.SUPERSCRIPT_EXPONENTS","page":"Polynomials","title":"NCTSSoS.SUPERSCRIPT_EXPONENTS","text":"SUPERSCRIPT_EXPONENTS::Dict{Int,String}\n\nModule-level constant mapping small exponents (2-9) to Unicode superscript characters.\n\nUsed by Base.show to display repeated variables with exponents (e.g., x¬≥ instead of x^3). Avoids allocation in the display loop. Exponents outside this range fall back to ^n notation.\n\n\n\n\n\n","category":"constant"},{"location":"apis/polynomials/#NCTSSoS.AbstractMonomial","page":"Polynomials","title":"NCTSSoS.AbstractMonomial","text":"AbstractMonomial{A<:AlgebraType, T<:Integer}\n\nAbstract supertype for all monomial types, parameterized by algebra type and integer type.\n\nThe type hierarchy is:\n\nAbstractTensorMonomial{As}\n‚îú‚îÄ‚îÄ AbstractMonomial{A,T}                 # Single-algebra monomials (As == Tuple{A})\n‚îÇ   ‚îú‚îÄ‚îÄ NormalMonomial{A,T}               # Bare word (always in canonical form)\n‚îÇ   ‚îú‚îÄ‚îÄ Monomial{A,T,C,W}                 # User-facing wrapper (coeff + word(s))\n‚îÇ   ‚îú‚îÄ‚îÄ StateSymbol{ST,A,T}               # State expectation symbol (in src/states/)\n‚îÇ   ‚îî‚îÄ‚îÄ StateWord{ST,A,T}                 # Product of state symbols (in src/states/)\n‚îî‚îÄ‚îÄ ComposedMonomial{As,Ts}               # Multi-algebra tensor monomial (in composed.jl)\n\nInterface\n\nAll subtypes should implement:\n\ndegree(m): Return total degree (number of operators)\nvariable_indices(m): Return set of variable indices present\nBase.isless(m1, m2): Ordering for sorting\nBase.:(==)(m1, m2): Equality comparison\nBase.hash(m, h): Hash function\n\nSee also: NormalMonomial, AbstractTensorMonomial\n\n\n\n\n\n","category":"type"},{"location":"apis/polynomials/#NCTSSoS.AbstractTensorMonomial","page":"Polynomials","title":"NCTSSoS.AbstractTensorMonomial","text":"AbstractTensorMonomial{As<:Tuple}\n\nAbstract supertype for monomials living in an ordered tensor-product algebra ‚äó_{i} As[i].\n\nThe signature As is semantic and ordered: Tuple{PauliAlgebra,FermionicAlgebra} is different from Tuple{FermionicAlgebra,PauliAlgebra}.\n\nThis type exists to enable signature-level multiple dispatch without wrapper objects.\n\nSee also: AbstractMonomial, ComposedMonomial\n\n\n\n\n\n","category":"type"},{"location":"apis/polynomials/#NCTSSoS.NormalMonomial","page":"Polynomials","title":"NCTSSoS.NormalMonomial","text":"NormalMonomial{A<:AlgebraType, T<:Integer} <: AbstractMonomial{A,T}\n\nRepresents an immutable monomial in word representation for non-commutative algebras. The word vector represents a product of operators (e.g., [1,3,1,3] = xzxz).\n\nFields\n\nword::Vector{T}: The monomial representation word\n\nType Parameters\n\nA<:AlgebraType: Algebra type for dispatch (PauliAlgebra, FermionicAlgebra, etc.)\nT<:Integer: Integer type for the monomial vector\nUInt16: For self-adjoint variables (Pauli, Projector, Unipotent)\nInt32: For non-self-adjoint variables (Fermionic, Bosonic)\n\nDesign\n\nThe algebra type is in the type parameter, enabling:\n\nZero per-element overhead (no runtime metadata)\nCompile-time dispatch for multiplication/simplification\nType safety: can't accidentally multiply incompatible algebras\n\nThe struct is immutable for safety - simplification operations return new monomials rather than mutating existing ones.\n\nExamples\n\njulia> m1 = NormalMonomial{PauliAlgebra}([1, 3, 1, 3]);\n\njulia> m1.word\n4-element Vector{Int64}:\n 1\n 3\n 1\n 3\n\njulia> typeof(m1)\nNormalMonomial{PauliAlgebra, Int64}\n\nDifferent algebra types:\n\njulia> m_pauli = NormalMonomial{PauliAlgebra}(UInt16[1, 2, 3]);\n\njulia> typeof(m_pauli)\nNormalMonomial{PauliAlgebra, UInt16}\n\njulia> m_fermi = NormalMonomial{FermionicAlgebra}(Int32[-1, 2, -3]);\n\njulia> typeof(m_fermi)\nNormalMonomial{FermionicAlgebra, Int32}\n\nEquality comparison:\n\njulia> m1 = NormalMonomial{PauliAlgebra}([1, 3, 1, 3]);\n\njulia> m2 = NormalMonomial{PauliAlgebra}([1, 3, 1, 2]);\n\njulia> m1 == m2\nfalse\n\njulia> m3 = NormalMonomial{PauliAlgebra}([1, 3, 1, 3]);\n\njulia> m1 == m3\ntrue\n\n\n\n\n\n","category":"type"},{"location":"apis/polynomials/#Base.:==-Union{Tuple{T2}, Tuple{T1}, Tuple{A2}, Tuple{A1}, Tuple{NormalMonomial{A1, T1}, NormalMonomial{A2, T2}}} where {A1, A2, T1, T2}","page":"Polynomials","title":"Base.:==","text":"Base.:(==)(m1::NormalMonomial, m2::NormalMonomial) -> Bool\n\nEquality comparison for monomials. Monomials of different algebra types are never equal (type-level distinction).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.hash-Union{Tuple{A}, Tuple{NormalMonomial{A}, UInt64}} where A","page":"Polynomials","title":"Base.hash","text":"Base.hash(m::NormalMonomial, h::UInt) -> UInt\n\nHash function for NormalMonomial. Includes algebra type for consistency with equality.\n\nThe hash includes both the algebra type A and the word vector, ensuring that monomials from different algebras with the same word have different hashes. This maintains the hash/equality contract: if m1 == m2, then hash(m1) == hash(m2).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.isless-Union{Tuple{T}, Tuple{A}, Tuple{NormalMonomial{A, T}, NormalMonomial{A, T}}} where {A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.isless","text":"Base.isless(m1::NormalMonomial{A,T}, m2::NormalMonomial{A,T}) where {A,T} -> Bool\n\nCompare two monomials of the same algebra type using degree-first (graded) ordering, then lexicographic ordering on the word vector for monomials of equal degree.\n\nThis ordering is required for:\n\nSorting polynomials (terms are stored in sorted order)\nBinary search in polynomial operations\nConsistent canonical forms\n\nOrdering Rules\n\nDegree-first: Shorter monomials come before longer ones\nLexicographic: For same-degree monomials, compare word vectors element-by-element\n\nType Safety\n\nOnly monomials of the same algebra type A and integer type T can be compared. Attempting to compare monomials of different algebra types will result in a MethodError.\n\nExamples\n\njulia> m1 = NormalMonomial{PauliAlgebra}([1]);\n\njulia> m2 = NormalMonomial{PauliAlgebra}([1, 2]);\n\njulia> isless(m1, m2)  # degree 1 < degree 2\ntrue\n\njulia> m3 = NormalMonomial{PauliAlgebra}([2]);\n\njulia> isless(m1, m3)  # same degree, [1] < [2] lexicographically\ntrue\n\njulia> isless(m3, m1)\nfalse\n\nSorting works correctly:\n\njulia> monos = [NormalMonomial{PauliAlgebra}([2]), NormalMonomial{PauliAlgebra}([1, 2]), NormalMonomial{PauliAlgebra}([1])];\n\njulia> sort!(monos);\n\njulia> [m.word for m in monos]\n3-element Vector{Vector{Int64}}:\n [1]\n [2]\n [1, 2]\n\nSee also: degree\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.isone-Tuple{NormalMonomial}","page":"Polynomials","title":"Base.isone","text":"Base.isone(m::NormalMonomial) -> Bool\n\nCheck if a monomial is the multiplicative identity (empty word).\n\nExamples\n\njulia> m_identity = NormalMonomial{PauliAlgebra}(Int[]);\n\njulia> isone(m_identity)\ntrue\n\njulia> m_not_identity = NormalMonomial{PauliAlgebra}([1, 2]);\n\njulia> isone(m_not_identity)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.iterate-Union{Tuple{NormalMonomial{A, T}}, Tuple{T}, Tuple{A}} where {A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.iterate","text":"Base.iterate(m::NormalMonomial{A,T}) where {A,T}\nBase.iterate(m::NormalMonomial{A,T}, state) where {A,T}\n\nIterate a NormalMonomial, yielding a single (coefficient, NormalMonomial) pair.\n\nThe coefficient is one(coeff_type(A)) since NormalMonomial represents a bare word with unit coefficient. This enables uniform iteration over both NormalMonomial (single term) and Polynomial (multiple terms) in algorithms that process bases of monomials.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m = NormalMonomial{PauliAlgebra}([1, 2]);\n\njulia> for (coef, mono) in m\n           println(\"Coefficient: $coef, Word: $(mono.word)\")\n       end\nCoefficient: 1.0 + 0.0im, Word: [1, 2]\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.one-Tuple{Type{NormalMonomial}}","page":"Polynomials","title":"Base.one","text":"Base.one(::Type{NormalMonomial}) -> NormalMonomial{NonCommutativeAlgebra,UInt}\n\nCreate the identity monomial (empty word) for the generic NormalMonomial type. This fallback is needed for code that uses one(NormalMonomial) without type parameters.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.one-Union{Tuple{NormalMonomial{A, T}}, Tuple{T}, Tuple{A}} where {A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.one","text":"Base.one(m::NormalMonomial{A,T}) where {A,T}\n\nCreate the identity monomial for the same type as m.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.one-Union{Tuple{Type{NormalMonomial{A, T}}}, Tuple{T}, Tuple{A}} where {A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.one","text":"Base.one(::Type{NormalMonomial{A,T}}) where {A<:AlgebraType, T<:Integer}\n\nCreate the identity monomial (empty word).\n\nExamples\n\njulia> m_one = one(NormalMonomial{PauliAlgebra,Int64});\n\njulia> isone(m_one)\ntrue\n\njulia> m_one.word\nInt64[]\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.show-Union{Tuple{T}, Tuple{A}, Tuple{IO, NormalMonomial{A, T}}} where {A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.show","text":"Base.show(io::IO, m::NormalMonomial{A,T}) where {A,T}\n\nDisplay a monomial. If a :registry is present in the IOContext, uses symbol names from the registry. Otherwise, falls back to displaying raw indices.\n\nWhen using a registry, consecutive identical variables are displayed with exponents:\n\n[1, 1, 1] with index 1 mapping to :x displays as x¬≥\n[1, 2, 2] displays as x‚ÇÅy‚ÇÇ¬≤\n[1, 1, 2, 2, 2] displays as x‚ÇÅ¬≤y‚ÇÇ¬≥\n\nExamples\n\n# Without registry (raw indices)\njulia> m = NormalMonomial{PauliAlgebra}([1, 2, 3]);\njulia> show(stdout, m)\n[1, 2, 3]\n\n# With registry (symbolic names)\njulia> reg, (œÉx, œÉy, œÉz) = create_pauli_variables(1:2);\njulia> m = œÉx[1] * œÉy[1];\njulia> show(IOContext(stdout, :registry => reg), m)\nœÉx‚ÇÅœÉy‚ÇÅ\n\n# With exponents for repeated variables\njulia> m = NormalMonomial{PauliAlgebra}([1, 1, 1]);\njulia> show(IOContext(stdout, :registry => reg), m)\nœÉx‚ÇÅ¬≥\n\nSee also: VariableRegistry\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._eq_same_algebra-Union{Tuple{A2}, Tuple{A1}, Tuple{Type{A1}, Type{A2}, Any, Any}} where {A1<:AlgebraType, A2<:AlgebraType}","page":"Polynomials","title":"NCTSSoS._eq_same_algebra","text":"_eq_same_algebra(::Type{A1}, ::Type{A2}, x1, x2) -> Bool\n\nInternal helper for type-safe equality comparison across algebra types.\n\nReturns false immediately if A1 !== A2 (different algebra types are never equal), otherwise delegates to x1 == x2 for the actual payload comparison.\n\nThis ensures monomials from different algebras with identical word vectors are correctly distinguished (e.g., Pauli [1,2] ‚â† Fermionic [1,2]).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._hash_with_algebra-Union{Tuple{A}, Tuple{Type{A}, Any, UInt64}} where A<:AlgebraType","page":"Polynomials","title":"NCTSSoS._hash_with_algebra","text":"_hash_with_algebra(::Type{A}, payload, h::UInt) -> UInt\n\nInternal helper that incorporates the algebra type A into the hash.\n\nThis maintains the hash/equality contract: since monomials from different algebras are never equal (even with identical payloads), their hashes must also differ. The algebra type is hashed first, then combined with the payload hash.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._validate_word-Union{Tuple{T}, Tuple{A}, Tuple{Type{A}, Vector{T}}} where {A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"NCTSSoS._validate_word","text":"_validate_word(::Type{A}, word::Vector{T}) where {A<:AlgebraType,T<:Integer}\n\nValidate that word is already in the algebra-specific normal form for A.\n\nThis is called by the NormalMonomial{A,T} constructor to enforce the invariant: a NormalMonomial is always in normal form.\n\nAlgebra-specific methods are defined in src/simplification/*.jl. The default implementation throws an error for unimplemented algebras.\n\nThrows\n\nErrorException if no validation method is defined for algebra A\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.algebra_type-Union{Tuple{Type{<:AbstractMonomial{A}}}, Tuple{A}} where A<:AlgebraType","page":"Polynomials","title":"NCTSSoS.algebra_type","text":"algebra_type(::Type{<:AbstractMonomial{A}}) where {A<:AlgebraType} -> Type{A}\nalgebra_type(m::AbstractMonomial) -> Type{A}\n\nReturn the algebra type parameter for a monomial type or instance.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.coeff_type-Union{Tuple{Type{<:AbstractMonomial{A}}}, Tuple{A}} where A<:AlgebraType","page":"Polynomials","title":"NCTSSoS.coeff_type","text":"coeff_type(::Type{T}) -> Type{<:Number}\ncoeff_type(x) -> Type{<:Number}\n\nReturn the coefficient type for a simplify result type.\n\nThis enables compile-time determination of coefficient types for type-stable processing of simplification results. Used by ComposedMonomial simplification to determine appropriate coefficient types for the Cartesian product of terms.\n\nFor NormalMonomial{A,T}, returns coeff_type(A) (the algebra's default). For Polynomial{A,T,C}, returns C (the explicit coefficient type).\n\nThis method is shared by NormalMonomial, simplified Monomial expansions, and state monomials (StateSymbol, StateWord) that carry the same algebra type parameter.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> coeff_type(NormalMonomial{PauliAlgebra,Int64})\nComplexF64\n\njulia> coeff_type(NormalMonomial{FermionicAlgebra,Int32})\nFloat64\n\njulia> coeff_type(Polynomial{BosonicAlgebra,Int32,Float64})\nFloat64\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.degree-Tuple{NormalMonomial}","page":"Polynomials","title":"NCTSSoS.degree","text":"degree(m::NormalMonomial) -> Int\n\nCompute the total degree of a monomial (length of word vector). For non-commutative monomials in word representation, this is the number of operators.\n\nExamples\n\njulia> m1 = NormalMonomial([1, 3, 1, 3]);\n\njulia> degree(m1)\n4\n\njulia> m2 = NormalMonomial([2, 2, 2]);\n\njulia> degree(m2)\n3\n\njulia> m_zero = NormalMonomial(Int[]);\n\njulia> degree(m_zero)\n0\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.monomials-Union{Tuple{NormalMonomial{A, T}}, Tuple{T}, Tuple{A}} where {A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"NCTSSoS.monomials","text":"monomials(m::NormalMonomial{A,T}) where {A,T} -> Vector{NormalMonomial{A,T}}\n\nReturn a single-element vector containing the monomial.\n\nThis provides compatibility with the monomials function for Polynomials, allowing uniform iteration over monomials regardless of input type.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m = NormalMonomial{PauliAlgebra}([1, 2]);\n\njulia> monomials(m)\n1-element Vector{NormalMonomial{PauliAlgebra, Int64}}:\n NormalMonomial{PauliAlgebra, Int64}([1, 2])\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.ComposedMonomial","page":"Polynomials","title":"NCTSSoS.ComposedMonomial","text":"ComposedMonomial{As<:Tuple,Ts<:Tuple} <: AbstractTensorMonomial{As}\n\nRepresents a product of monomials from different algebra types.\n\nEach component is a NormalMonomial{A,T} with its own algebra type in the type parameter. This enables tensor products of operators from different algebraic structures.\n\nFields\n\ncomponents::Ts: Tuple of monomials, e.g., (NormalMonomial{PauliAlgebra}, NormalMonomial{FermionicAlgebra})\n\nType Parameters\n\nAs<:Tuple: Ordered algebra signature, e.g. Tuple{PauliAlgebra,FermionicAlgebra}\nTs<:Tuple: Tuple type of the component monomials\n\nDesign\n\nAlgebra types are compile-time information (in each monomial's type parameter), so ComposedMonomial has zero runtime overhead for algebra type storage.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m_pauli = NormalMonomial{PauliAlgebra}(UInt16[1, 4, 7]);  # œÉx on sites 1,2,3\n\njulia> m_fermi = NormalMonomial{FermionicAlgebra}(Int32[-1, 2]);\n\njulia> cm = ComposedMonomial((m_pauli, m_fermi));\n\njulia> length(cm)\n2\n\njulia> degree(cm)\n5\n\njulia> cm[1] === m_pauli\ntrue\n\nSimplification dispatches to each component's algebra and returns a vector of (coefficient, ComposedMonomial) pairs:\n\njulia> using NCTSSoS\n\njulia> using NCTSSoS: encode_index\n\njulia> m_pauli = NormalMonomial{PauliAlgebra}(UInt16[1, 4]);  # œÉx on sites 1,2\n\njulia> m_unip = NormalMonomial{UnipotentAlgebra}(UInt16[encode_index(UInt16, 1, 1), encode_index(UInt16, 1, 1), encode_index(UInt16, 2, 1)]);\n\njulia> cm = ComposedMonomial((m_pauli, m_unip));\n\njulia> terms = simplify(cm);\n\njulia> terms[1][1]\n1.0 + 0.0im\n\njulia> terms[1][2][1].word == UInt16[1, 4]  # Pauli component stays canonical\ntrue\n\njulia> terms[1][2][2].word == [encode_index(UInt16, 2, 1)]  # Unipotent: [1,1,2] -> [2]\ntrue\n\n\n\n\n\n","category":"type"},{"location":"apis/polynomials/#Base.:==-Union{Tuple{Ts2}, Tuple{As2}, Tuple{Ts1}, Tuple{As1}, Tuple{ComposedMonomial{As1, Ts1}, ComposedMonomial{As2, Ts2}}} where {As1, Ts1, As2, Ts2}","page":"Polynomials","title":"Base.:==","text":"Base.:(==)(cm1::ComposedMonomial, cm2::ComposedMonomial) -> Bool\n\nEquality check via component-wise comparison.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.getindex-Tuple{ComposedMonomial, Int64}","page":"Polynomials","title":"Base.getindex","text":"Base.getindex(cm::ComposedMonomial, i::Int) -> NormalMonomial\n\nAccess the i-th component monomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.hash-Tuple{ComposedMonomial, UInt64}","page":"Polynomials","title":"Base.hash","text":"Base.hash(cm::ComposedMonomial, h::UInt) -> UInt\n\nHash function computed from components.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.isless-Union{Tuple{Ts}, Tuple{As}, Tuple{ComposedMonomial{As, Ts}, ComposedMonomial{As, Ts}}} where {As<:Tuple, Ts<:Tuple}","page":"Polynomials","title":"Base.isless","text":"Base.isless(cm1::ComposedMonomial{As,Ts}, cm2::ComposedMonomial{As,Ts}) where {As<:Tuple,Ts<:Tuple}\n\nCompare two ComposedMonomials using degree-first ordering, then component-wise lexicographic.\n\nThis ordering enables sorting ComposedMonomials for polynomial operations.\n\nAlgorithm\n\nCompare total degrees (degree-first ordering)\nIf degrees equal, compare components lexicographically using their isless\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m1 = NormalMonomial{PauliAlgebra}(UInt16[1]);\n\njulia> m2 = NormalMonomial{PauliAlgebra}(UInt16[1, 2]);\n\njulia> m3 = NormalMonomial{FermionicAlgebra}(Int32[1]);\n\njulia> cm1 = ComposedMonomial((m1, m3));  # degree 2\n\njulia> cm2 = ComposedMonomial((m2, m3));  # degree 3\n\njulia> isless(cm1, cm2)  # degree 2 < degree 3\ntrue\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.isone-Tuple{ComposedMonomial}","page":"Polynomials","title":"Base.isone","text":"Base.isone(cm::ComposedMonomial) -> Bool\n\nCheck if a ComposedMonomial is the identity (all components are identity monomials).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.isone-Union{Tuple{Tuple{C, ComposedMonomial}}, Tuple{C}} where C<:Number","page":"Polynomials","title":"Base.isone","text":"Base.isone(t::Tuple{C,<:ComposedMonomial}) where {C} -> Bool\n\nCheck if a composed term is the identity (coefficient 1, all components are identity monomials).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.length-Tuple{ComposedMonomial}","page":"Polynomials","title":"Base.length","text":"Base.length(cm::ComposedMonomial) -> Int\n\nNumber of component monomials.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.one-Union{Tuple{ComposedMonomial{As, Ts}}, Tuple{Ts}, Tuple{As}} where {As, Ts}","page":"Polynomials","title":"Base.one","text":"Base.one(cm::ComposedMonomial{As,Ts}) where {As,Ts}\n\nCreate the identity ComposedMonomial for the same type as cm.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.one-Union{Tuple{Type{ComposedMonomial{As, Ts}}}, Tuple{Ts}, Tuple{As}} where {As<:Tuple, Ts<:Tuple}","page":"Polynomials","title":"Base.one","text":"Base.one(::Type{ComposedMonomial{As,Ts}}) where {As<:Tuple,Ts<:Tuple}\n\nCreate the identity ComposedMonomial (all components are identity monomials).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.degree-Tuple{ComposedMonomial}","page":"Polynomials","title":"NCTSSoS.degree","text":"degree(cm::ComposedMonomial) -> Int\n\nTotal degree across all components.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m1 = NormalMonomial{PauliAlgebra}(UInt16[1, 2, 3]);\n\njulia> m2 = NormalMonomial{FermionicAlgebra}(Int32[1, 2]);\n\njulia> cm = ComposedMonomial((m1, m2));\n\njulia> degree(cm)\n5\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.simplify-Union{Tuple{ComposedMonomial{As, Ts}}, Tuple{Ts}, Tuple{As}} where {As<:Tuple, Ts<:Tuple}","page":"Polynomials","title":"NCTSSoS.simplify","text":"simplify(cm::ComposedMonomial) -> Vector{Tuple{<:Number,<:ComposedMonomial}}\n\nSimplify each component according to its algebra type.\n\nAlways returns Vector{Tuple{coefficient,ComposedMonomial}} for consistent API. Each entry contains a ComposedMonomial with the simplified component monomials.\n\nAlgorithm\n\nSimplify each component using its algebra's simplify function\nConvert all results to (coefficient, monomial) pairs\nCompute Cartesian product across all components\nFilter zero terms\n\nExamples\n\njulia> using NCTSSoS\n\njulia> using NCTSSoS: encode_index\n\njulia> m_pauli = NormalMonomial{PauliAlgebra}(UInt16[]);  # identity\n\njulia> u2 = encode_index(UInt16, 2, 1);\n\njulia> m_unip = NormalMonomial{UnipotentAlgebra}(UInt16[u2, u2]);\n\njulia> cm = ComposedMonomial((m_pauli, m_unip));\n\njulia> result = simplify(cm);\n\njulia> result isa Vector{<:Tuple}\ntrue\n\njulia> result[1][1]\n1.0 + 0.0im\n\njulia> isempty(result[1][2][1].word)  # Pauli identity stays identity\ntrue\n\njulia> isempty(result[1][2][2].word)  # Unipotent [2,2] -> []\ntrue\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.AbstractPolynomial","page":"Polynomials","title":"NCTSSoS.AbstractPolynomial","text":"AbstractPolynomial{C<:Number}\n\nAbstract supertype for all polynomial types in NCTSSoS.\n\nType Parameters\n\nC<:Number: Coefficient type (Float64, ComplexF64, etc.)\n\nSubtypes\n\nPolynomial{A,T,C}: Standard polynomial over a non-commutative algebra\nStatePolynomial{C,ST,A,T}: Polynomial of state expectations (commutative)\nNCStatePolynomial{C,ST,A,T}: Polynomial of state-operator products\n\nInterface\n\nAll subtypes should implement:\n\ncoefficients(p): Return vector of coefficients\nmonomials(p): Return vector of monomials/terms\ndegree(p): Return maximum degree\nBase.zero(::Type{P}), Base.one(::Type{P}): Identity elements\nBase.:(+), Base.:(-), Base.:(*): Arithmetic operations\n\n\n\n\n\n","category":"type"},{"location":"apis/polynomials/#NCTSSoS.Polynomial","page":"Polynomials","title":"NCTSSoS.Polynomial","text":"Polynomial{A<:AlgebraType, T<:Integer, C<:Number}\n\nA polynomial represented as a sum of (coefficient, monomial) pairs. Maintains sorted, unique monomials with non-zero coefficients.\n\nFields\n\nterms::Vector{Tuple{C,NormalMonomial{A,T}}}: Sorted terms with unique monomials and non-zero coefficients\n\nType Parameters\n\nA<:AlgebraType: Algebra type for dispatch (PauliAlgebra, FermionicAlgebra, etc.)\nT<:Integer: Integer type for monomial word representation\nC<:Number: Coefficient type (Float64, ComplexF64, etc.)\n\nInvariants\n\nTerms are sorted by monomial (using isless)\nNo duplicate monomials (combined during construction)\nAll coefficients are non-zero (zeros removed during construction)\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m1 = NormalMonomial{PauliAlgebra}([1, 2]);\n\njulia> m2 = NormalMonomial{PauliAlgebra}([3]);\n\njulia> p = Polynomial([(1.0 + 0.0im, m1), (2.0 + 0.0im, m2)]);\n\njulia> length(terms(p))\n2\n\njulia> degree(p)\n2\n\nConstruction with automatic deduplication:\n\njulia> using NCTSSoS\n\njulia> m = NormalMonomial{PauliAlgebra}([1]);\n\njulia> p = Polynomial([(1.0+0im, m), (2.0+0im, m)]);  # Same monomial twice\n\njulia> length(terms(p))  # Combined into one term\n1\n\njulia> coefficients(p)[1]  # Coefficients added\n3.0 + 0.0im\n\nSee also: NormalMonomial, coefficients, monomials\n\n\n\n\n\n","category":"type"},{"location":"apis/polynomials/#NCTSSoS.Polynomial-Union{Tuple{NormalMonomial{A, T}}, Tuple{T}, Tuple{A}} where {A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"NCTSSoS.Polynomial","text":"Polynomial(m::NormalMonomial{A,T}) where {A,T}\n\nConstruct a polynomial from a monomial with coefficient 1.\n\nThe coefficient type is determined by coeff_type(A):\n\nPauliAlgebra: uses ComplexF64 (Pauli products generate complex phases)\nAll others: uses Float64\n\nnote: No automatic simplification\nThis constructor does NOT call simplify on the monomial. If the monomial is not in canonical form (e.g., a Pauli product like œÉx‚ÇÅ * œÉx‚ÇÅ that should simplify to identity), the resulting polynomial will contain the unsimplified monomial. Use simplify(Polynomial(m)) if canonical form is required.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m = NormalMonomial{PauliAlgebra}([1, 2]);\n\njulia> p = Polynomial(m);\n\njulia> coefficients(p)\n1-element Vector{ComplexF64}:\n 1.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.Polynomial-Union{Tuple{Number}, Tuple{C}, Tuple{T}, Tuple{A}} where {A<:AlgebraType, T<:Integer, C<:Number}","page":"Polynomials","title":"NCTSSoS.Polynomial","text":"Polynomial{A,T,C}(c::Number) where {A,T,C}\n\nConstruct a constant polynomial (coefficient times identity monomial).\n\nExamples\n\njulia> using NCTSSoS\n\njulia> p = Polynomial{PauliAlgebra,Int64,Float64}(5.0);\n\njulia> coefficients(p)\n1-element Vector{Float64}:\n 5.0\n\njulia> isone(monomials(p)[1])\ntrue\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.Polynomial-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A<:AlgebraType, T<:Integer, C<:Number}","page":"Polynomials","title":"NCTSSoS.Polynomial","text":"Polynomial(p::Polynomial{A,T,C}) where {A,T,C}\n\nIdentity constructor: returns the polynomial unchanged. Useful for generic code that may receive NormalMonomial or Polynomial.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> p1 = Polynomial([(2.0 + 0.0im, NormalMonomial{PauliAlgebra}([1]))]);\n\njulia> p2 = Polynomial(p1);\n\njulia> p1 === p2\ntrue\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.Polynomial-Union{Tuple{Tuple{C, NormalMonomial{A, T}}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A<:AlgebraType, T<:Integer, C<:Number}","page":"Polynomials","title":"NCTSSoS.Polynomial","text":"Polynomial((c, m)::Tuple{C,NormalMonomial{A,T}}) where {A,T,C}\n\nConstruct a polynomial from a single term.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m = NormalMonomial{PauliAlgebra}([1, 2]);\n\njulia> p = Polynomial((3.0 + 0.0im, m));\n\njulia> length(terms(p))\n1\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.Polynomial-Union{Tuple{Tuple{Vector{T}, UInt8}}, Tuple{T}} where T<:Integer","page":"Polynomials","title":"NCTSSoS.Polynomial","text":"Polynomial(t::Tuple{Vector{T},UInt8}) where {T<:Integer}\n\nConstruct a Polynomial from a (word, phase) tuple returned by Pauli simplification.\n\nThe phase encoding: 0=1, 1=i, 2=-1, 3=-i (representing (im)^phase).\n\nExamples\n\njulia> using NCTSSoS\n\njulia> # Result from simplify(PauliAlgebra, word)\njulia> result = (Int64[1, 2], UInt8(1));  # word with phase i\n\njulia> p = Polynomial(result);\n\njulia> coefficients(p)[1]\n0.0 + 1.0im\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:==-Union{Tuple{C2}, Tuple{C1}, Tuple{T2}, Tuple{T1}, Tuple{A2}, Tuple{A1}, Tuple{Polynomial{A1, T1, C1}, Polynomial{A2, T2, C2}}} where {A1, A2, T1, T2, C1, C2}","page":"Polynomials","title":"Base.:==","text":"Base.:(==)(p1::Polynomial, p2::Polynomial) -> Bool\n\nCheck if two polynomials are equal. Polynomials are equal if they have the same terms (same monomials with same coefficients).\n\nSince polynomials are maintained in canonical form (sorted, deduplicated), equality is a straightforward comparison of the terms vectors.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.convert-Union{Tuple{C2}, Tuple{C1}, Tuple{T}, Tuple{A}, Tuple{Type{Polynomial{A, T, C2}}, Polynomial{A, T, C1}}} where {A<:AlgebraType, T<:Integer, C1<:Number, C2<:Number}","page":"Polynomials","title":"Base.convert","text":"Base.convert(::Type{Polynomial{A,T,C2}}, p::Polynomial{A,T,C1}) where {A,T,C1,C2}\n\nConvert a polynomial to a different coefficient type.\n\nThis is needed for operations like power_by_squaring which may require converting between different coefficient types during computation.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m = NormalMonomial{NonCommutativeAlgebra}(UInt8[1]);\n\njulia> p_int = Polynomial([(2, m)]);  # Int coefficients\n\njulia> p_float = convert(Polynomial{NonCommutativeAlgebra,UInt8,Float64}, p_int);\n\njulia> coefficients(p_float)[1]\n2.0\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.copy-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A<:AlgebraType, T<:Integer, C<:Number}","page":"Polynomials","title":"Base.copy","text":"Base.copy(p::Polynomial{A,T,C}) where {A,T,C}\n\nCreate a shallow copy of the polynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.eltype-Union{Tuple{Type{Polynomial{A, T, C}}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A<:AlgebraType, T<:Integer, C<:Number}","page":"Polynomials","title":"Base.eltype","text":"Base.iterate(p::Polynomial{A,T,C})\nBase.iterate(p::Polynomial{A,T,C}, state::Int)\n\nIterate a Polynomial, yielding (coefficient, NormalMonomial) pairs for each term.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m1 = NormalMonomial{PauliAlgebra}([1]);\n\njulia> m2 = NormalMonomial{PauliAlgebra}([2]);\n\njulia> p = Polynomial([(1.0+0im, m1), (2.0+0im, m2)]);\n\njulia> length(collect(p))\n2\n\njulia> for (coef, mono) in p\n           println(\"Coefficient: $coef, Degree: $(degree(mono))\")\n       end\nCoefficient: 1.0 + 0.0im, Degree: 1\nCoefficient: 2.0 + 0.0im, Degree: 1\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.hash-Tuple{Polynomial, UInt64}","page":"Polynomials","title":"Base.hash","text":"Base.hash(p::Polynomial, h::UInt) -> UInt\n\nHash function for polynomial. Combines hashes of all terms.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.isless-Union{Tuple{C}, Tuple{T}, Tuple{A}, Tuple{Polynomial{A, T, C}, Polynomial{A, T, C}}} where {A<:AlgebraType, T<:Integer, C<:Number}","page":"Polynomials","title":"Base.isless","text":"Base.isless(p1::Polynomial{A,T,C}, p2::Polynomial{A,T,C}) where {A,T,C} -> Bool\n\nCompare two polynomials for sorting. Uses degree-first (graded) ordering:\n\nCompare by highest-degree monomial first\nFor equal monomials, compare by coefficient magnitude\nContinue to next-highest degree monomial if still equal\nPolynomial with fewer terms is \"less\" if all compared terms are equal\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.isone-Tuple{Polynomial}","page":"Polynomials","title":"Base.isone","text":"Base.isone(p::Polynomial) -> Bool\n\nCheck if a polynomial is the multiplicative identity (single term with coefficient 1 and identity monomial).\n\nExamples\n\njulia> using NCTSSoS\n\njulia> p = one(Polynomial{PauliAlgebra,Int64,Float64});\n\njulia> isone(p)\ntrue\n\njulia> p2 = Polynomial{PauliAlgebra,Int64,Float64}(2.0);\n\njulia> isone(p2)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.iszero-Tuple{Polynomial}","page":"Polynomials","title":"Base.iszero","text":"Base.iszero(p::Polynomial) -> Bool\n\nCheck if a polynomial is the zero polynomial (has no terms).\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m = NormalMonomial{PauliAlgebra}([1]);\n\njulia> p = Polynomial([(1.0+0im, m), (-1.0+0im, m)]);  # Cancels out\n\njulia> iszero(p)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.one-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A<:AlgebraType, T<:Integer, C<:Number}","page":"Polynomials","title":"Base.one","text":"Base.one(p::Polynomial{A,T,C}) where {A,T,C}\n\nCreate the multiplicative identity polynomial for the same type as p.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.one-Union{Tuple{Type{Polynomial{A, T, C}}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A<:AlgebraType, T<:Integer, C<:Number}","page":"Polynomials","title":"Base.one","text":"Base.one(::Type{Polynomial{A,T,C}}) where {A,T,C}\n\nCreate the multiplicative identity polynomial (1 times identity monomial).\n\nExamples\n\njulia> using NCTSSoS\n\njulia> p = one(Polynomial{PauliAlgebra,Int64,Float64});\n\njulia> isone(p)\ntrue\n\njulia> coefficients(p)\n1-element Vector{Float64}:\n 1.0\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.show-Union{Tuple{C}, Tuple{T}, Tuple{A}, Tuple{IO, Polynomial{A, T, C}}} where {A, T, C}","page":"Polynomials","title":"Base.show","text":"Base.show(io::IO, p::Polynomial)\n\nDisplay a polynomial as a sum of terms.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.zero-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A<:AlgebraType, T<:Integer, C<:Number}","page":"Polynomials","title":"Base.zero","text":"Base.zero(p::Polynomial{A,T,C}) where {A,T,C}\n\nCreate the zero polynomial for the same type as p.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.zero-Union{Tuple{Type{Polynomial{A, T, C}}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A<:AlgebraType, T<:Integer, C<:Number}","page":"Polynomials","title":"Base.zero","text":"Base.zero(::Type{Polynomial{A,T,C}}) where {A,T,C}\n\nCreate the zero polynomial (no terms).\n\nExamples\n\njulia> using NCTSSoS\n\njulia> p = zero(Polynomial{PauliAlgebra,Int64,Float64});\n\njulia> iszero(p)\ntrue\n\njulia> length(terms(p))\n0\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._process_terms-Union{Tuple{C}, Tuple{T}, Tuple{A}, Tuple{Array{Tuple{C, NormalMonomial{A, T}}, 1}, Type{C}}} where {A<:AlgebraType, T<:Integer, C<:Number}","page":"Polynomials","title":"NCTSSoS._process_terms","text":"_process_terms(input_terms, C) -> Vector{Tuple{C,NormalMonomial}}\n\nProcess a vector of terms: sort by monomial, combine duplicates, remove zeros. This is the core algorithm for maintaining polynomial invariants.\n\nAlgorithm\n\nIf empty, return empty vector\nSort terms by monomial (degree-first, then lexicographic)\nIterate through sorted terms, combining coefficients for duplicate monomials\nFilter out terms with zero coefficients\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.coeff_type-Union{Tuple{Type{<:NCTSSoS.AbstractPolynomial{C}}}, Tuple{C}} where C<:Number","page":"Polynomials","title":"NCTSSoS.coeff_type","text":"coeff_type(::Type{<:AbstractPolynomial{C}}) where {C} -> Type{<:Number}\ncoeff_type(p::AbstractPolynomial) -> Type{<:Number}\n\nReturn the coefficient type C for any AbstractPolynomial subtype.\n\nWorks for all polynomial types including Polynomial{A,T,C} and NCStatePolynomial{C,ST,A,T} since both subtype AbstractPolynomial{C}.\n\nExamples\n\njulia> coeff_type(Polynomial{PauliAlgebra,Int64,ComplexF64})\nComplexF64\n\njulia> coeff_type(Polynomial{NonCommutativeAlgebra,Int64,Float64})\nFloat64\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.coefficients-Tuple{Polynomial}","page":"Polynomials","title":"NCTSSoS.coefficients","text":"coefficients(p::Polynomial) -> Vector{C}\n\nExtract the coefficients of all terms in the polynomial.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m1 = NormalMonomial{PauliAlgebra}([1]);\n\njulia> m2 = NormalMonomial{PauliAlgebra}([2]);\n\njulia> p = Polynomial([(1.0+0im, m1), (2.0+0im, m2)]);\n\njulia> coefficients(p)\n2-element Vector{ComplexF64}:\n 1.0 + 0.0im\n 2.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.degree-Tuple{Polynomial}","page":"Polynomials","title":"NCTSSoS.degree","text":"degree(p::Polynomial) -> Union{Int, Float64}\n\nCompute the maximum degree of all monomials in the polynomial. Returns -Inf for the zero polynomial to preserve the algebraic identity deg(p * q) = deg(p) + deg(q).\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m1 = NormalMonomial{PauliAlgebra}([1]);\n\njulia> m2 = NormalMonomial{PauliAlgebra}([2, 3, 4]);\n\njulia> p = Polynomial([(1.0+0im, m1), (2.0+0im, m2)]);\n\njulia> degree(p)\n3\n\njulia> degree(zero(Polynomial{PauliAlgebra,Int64,ComplexF64}))\n-Inf\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.monomials-Union{Tuple{Polynomial{A, T}}, Tuple{T}, Tuple{A}} where {A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"NCTSSoS.monomials","text":"monomials(p::Polynomial) -> Vector{NormalMonomial}\n\nExtract the monomials of all terms in the polynomial.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m1 = NormalMonomial{PauliAlgebra}([1]);\n\njulia> m2 = NormalMonomial{PauliAlgebra}([2]);\n\njulia> p = Polynomial([(1.0+0im, m1), (2.0+0im, m2)]);\n\njulia> ms = monomials(p);\n\njulia> length(ms)\n2\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.terms-Tuple{Polynomial}","page":"Polynomials","title":"NCTSSoS.terms","text":"terms(p::Polynomial)\n\nIterate the polynomial as (coefficient, monomial) pairs.\n\nThe returned monomials are NormalMonomials (canonical form).\n\nExamples\n\njulia> using NCTSSoS\n\njulia> reg, (œÉx, œÉy, œÉz) = create_pauli_variables(1:1);\n\njulia> m1 = œÉx[1];\n\njulia> m2 = œÉy[1];\n\njulia> p = Polynomial([(1.0+0im, m1), (2.0+0im, m2)]);\n\njulia> length(terms(p))\n2\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.variable_indices-Union{Tuple{NormalMonomial{A, T}}, Tuple{T}, Tuple{A}} where {A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"NCTSSoS.variable_indices","text":"variable_indices(m::NormalMonomial{A,T}) -> Set{T}\n\nGet the set of all variable indices used in a monomial. Returns a Set of integer indices.\n\nFor signed index types (Fermionic/Bosonic), uses abs(idx) to normalize indices. This treats creation operators (negative indices like -1 for a‚ÇÅ‚Ä†) and annihilation operators (positive indices like 1 for a‚ÇÅ) as referring to the same physical mode, which is the correct behavior for correlative sparsity analysis.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m = NormalMonomial{PauliAlgebra}([1, 2, 1]);\n\njulia> variable_indices(m)\nSet{Int64} with 2 elements:\n  2\n  1\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.variable_indices-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A, T, C}","page":"Polynomials","title":"NCTSSoS.variable_indices","text":"variable_indices(p::Polynomial) -> Set\n\nGet the set of all variable indices used in the polynomial's monomials. Returns a Set of integer indices.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m1 = NormalMonomial{PauliAlgebra}([1, 2]);\n\njulia> m2 = NormalMonomial{PauliAlgebra}([2, 3]);\n\njulia> p = Polynomial([(1.0+0im, m1), (1.0+0im, m2)]);\n\njulia> variable_indices(p)\nSet{Int64} with 3 elements:\n  2\n  3\n  1\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.NCStatePolynomial","page":"Polynomials","title":"NCTSSoS.NCStatePolynomial","text":"NCStatePolynomial{C<:Number, ST<:StateType, A<:MonoidAlgebra, T<:Integer}\n\nA polynomial in non-commutative state words with coefficients.\n\nRepresents a sum of NCStateWords with coefficients: sumi ci * ncsw_i\n\nFields\n\ncoeffs::Vector{C}: Coefficients for each NC state word\nnc_state_words::Vector{NCStateWord{ST,A,T}}: Sorted unique NC state words\n\nInvariants\n\nSame as StatePolynomial: sorted, unique, non-zero coefficients.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m1 = NormalMonomial{ProjectorAlgebra}(UInt8[1]);\n\njulia> sw = StateWord{Arbitrary}([m1]);\n\njulia> ncsw = NCStateWord(sw, m1);\n\njulia> ncsp = NCStatePolynomial([1.0], [ncsw]);\n\njulia> length(ncsp.nc_state_words)\n1\n\nSee also: NCStateWord, StatePolynomial\n\n\n\n\n\n","category":"type"},{"location":"apis/polynomials/#NCTSSoS.StatePolynomial","page":"Polynomials","title":"NCTSSoS.StatePolynomial","text":"StatePolynomial{C<:Number, ST<:StateType, A<:AlgebraType, T<:Integer}\n\nA polynomial in state words with coefficients.\n\nRepresents a sum of state words with coefficients: sumi ci * sw_i\n\nFields\n\ncoeffs::Vector{C}: Coefficients for each state word\nstate_words::Vector{StateWord{ST,A,T}}: Sorted unique state words\n\nInvariants\n\nstate_words is sorted by the StateWord ordering\nAll state words are unique (combined during construction)\nAll coefficients are non-zero (zeros removed during construction)\nlength(coeffs) == length(state_words)\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m1 = NormalMonomial{ProjectorAlgebra}(UInt8[1, 2]);\n\njulia> m2 = NormalMonomial{ProjectorAlgebra}(UInt8[3]);\n\njulia> sw1 = StateWord{Arbitrary}([m1]);\n\njulia> sw2 = StateWord{Arbitrary}([m2]);\n\njulia> sp = StatePolynomial([1.0, 2.0], [sw1, sw2]);\n\njulia> length(sp.state_words)\n2\n\nSee also: StateWord, NCStatePolynomial\n\n\n\n\n\n","category":"type"},{"location":"apis/polynomials/#Base.:*-Tuple{NCTSSoS.NCStatePolynomial, Number}","page":"Polynomials","title":"Base.:*","text":"Base.:(*)(ncsp::NCStatePolynomial, c::Number)\n\nScalar multiplication (scalar on right).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:*-Tuple{StatePolynomial, Number}","page":"Polynomials","title":"Base.:*","text":"Base.:(*)(sp::StatePolynomial, c::Number)\n\nScalar multiplication (scalar on right).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C2}, Tuple{C1}, Tuple{StatePolynomial{C1, ST, A, T}, StatePolynomial{C2, ST, A, T}}} where {C1<:Number, C2<:Number, ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.:*","text":"Base.:(*)(a::StatePolynomial{C1,ST,A,T}, b::StatePolynomial{C2,ST,A,T}) where {C1,C2,ST,A,T}\n\nMultiply two StatePolynomials.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{NormalMonomial{A, T}, StatePolynomial{C, ST, A, T}}} where {C<:Number, ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.:*","text":"Base.:(*)(m::NormalMonomial{A,T}, sp::StatePolynomial{C,ST,A,T}) where {C,ST,A,T}\n\nMultiply a NormalMonomial by a StatePolynomial (on the left).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{Number, NCTSSoS.NCStatePolynomial{C, ST, A, T}}} where {C<:Number, ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.:*","text":"Base.:(*)(c::Number, ncsp::NCStatePolynomial)\n\nScalar multiplication (scalar on left).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{Number, StatePolynomial{C, ST, A, T}}} where {C<:Number, ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.:*","text":"Base.:(*)(c::Number, sp::StatePolynomial)\n\nScalar multiplication (scalar on left).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{StatePolynomial{C, ST, A, T}, NormalMonomial{A, T}}} where {C<:Number, ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.:*","text":"Base.:(*)(sp::StatePolynomial{C,ST,A,T}, m::NormalMonomial{A,T}) where {C,ST,A,T}\n\nMultiply a StatePolynomial by a NormalMonomial (on the right). Equivalent to multiplying by one(Polynomial) - used in expressions like sp * one(NormalMonomial). The result is an NCStatePolynomial since it now has both state and non-commutative parts.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{StatePolynomial{C, ST, A, T}, StateWord{ST, A, T}}} where {C<:Number, ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.:*","text":"Base.:(*)(sp::StatePolynomial{C,ST,A,T}, sw::StateWord{ST,A,T}) where {C,ST,A,T}\n\nMultiply a StatePolynomial by a StateWord.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{StateWord{ST, A, T}, StatePolynomial{C, ST, A, T}}} where {C<:Number, ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.:*","text":"Base.:(*)(sw::StateWord{ST,A,T}, sp::StatePolynomial{C,ST,A,T}) where {C,ST,A,T}\n\nMultiply a StateWord by a StatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{Number, NCStateWord{ST, A, T}}} where {ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.:*","text":"Base.:(*)(c::Number, ncsw::NCStateWord{ST,A,T}) where {ST,A,T}\n\nMultiply a scalar with an NCStateWord, creating an NCStatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{Number, StateWord{ST, A, T}}} where {ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.:*","text":"Base.:(*)(c::Number, sw::StateWord{ST,A,T}) where {ST,A,T}\n\nMultiply a scalar with a StateWord, creating a StatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:+-Union{Tuple{TC}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateWord{ST, A, T}, Tuple{TC, StateWord{ST, A, T}}}} where {ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer, TC<:Number}","page":"Polynomials","title":"Base.:+","text":"Base.:(+)(sw::StateWord{ST,A,T}, t::Tuple{TC,StateWord{ST,A,T}}) where {ST,A,T,TC}\n\nAdd a StateWord to a (coefficient, StateWord) pair to create a StatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C2}, Tuple{C1}, Tuple{NCTSSoS.NCStatePolynomial{C1, ST, A, T}, NCTSSoS.NCStatePolynomial{C2, ST, A, T}}} where {C1<:Number, C2<:Number, ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.:+","text":"Base.:(+)(a::NCStatePolynomial, b::NCStatePolynomial)\n\nAdd two NCStatePolynomials.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C2}, Tuple{C1}, Tuple{StatePolynomial{C1, ST, A, T}, StatePolynomial{C2, ST, A, T}}} where {C1<:Number, C2<:Number, ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.:+","text":"Base.:(+)(a::StatePolynomial{C1,ST,A,T}, b::StatePolynomial{C2,ST,A,T}) where {C1,C2,ST,A,T}\n\nAdd two StatePolynomials.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}, NCStateWord{ST, A, T}}} where {C<:Number, ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.:+","text":"Base.:(+)(ncsp::NCStatePolynomial{C,ST,A,T}, ncsw::NCStateWord{ST,A,T}) where {C,ST,A,T}\n\nAdd an NCStateWord to an NCStatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{StatePolynomial{C, ST, A, T}, StateWord{ST, A, T}}} where {C<:Number, ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.:+","text":"Base.:(+)(sp::StatePolynomial{C,ST,A,T}, sw::StateWord{ST,A,T}) where {C,ST,A,T}\n\nAdd a StateWord to a StatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{NCStateWord{ST, A, T}, NCStateWord{ST, A, T}}} where {ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.:+","text":"Base.:(+)(a::NCStateWord{ST,A,T}, b::NCStateWord{ST,A,T}) where {ST,A,T}\n\nAdd two NCStateWords to create an NCStatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{Number, NCStateWord{ST, A, T}}} where {ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.:+","text":"Base.:(+)(c::Number, ncsw::NCStateWord{ST,A,T}) where {ST,A,T}\n\nAdd a scalar to an NCStateWord, creating an NCStatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{Number, StateWord{ST, A, T}}} where {ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.:+","text":"Base.:(+)(c::Number, sw::StateWord{ST,A,T}) where {ST,A,T}\n\nAdd a scalar to a StateWord, creating a StatePolynomial with identity StateWord for the constant.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateWord{ST, A, T}, StateWord{ST, A, T}}} where {ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.:+","text":"Base.:(+)(sw1::StateWord{ST,A,T}, sw2::StateWord{ST,A,T}) where {ST,A,T}\n\nAdd two StateWords to create a StatePolynomial with both words.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:+-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{TC}, Tuple{C}, Tuple{StatePolynomial{C, ST, A, T}, Tuple{TC, StateWord{ST, A, T}}}} where {C<:Number, TC<:Number, ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.:+","text":"Base.:(+)(sp::StatePolynomial{C,ST,A,T}, t::Tuple{TC,StateWord{ST,A,T}}) where {C,TC,ST,A,T}\n\nAdd a (coefficient, StateWord) pair to a StatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:--Union{Tuple{NCStateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.:-","text":"Base.:(-)(ncsw::NCStateWord{ST,A,T}) where {ST,A,T}\n\nNegate an NCStateWord to create an NCStatePolynomial with coefficient -1.0.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:--Union{Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C<:Number, ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.:-","text":"Base.:(-)(ncsp::NCStatePolynomial)\n\nNegate an NCStatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:--Union{Tuple{StatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C<:Number, ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.:-","text":"Base.:(-)(sp::StatePolynomial)\n\nNegate a StatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:--Union{Tuple{StateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.:-","text":"Base.:(-)(sw::StateWord{ST,A,T}) where {ST,A,T}\n\nNegate a StateWord to create a StatePolynomial with coefficient -1.0.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:--Union{Tuple{TC}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateWord{ST, A, T}, Tuple{TC, StateWord{ST, A, T}}}} where {ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer, TC<:Number}","page":"Polynomials","title":"Base.:-","text":"Base.:(-)(sw::StateWord{ST,A,T}, t::Tuple{TC,StateWord{ST,A,T}}) where {ST,A,T,TC}\n\nSubtract a (coefficient, StateWord) pair from a StateWord to create a StatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:--Union{Tuple{TC}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{Tuple{TC, StateWord{ST, A, T}}, StateWord{ST, A, T}}} where {ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer, TC<:Number}","page":"Polynomials","title":"Base.:-","text":"Base.:(-)(t::Tuple{TC,StateWord{ST,A,T}}, sw::StateWord{ST,A,T}) where {ST,A,T,TC}\n\nSubtract a StateWord from a (coefficient, StateWord) pair to create a StatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C2}, Tuple{C1}, Tuple{NCTSSoS.NCStatePolynomial{C1, ST, A, T}, NCTSSoS.NCStatePolynomial{C2, ST, A, T}}} where {C1<:Number, C2<:Number, ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.:-","text":"Base.:(-)(a::NCStatePolynomial, b::NCStatePolynomial)\n\nSubtract two NCStatePolynomials.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C2}, Tuple{C1}, Tuple{StatePolynomial{C1, ST, A, T}, StatePolynomial{C2, ST, A, T}}} where {C1<:Number, C2<:Number, ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.:-","text":"Base.:(-)(a::StatePolynomial, b::StatePolynomial)\n\nSubtract two StatePolynomials.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{NCStateWord{ST, A, T}, NCTSSoS.NCStatePolynomial{C, ST, A, T}}} where {C<:Number, ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.:-","text":"Base.:(-)(ncsw::NCStateWord{ST,A,T}, ncsp::NCStatePolynomial{C,ST,A,T}) where {C,ST,A,T}\n\nSubtract an NCStatePolynomial from an NCStateWord.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}, NCStateWord{ST, A, T}}} where {C<:Number, ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.:-","text":"Base.:(-)(ncsp::NCStatePolynomial{C,ST,A,T}, ncsw::NCStateWord{ST,A,T}) where {C,ST,A,T}\n\nSubtract an NCStateWord from an NCStatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{StatePolynomial{C, ST, A, T}, StateWord{ST, A, T}}} where {C<:Number, ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.:-","text":"Base.:(-)(sp::StatePolynomial{C,ST,A,T}, sw::StateWord{ST,A,T}) where {C,ST,A,T}\n\nSubtract a StateWord from a StatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{NCStateWord{ST, A, T}, NCStateWord{ST, A, T}}} where {ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.:-","text":"Base.:(-)(a::NCStateWord{ST,A,T}, b::NCStateWord{ST,A,T}) where {ST,A,T}\n\nSubtract two NCStateWords to create an NCStatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{NCStateWord{ST, A, T}, Number}} where {ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.:-","text":"Base.:(-)(ncsw::NCStateWord{ST,A,T}, c::Number) where {ST,A,T}\n\nSubtract a scalar from an NCStateWord.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{Number, NCStateWord{ST, A, T}}} where {ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.:-","text":"Base.:(-)(c::Number, ncsw::NCStateWord{ST,A,T}) where {ST,A,T}\n\nSubtract an NCStateWord from a scalar.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{Number, StateWord{ST, A, T}}} where {ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.:-","text":"Base.:(-)(c::Number, sw::StateWord{ST,A,T}) where {ST,A,T}\n\nSubtract a StateWord from a scalar.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateWord{ST, A, T}, StateWord{ST, A, T}}} where {ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.:-","text":"Base.:(-)(sw1::StateWord{ST,A,T}, sw2::StateWord{ST,A,T}) where {ST,A,T}\n\nSubtract two StateWords to create a StatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:--Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{TC}, Tuple{C}, Tuple{StatePolynomial{C, ST, A, T}, Tuple{TC, StateWord{ST, A, T}}}} where {C<:Number, TC<:Number, ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.:-","text":"Base.:(-)(sp::StatePolynomial{C,ST,A,T}, t::Tuple{TC,StateWord{ST,A,T}}) where {C,TC,ST,A,T}\n\nSubtract a (coefficient, StateWord) pair from a StatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:==-Union{Tuple{T2}, Tuple{T1}, Tuple{A2}, Tuple{A1}, Tuple{ST2}, Tuple{ST1}, Tuple{C2}, Tuple{C1}, Tuple{NCTSSoS.NCStatePolynomial{C1, ST1, A1, T1}, NCTSSoS.NCStatePolynomial{C2, ST2, A2, T2}}} where {C1, C2, ST1, ST2, A1, A2, T1, T2}","page":"Polynomials","title":"Base.:==","text":"Base.:(==)(a::NCStatePolynomial, b::NCStatePolynomial) -> Bool\n\nCheck if two NCStatePolynomials are equal.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:==-Union{Tuple{T2}, Tuple{T1}, Tuple{A2}, Tuple{A1}, Tuple{ST2}, Tuple{ST1}, Tuple{C2}, Tuple{C1}, Tuple{StatePolynomial{C1, ST1, A1, T1}, StatePolynomial{C2, ST2, A2, T2}}} where {C1, C2, ST1, ST2, A1, A2, T1, T2}","page":"Polynomials","title":"Base.:==","text":"Base.:(==)(a::StatePolynomial, b::StatePolynomial) -> Bool\n\nCheck if two StatePolynomials are equal.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.hash-Tuple{NCTSSoS.NCStatePolynomial, UInt64}","page":"Polynomials","title":"Base.hash","text":"Base.hash(ncsp::NCStatePolynomial, h::UInt) -> UInt\n\nHash function for NCStatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.hash-Tuple{StatePolynomial, UInt64}","page":"Polynomials","title":"Base.hash","text":"Base.hash(sp::StatePolynomial, h::UInt) -> UInt\n\nHash function for StatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.isone-Tuple{NCTSSoS.NCStatePolynomial}","page":"Polynomials","title":"Base.isone","text":"Base.isone(ncsp::NCStatePolynomial) -> Bool\n\nCheck if an NCStatePolynomial is the identity.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.isone-Tuple{StatePolynomial}","page":"Polynomials","title":"Base.isone","text":"Base.isone(sp::StatePolynomial) -> Bool\n\nCheck if a StatePolynomial is the identity.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.iszero-Tuple{NCTSSoS.NCStatePolynomial}","page":"Polynomials","title":"Base.iszero","text":"Base.iszero(ncsp::NCStatePolynomial) -> Bool\n\nCheck if an NCStatePolynomial is zero.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.iszero-Tuple{StatePolynomial}","page":"Polynomials","title":"Base.iszero","text":"Base.iszero(sp::StatePolynomial) -> Bool\n\nCheck if a StatePolynomial is zero (has no terms).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.one-Union{Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C<:Number, ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.one","text":"Base.one(ncsp::NCStatePolynomial{C,ST,A,T}) where {C,ST,A,T}\n\nCreate the identity NCStatePolynomial for the same type.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.one-Union{Tuple{StatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C<:Number, ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.one","text":"Base.one(sp::StatePolynomial{C,ST,A,T}) where {C,ST,A,T}\n\nCreate the identity StatePolynomial for the same type as sp.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.one-Union{Tuple{Type{NCTSSoS.NCStatePolynomial{C, ST, A, T}}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C<:Number, ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.one","text":"Base.one(::Type{NCStatePolynomial{C,ST,A,T}}) where {C,ST,A,T}\n\nCreate the identity NCStatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.one-Union{Tuple{Type{StatePolynomial{C, ST, A, T}}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C<:Number, ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.one","text":"Base.one(::Type{StatePolynomial{C,ST,A,T}}) where {C,ST,A,T}\n\nCreate the identity StatePolynomial (1 * identity StateWord).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.show-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{IO, NCTSSoS.NCStatePolynomial{C, ST, A, T}}} where {C, ST, A, T}","page":"Polynomials","title":"Base.show","text":"Base.show(io::IO, ncsp::NCStatePolynomial{C,ST,A,T}) where {C,ST,A,T}\n\nDisplay an NCStatePolynomial. Uses registry from IO context if available for human-readable symbols.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.show-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}, Tuple{IO, StatePolynomial{C, ST, A, T}}} where {C, ST, A, T}","page":"Polynomials","title":"Base.show","text":"Base.show(io::IO, sp::StatePolynomial{C,ST,A,T}) where {C,ST,A,T}\n\nDisplay a StatePolynomial. Uses registry from IO context if available for human-readable symbols.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.zero-Union{Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C<:Number, ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.zero","text":"Base.zero(ncsp::NCStatePolynomial{C,ST,A,T}) where {C,ST,A,T}\n\nCreate the zero NCStatePolynomial for the same type.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.zero-Union{Tuple{StatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C<:Number, ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.zero","text":"Base.zero(sp::StatePolynomial{C,ST,A,T}) where {C,ST,A,T}\n\nCreate the zero StatePolynomial for the same type as sp.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.zero-Union{Tuple{Type{NCTSSoS.NCStatePolynomial{C, ST, A, T}}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C<:Number, ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.zero","text":"Base.zero(::Type{NCStatePolynomial{C,ST,A,T}}) where {C,ST,A,T}\n\nCreate the zero NCStatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.zero-Union{Tuple{Type{StatePolynomial{C, ST, A, T}}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C<:Number, ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.zero","text":"Base.zero(::Type{StatePolynomial{C,ST,A,T}}) where {C,ST,A,T}\n\nCreate the zero StatePolynomial (no terms).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._process_state_terms-Union{Tuple{W}, Tuple{C}, Tuple{Vector{C}, Vector{W}}} where {C<:Number, W}","page":"Polynomials","title":"NCTSSoS._process_state_terms","text":"_process_state_terms(coeffs::Vector{C}, words::Vector{W}) where {C<:Number, W}\n\nSort, combine duplicates, and filter zeros for state polynomial construction. Returns (processedcoeffs, processedwords).\n\nThis is shared logic between StatePolynomial and NCStatePolynomial constructors.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._show_poly_coeff-Union{Tuple{C}, Tuple{IO, Number, Type{C}, Bool}} where C<:Number","page":"Polynomials","title":"NCTSSoS._show_poly_coeff","text":"_show_poly_coeff(io::IO, c::Number, ::Type{C}, is_first::Bool) where {C<:Number}\n\nFormat and print a polynomial term's coefficient with proper sign handling. Returns false (for next iteration's is_first flag).\n\nHandles special cases:\n\n+1: prints nothing (first term) or \" + \" (subsequent)\n-1: prints \"-\" (first term) or \" - \" (subsequent)\nnegative: prints value (first term) or \" - abs(value)\" (subsequent)\npositive: prints value (first term) or \" + value\" (subsequent)\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.coefficients-Tuple{NCTSSoS.NCStatePolynomial}","page":"Polynomials","title":"NCTSSoS.coefficients","text":"coefficients(ncsp::NCStatePolynomial) -> Vector{C}\n\nGet the coefficients of the NCStatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.coefficients-Tuple{StatePolynomial}","page":"Polynomials","title":"NCTSSoS.coefficients","text":"coefficients(sp::StatePolynomial) -> Vector{C}\n\nGet the coefficients of the StatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.degree-Tuple{NCTSSoS.NCStatePolynomial}","page":"Polynomials","title":"NCTSSoS.degree","text":"degree(ncsp::NCStatePolynomial) -> Int\n\nCompute the maximum degree of all NC state words in the polynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.degree-Tuple{StatePolynomial}","page":"Polynomials","title":"NCTSSoS.degree","text":"degree(sp::StatePolynomial) -> Int\n\nCompute the maximum degree of all state words in the polynomial. Returns 0 for the zero polynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.expval-Union{Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C<:Number, ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"NCTSSoS.expval","text":"expval(ncsp::NCStatePolynomial) -> StatePolynomial\n\nCompute the expectation value of an NCStatePolynomial.\n\nConverts each NCStateWord to a StateWord using expval and combines with coefficients.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.expval-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A<:AlgebraType, T<:Integer, C<:Number}","page":"Polynomials","title":"NCTSSoS.expval","text":"expval(::Type{ST}, p::Polynomial{A,T,C}) where {ST,A,T,C}\n\nExpectation value of a Polynomial.\n\nReturns a StatePolynomial with the same coefficients, converting each NormalMonomial to a StateWord{ST}.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.monomials-Tuple{NCTSSoS.NCStatePolynomial}","page":"Polynomials","title":"NCTSSoS.monomials","text":"monomials(ncsp::NCStatePolynomial) -> Vector{NCStateWord}\n\nGet the NC state words of the NCStatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.monomials-Tuple{StatePolynomial}","page":"Polynomials","title":"NCTSSoS.monomials","text":"monomials(sp::StatePolynomial) -> Vector{StateWord}\n\nGet the state words of the StatePolynomial (these are the \"monomials\" in state space).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.terms-Tuple{NCTSSoS.NCStatePolynomial}","page":"Polynomials","title":"NCTSSoS.terms","text":"terms(ncsp::NCStatePolynomial) -> Zip\n\nIterate over (coefficient, ncstateword) pairs.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.terms-Tuple{StatePolynomial}","page":"Polynomials","title":"NCTSSoS.terms","text":"terms(sp::StatePolynomial) -> Zip\n\nIterate over (coefficient, state_word) pairs.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.tr-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A<:MonoidAlgebra, T<:Integer, C<:Number}","page":"Polynomials","title":"NCTSSoS.tr","text":"tr(p::Polynomial{A,T,C}) -> StatePolynomial\n\nCreate a tracial StatePolynomial from a Polynomial. Converts each term's monomial to a StateWord{MaxEntangled}.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.variable_indices-Union{Tuple{NCStateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST, A, T}","page":"Polynomials","title":"NCTSSoS.variable_indices","text":"variable_indices(ncsw::NCStateWord) -> Set{T}\n\nGet variable indices from an NCStateWord.\n\nThis is an alias for variables() that matches the naming convention used by regular NormalMonomial types.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.variable_indices-Union{Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C, ST, A, T}","page":"Polynomials","title":"NCTSSoS.variable_indices","text":"variable_indices(ncsp::NCStatePolynomial) -> Set{T}\n\nGet all variable indices from an NCStatePolynomial. Extracts indices from both the StateWord and nc_word parts of each NCStateWord.\n\nThis is an alias for variables() that matches the naming convention used by regular Polynomial types.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.variables-Union{Tuple{NCTSSoS.NCStatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C, ST, A, T}","page":"Polynomials","title":"NCTSSoS.variables","text":"variables(ncsp::NCStatePolynomial) -> Set\n\nGet the set of all variable indices used in the NCStatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.variables-Union{Tuple{StatePolynomial{C, ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{C}} where {C, ST, A, T}","page":"Polynomials","title":"NCTSSoS.variables","text":"variables(sp::StatePolynomial) -> Set\n\nGet the set of all variable indices used in the StatePolynomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.œÇ-Union{Tuple{Polynomial{A, T, C}}, Tuple{C}, Tuple{T}, Tuple{A}} where {A<:MonoidAlgebra, T<:Integer, C<:Number}","page":"Polynomials","title":"NCTSSoS.œÇ","text":"œÇ(p::Polynomial{A,T,C}) -> StatePolynomial\n\nCreate a StatePolynomial from a Polynomial. Converts each term's monomial to a StateWord{Arbitrary}.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m = NormalMonomial{ProjectorAlgebra}(UInt8[1, 2]);\n\njulia> p = Polynomial([(1.0, m)]);\n\njulia> sp = œÇ(p);\n\njulia> sp isa StatePolynomial\ntrue\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.NCStateWord","page":"Polynomials","title":"NCTSSoS.NCStateWord","text":"NCStateWord{ST<:StateType, A<:MonoidAlgebra, T<:Integer}\n\nA product of state expectations and a non-commutative operator: <M1><M2>...<Mk> * Onc\n\nCombines a commutative StateWord (expectations) with a non-commutative monomial (operator).\n\nFields\n\nsw::StateWord{ST,A,T}: Commutative state word part\nnc_word::NormalMonomial{A,T}: Non-commutative operator part\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m1 = NormalMonomial{NonCommutativeAlgebra}([1, 2]);\n\njulia> m2 = NormalMonomial{NonCommutativeAlgebra}([3]);\n\njulia> sw = StateWord{Arbitrary}([m1]);\n\njulia> ncsw = NCStateWord(sw, m2);\n\njulia> degree(ncsw)\n3\n\nSee also: StateWord, NCStatePolynomial, expval\n\n\n\n\n\n","category":"type"},{"location":"apis/polynomials/#NCTSSoS.StateSymbol","page":"Polynomials","title":"NCTSSoS.StateSymbol","text":"StateSymbol{ST<:StateType, A<:AlgebraType, T<:Integer} <: AbstractMonomial{A,T}\n\nA single state expectation symbol wrapping a canonicalized monomial.\n\nStateSymbol is the atomic unit of state expectations. It stores a single monomial that has been canonicalized according to the state type:\n\nArbitrary: involution canon (min(m, adjoint(m)))\nMaxEntangled: cyclicsymmetriccanon(m)\n\nFields\n\nmono::Vector{T}: The canonicalized monomial\n\nType Parameters\n\nST: State type (Arbitrary or MaxEntangled)\nA: Algebra type\nT: Integer type for monomial words\n\nInvariants\n\nThe monomial is always in canonical form for the given state type\nCanonicalization happens automatically at construction\n\nNote on non-monoid algebras\n\nFor algebras where simplification can introduce phases (Pauli / TwistedGroupAlgebra) or multi-term PBW expansions (Fermionic/Bosonic / PBWAlgebra), the expectation value of a Monomial is not representable by a single StateSymbol. Use expval(ST, m::Monomial) to obtain a StatePolynomial (a linear combination of StateWords) instead.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m = NormalMonomial{ProjectorAlgebra}(UInt8[1, 2]);\n\njulia> sym = StateSymbol{Arbitrary}(m);\n\njulia> degree(sym)\n2\n\nSee also: StateWord\n\n\n\n\n\n","category":"type"},{"location":"apis/polynomials/#NCTSSoS.StateWord","page":"Polynomials","title":"NCTSSoS.StateWord","text":"StateWord{ST<:StateType, A<:AlgebraType, T<:Integer} <: AbstractMonomial{A,T}\n\nA product of state expectations <M1><M2>...<Mk>.\n\nThe state expectations commute, so StateWord maintains symbols in sorted order. All symbols share the same algebra type A.\n\nFields\n\nstate_syms::Vector{StateSymbol{ST,A,T}}: Sorted, canonicalized state symbols\n\nType Parameters\n\nST: State type (Arbitrary or MaxEntangled)\nA: Algebra type (all expectations use the same algebra)\nT: Integer type for monomial words\n\nInvariants\n\nCanonicalization: Each symbol is canonicalized per state type\nCommutativity: state_syms is sorted by the symbol ordering\nIdentity symbols are filtered out (unless all are identity)\n\nwarning: Real expectation values\nThe involution canonicalization enforces ‚ü®M‚ü© = ‚ü®M‚Ä†‚ü©, which means all expectation values are treated as real variables. This is appropriate for Hermitian moment optimization but restricts the variable space to real-valued expectations.\n\nwarning: MaxEntangled (trace) assumptions\nThe MaxEntangled (trace) state type uses cyclic-symmetric canonicalization, which assumes tr(M) = tr(reverse(M)). This can fail for algebras where transposition introduces signs/phases (e.g. Pauli algebra). NCTSSoS.jl restricts state polynomials to MonoidAlgebra (NC/Projector/Unipotent), so PauliAlgebra is not supported here.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m1 = NormalMonomial{NonCommutativeAlgebra}([1, 2]);\n\njulia> m2 = NormalMonomial{NonCommutativeAlgebra}([3]);\n\njulia> sw = StateWord{Arbitrary}([m1, m2]);\n\njulia> length(sw.state_syms)\n2\n\njulia> degree(sw)\n3\n\nSee also: StateSymbol, NCStateWord, StatePolynomial\n\n\n\n\n\n","category":"type"},{"location":"apis/polynomials/#Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{NCStateWord{ST, A, T}, NCStateWord{ST, A, T}}} where {ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.:*","text":"Base.:(*)(a::NCStateWord{ST,A,T}, b::NCStateWord{ST,A,T}) where {ST,A,T}\n\nMultiply two NCStateWords: multiply sw parts (commutative) and nc_word parts (non-commutative).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:*-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateWord{ST, A, T}, StateWord{ST, A, T}}} where {ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.:*","text":"Base.:(*)(a::StateWord{ST,A,T}, b::StateWord{ST,A,T}) where {ST,A,T}\n\nMultiply two StateWords by concatenating and re-sorting their symbols.\n\nState expectations commute, so the result is a sorted StateWord containing all expectations from both operands.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m1 = NormalMonomial{NonCommutativeAlgebra}([1, 2]);\n\njulia> m2 = NormalMonomial{NonCommutativeAlgebra}([3]);\n\njulia> sw1 = StateWord{Arbitrary}([m1]);\n\njulia> sw2 = StateWord{Arbitrary}([m2]);\n\njulia> result = sw1 * sw2;\n\njulia> result isa StateWord\ntrue\n\njulia> length(result.state_syms)\n2\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:==-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{NCStateWord{ST, A, T}, NCStateWord{ST, A, T}}} where {ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.:==","text":"Base.:(==)(a::NCStateWord{ST,A,T}, b::NCStateWord{ST,A,T}) where {ST,A,T} -> Bool\n\nCheck if two NCStateWords are equal.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:==-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateSymbol{ST, A, T}, StateSymbol{ST, A, T}}} where {ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.:==","text":"Base.:(==)(a::StateSymbol{ST,A,T}, b::StateSymbol{ST,A,T}) where {ST,A,T} -> Bool\n\nCheck if two StateSymbols are equal (same canonicalized monomial).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.:==-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateWord{ST, A, T}, StateWord{ST, A, T}}} where {ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.:==","text":"Base.:(==)(a::StateWord{ST,A,T}, b::StateWord{ST,A,T}) where {ST,A,T} -> Bool\n\nCheck if two StateWords are equal (same state symbols).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.adjoint-Union{Tuple{NCStateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.adjoint","text":"Base.adjoint(ncsw::NCStateWord{ST,A,T}) where {ST,A,T}\n\nCompute the adjoint (Hermitian conjugate) of an NCStateWord by adjointing both parts.\n\nnote: Physics notation\nThis is the dagger (‚Ä†) or star (*) operation in physics notation. You can also use the Julia syntax ncsw' as shorthand for adjoint(ncsw).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.adjoint-Union{Tuple{StateSymbol{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.adjoint","text":"Base.adjoint(sym::StateSymbol{ST,A,T}) where {ST,A,T}\n\nReturn the StateSymbol itself (due to canonicalization, adjoint equals self).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.adjoint-Union{Tuple{StateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.adjoint","text":"Base.adjoint(sw::StateWord{ST,A,T}) where {ST,A,T}\n\nCompute the adjoint (Hermitian conjugate) of a StateWord. Due to the involution invariant, adjoint(sw) == sw for all StateWords.\n\nnote: Physics notation\nThis is the dagger (‚Ä†) or star (*) operation in physics notation. You can also use the Julia syntax sw' as shorthand for adjoint(sw).\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m = NormalMonomial{NonCommutativeAlgebra}([1, 2, 3]);\n\njulia> sw = StateWord{Arbitrary}([m]);\n\njulia> sw_adj = adjoint(sw);\n\njulia> sw == sw_adj  # Due to involution canonicalization\ntrue\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.hash-Tuple{NCStateWord, UInt64}","page":"Polynomials","title":"Base.hash","text":"Base.hash(ncsw::NCStateWord, h::UInt) -> UInt\n\nHash function for NCStateWord. Computed from sw and nc_word.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.hash-Tuple{StateSymbol, UInt64}","page":"Polynomials","title":"Base.hash","text":"Base.hash(sym::StateSymbol, h::UInt) -> UInt\n\nHash function for StateSymbol.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.hash-Tuple{StateWord, UInt64}","page":"Polynomials","title":"Base.hash","text":"Base.hash(sw::StateWord, h::UInt) -> UInt\n\nHash function for StateWord. Computed from state_syms.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.isless-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{NCStateWord{ST, A, T}, NCStateWord{ST, A, T}}} where {ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.isless","text":"Base.isless(a::NCStateWord{ST,A,T}, b::NCStateWord{ST,A,T}) where {ST,A,T} -> Bool\n\nCompare two NCStateWords: degree first, then nc_word, then sw.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.isless-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateSymbol{ST, A, T}, StateSymbol{ST, A, T}}} where {ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.isless","text":"Base.isless(a::StateSymbol{ST,A,T}, b::StateSymbol{ST,A,T}) where {ST,A,T} -> Bool\n\nCompare two StateSymbols: degree-first, then by monomial ordering.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.isless-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{StateWord{ST, A, T}, StateWord{ST, A, T}}} where {ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.isless","text":"Base.isless(a::StateWord{ST,A,T}, b::StateWord{ST,A,T}) where {ST,A,T} -> Bool\n\nCompare two StateWords using degree-first ordering, then lexicographic on state_syms.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m1 = NormalMonomial{NonCommutativeAlgebra}([1]);\n\njulia> m2 = NormalMonomial{NonCommutativeAlgebra}([1, 2]);\n\njulia> sw1 = StateWord{Arbitrary}([m1]);\n\njulia> sw2 = StateWord{Arbitrary}([m2]);\n\njulia> isless(sw1, sw2)  # degree 1 < degree 2\ntrue\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.isone-Tuple{NCStateWord}","page":"Polynomials","title":"Base.isone","text":"Base.isone(ncsw::NCStateWord) -> Bool\n\nCheck if an NCStateWord is the identity.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.isone-Tuple{StateSymbol}","page":"Polynomials","title":"Base.isone","text":"Base.isone(sym::StateSymbol) -> Bool\n\nCheck if a StateSymbol wraps the identity monomial.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.isone-Tuple{StateWord}","page":"Polynomials","title":"Base.isone","text":"Base.isone(sw::StateWord) -> Bool\n\nCheck if a StateWord is the identity (single identity symbol).\n\nExamples\n\njulia> using NCTSSoS\n\njulia> sw_one = one(StateWord{Arbitrary,NonCommutativeAlgebra,Int64});\n\njulia> isone(sw_one)\ntrue\n\njulia> m = NormalMonomial{NonCommutativeAlgebra}([1]);\n\njulia> sw = StateWord{Arbitrary}([m]);\n\njulia> isone(sw)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.one-Union{Tuple{NCStateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.one","text":"Base.one(ncsw::NCStateWord{ST,A,T}) where {ST,A,T}\n\nCreate the identity NCStateWord for the same type.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.one-Union{Tuple{StateSymbol{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.one","text":"Base.one(sym::StateSymbol{ST,A,T}) where {ST,A,T}\n\nCreate the identity StateSymbol for the same type.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.one-Union{Tuple{StateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.one","text":"Base.one(sw::StateWord{ST,A,T}) where {ST,A,T}\n\nCreate the identity StateWord for the same type as sw.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.one-Union{Tuple{Type{NCStateWord{ST, A, T}}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"Base.one","text":"Base.one(::Type{NCStateWord{ST,A,T}}) where {ST,A,T}\n\nCreate the identity NCStateWord.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.one-Union{Tuple{Type{StateSymbol{ST, A, T}}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.one","text":"Base.one(::Type{StateSymbol{ST,A,T}}) where {ST,A,T}\n\nCreate the identity StateSymbol (wrapping identity monomial).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.one-Union{Tuple{Type{StateWord{ST, A, T}}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST<:NCTSSoS.StateType, A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"Base.one","text":"Base.one(::Type{StateWord{ST,A,T}}) where {ST,A,T}\n\nCreate the identity StateWord (single identity symbol).\n\nExamples\n\njulia> using NCTSSoS\n\njulia> sw_one = one(StateWord{Arbitrary,NonCommutativeAlgebra,Int64});\n\njulia> isone(sw_one)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.show-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{IO, NCStateWord{ST, A, T}}} where {ST, A, T}","page":"Polynomials","title":"Base.show","text":"Base.show(io::IO, ncsw::NCStateWord{ST,A,T}) where {ST,A,T}\n\nDisplay an NCStateWord. Uses registry from IO context if available for human-readable symbols.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.show-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{IO, StateSymbol{ST, A, T}}} where {ST, A, T}","page":"Polynomials","title":"Base.show","text":"Base.show(io::IO, sym::StateSymbol{ST,A,T}) where {ST,A,T}\n\nDisplay a StateSymbol with appropriate brackets based on state type.\n\nArbitrary: ‚ü®mono‚ü©\nMaxEntangled: tr(mono)\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.show-Union{Tuple{T}, Tuple{A}, Tuple{ST}, Tuple{IO, StateWord{ST, A, T}}} where {ST, A, T}","page":"Polynomials","title":"Base.show","text":"Base.show(io::IO, sw::StateWord{ST,A,T}) where {ST,A,T}\n\nDisplay a StateWord with appropriate brackets based on state type. Uses registry from IO context if available for human-readable symbols.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._generate_statewords_up_to_degree-Union{Tuple{ST}, Tuple{T}, Tuple{A}, Tuple{Array{NormalMonomial{A, T}, 1}, Int64, Type{ST}}} where {A<:AlgebraType, T<:Integer, ST<:NCTSSoS.StateType}","page":"Polynomials","title":"NCTSSoS._generate_statewords_up_to_degree","text":"_generate_statewords_up_to_degree(monos, max_deg, ST) -> Vector{StateWord}\n\nGenerate all StateWords with total degree <= max_deg.\n\nIncludes:\n\nIdentity StateWord <I> (degree 0)\nSingle expectations <M>\nCompound expectations <M1><M2>, <M1><M2><M3>, etc.\n\nArguments\n\nmonos: Vector of all available monomials\nmax_deg: Maximum total degree for the StateWord\nST: StateType (Arbitrary or MaxEntangled)\n\nReturns\n\nVector of unique, sorted StateWords.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.degree-Tuple{NCStateWord}","page":"Polynomials","title":"NCTSSoS.degree","text":"degree(ncsw::NCStateWord) -> Int\n\nCompute the total degree of an NCStateWord (sw degree + nc_word degree).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.degree-Tuple{StateSymbol}","page":"Polynomials","title":"NCTSSoS.degree","text":"degree(sym::StateSymbol) -> Int\n\nCompute the degree of a StateSymbol (degree of its monomial).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.degree-Tuple{StateWord}","page":"Polynomials","title":"NCTSSoS.degree","text":"degree(sw::StateWord) -> Int\n\nCompute the total degree of a StateWord (sum of symbol degrees).\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m1 = NormalMonomial{NonCommutativeAlgebra}([1, 2]);  # degree 2\n\njulia> m2 = NormalMonomial{NonCommutativeAlgebra}([3]);     # degree 1\n\njulia> sw = StateWord{Arbitrary}([m1, m2]);\n\njulia> degree(sw)\n3\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.expval-Union{Tuple{NCStateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST<:NCTSSoS.StateType, A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"NCTSSoS.expval","text":"expval(ncsw::NCStateWord{ST,A,T}) where {ST,A,T}\n\nCollapse NCStateWord to StateWord by adding nc_word as an expectation.\n\nConverts <M1><M2>...<Mk> * Onc to <M1><M2>...<Mk><Onc>.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m1 = NormalMonomial{NonCommutativeAlgebra}([1, 2]);\n\njulia> m2 = NormalMonomial{NonCommutativeAlgebra}([3, 4]);\n\njulia> sw = StateWord{Arbitrary}([m1]);\n\njulia> ncsw = NCStateWord(sw, m2);\n\njulia> ev = expval(ncsw);\n\njulia> length(ev.state_syms)\n2\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.get_state_basis-Union{Tuple{ST}, Tuple{T}, Tuple{A}, Tuple{VariableRegistry{A, T}, Int64}} where {A<:MonoidAlgebra, T<:Integer, ST<:NCTSSoS.StateType}","page":"Polynomials","title":"NCTSSoS.get_state_basis","text":"get_state_basis(registry::VariableRegistry{A,T}, d::Int;\n                state_type::Type{ST}=Arbitrary) where {A<:AlgebraType, T<:Integer, ST<:StateType}\n\nGenerate a basis of NCStateWord elements up to degree d.\n\nThis function generates all unique NCStateWord basis elements that can be formed from the variables in the registry up to the specified degree. The basis includes all (StateWord, Monomial) combinations where degree(sw) + degree(nc_word) <= d.\n\nThis generates:\n\n<I>*M forms (identity StateWord, operator monomial)\n<M>*I forms (single expectation, identity operator)\n<M1><M2>*I forms (compound expectations, identity operator)\n<M>*N mixed forms (expectation with operator)\n\nArguments\n\nregistry: Variable registry containing the variable indices\nd: Maximum total degree (inclusive)\n\nKeyword Arguments\n\nstate_type: The state type for the basis elements (default: Arbitrary)\n\nReturns\n\nVector{NCStateWord{ST,A,T}}: Sorted unique NCStateWord basis elements\n\nExamples\n\njulia> using NCTSSoS\n\njulia> reg, (x,) = create_unipotent_variables([(\"x\", 1:2)]);\n\njulia> basis = get_state_basis(reg, 1);\n\njulia> length(basis)  # includes <I>*I, <I>*x1, <I>*x2, <x1>*I, <x2>*I\n5\n\njulia> all(b -> b isa NCStateWord{Arbitrary}, basis)\ntrue\n\nFor projector algebra:\n\njulia> using NCTSSoS\n\njulia> reg, (P,) = create_projector_variables([(\"P\", 1:2)]);\n\njulia> basis = get_state_basis(reg, 2; state_type=MaxEntangled);\n\njulia> all(b -> b isa NCStateWord{MaxEntangled}, basis)\ntrue\n\nSee also: NCStateWord, get_ncbasis\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.neat_dot-Tuple{NCStateWord, NCStateWord}","page":"Polynomials","title":"NCTSSoS.neat_dot","text":"neat_dot(x::NCStateWord, y::NCStateWord)\n\nCompute adjoint(x) * y. Common operation in quantum optimization.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m = NormalMonomial{NonCommutativeAlgebra}([1]);\n\njulia> sw = StateWord{Arbitrary}([m]);\n\njulia> ncsw = NCStateWord(sw, m);\n\njulia> nd = neat_dot(ncsw, ncsw);\n\njulia> nd == adjoint(ncsw) * ncsw\ntrue\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.tr-Union{Tuple{NormalMonomial{A, T}}, Tuple{T}, Tuple{A}} where {A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"NCTSSoS.tr","text":"tr(m::NormalMonomial{A,T}) where {A,T}\n\nCreate a StateSymbol{MaxEntangled} from a monomial.\n\nThis is a convenience function for creating trace expressions in the maximally entangled state formalism. Equivalent to StateSymbol{MaxEntangled}(m).\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m = NormalMonomial{NonCommutativeAlgebra}([1, 2]);\n\njulia> sym = tr(m);\n\njulia> sym isa StateSymbol{MaxEntangled}\ntrue\n\ntr(m::NormalMonomial{A,T}) where {A<:MonoidAlgebra,T<:Integer} = StateSymbol{MaxEntangled}(m) tr(pairs::Vector{Tuple{Val{1},NormalMonomial{A,T}}}) where {A<:MonoidAlgebra,T<:Integer} = StateSymbol{MaxEntangled}(pairs)\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.variables-Union{Tuple{NCStateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST, A, T}","page":"Polynomials","title":"NCTSSoS.variables","text":"variables(ncsw::NCStateWord) -> Set\n\nGet the set of all variable indices used in the NCStateWord.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.variables-Union{Tuple{StateSymbol{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST, A, T}","page":"Polynomials","title":"NCTSSoS.variables","text":"variables(sym::StateSymbol{ST,A,T}) -> Set{T}\n\nGet the set of variable indices used in the StateSymbol.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.variables-Union{Tuple{StateWord{ST, A, T}}, Tuple{T}, Tuple{A}, Tuple{ST}} where {ST, A, T}","page":"Polynomials","title":"NCTSSoS.variables","text":"variables(sw::StateWord) -> Set\n\nGet the set of all variable indices used in the StateWord's symbols.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m1 = NormalMonomial{NonCommutativeAlgebra}([1, 2]);\n\njulia> m2 = NormalMonomial{NonCommutativeAlgebra}([2, 3]);\n\njulia> sw = StateWord{Arbitrary}([m1, m2]);\n\njulia> sort(collect(variables(sw)))\n3-element Vector{Int64}:\n 1\n 2\n 3\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.œÇ-Union{Tuple{NormalMonomial{A, T}}, Tuple{T}, Tuple{A}} where {A<:MonoidAlgebra, T<:Integer}","page":"Polynomials","title":"NCTSSoS.œÇ","text":"œÇ(m::NormalMonomial{A,T}) where {A,T}\n\nCreate a StateWord{Arbitrary} from a monomial.\n\nThis is a convenience function for creating state expectations in the arbitrary state formalism. Equivalent to StateWord{Arbitrary}(m).\n\nExamples\n\njulia> using NCTSSoS\n\njulia> m = NormalMonomial{NonCommutativeAlgebra}([1, 2]);\n\njulia> sym = œÇ(m);\n\njulia> sym isa StateWord{Arbitrary}\ntrue\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._pauli_product-Tuple{Int64, Int64}","page":"Polynomials","title":"NCTSSoS._pauli_product","text":"_pauli_product(type1::Int, type2::Int) -> Tuple{UInt8, Int}\n\nCompute the product of two Pauli operators on the SAME site. Returns (phasekdelta, result_type) where:\n\nphasekdelta ‚àà 0:3 encodes phase contribution as (im)^phasekdelta\nresult_type is 0, 1, or 2 (or -1 for identity)\n\nIf type1 == type2, returns (0, -1) to indicate identity (œÉ·µ¢¬≤ = I).\n\nPhase encoding: 0 ‚Üí 1, 1 ‚Üí i, 2 ‚Üí -1, 3 ‚Üí -i\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._validate_word-Union{Tuple{T}, Tuple{Type{PauliAlgebra}, Vector{T}}} where T<:Integer","page":"Polynomials","title":"NCTSSoS._validate_word","text":"_validate_pauli_word!(word::Vector{T}) where {T<:Integer}\n\nCheck that a Pauli word is in canonical form. Throws ArgumentError if invalid.\n\nCanonical form requirements:\n\n‚â§1 operator per site (no œÉ¬≤ terms)\nSites sorted in ascending order\n\nThis is used by NormalMonomial{PauliAlgebra,T} constructor to enforce invariants.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.simplify!-Union{Tuple{T}, Tuple{Type{PauliAlgebra}, Vector{T}}} where T<:Integer","page":"Polynomials","title":"NCTSSoS.simplify!","text":"simplify!(::Type{PauliAlgebra}, word::Vector{T}) where {T<:Integer} -> Tuple{Vector{T}, UInt8}\n\nIn-place site-aware simplification for Pauli algebra word vectors.\n\nOperators on different sites commute and are sorted by site (ascending). Within each site, Pauli product rules apply: œÉ‚ÇìœÉ·µß = iœÉz, œÉ·µ¢¬≤ = I, etc.\n\nReturns a tuple of (word, phase_k) where:\n\nword is the input vector, mutated and resized in-place\nphasek ‚àà 0:3 encodes the accumulated phase as (im)^phasek\n\nPhase encoding: 0 ‚Üí 1, 1 ‚Üí i, 2 ‚Üí -1, 3 ‚Üí -i\n\nAlgorithm\n\nStable sort by site (using _pauli_site)\nTwo-pointer reduction: readidx scans groups, writeidx writes results\nResize to truncate trailing elements\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.simplify-Union{Tuple{T}, Tuple{Type{PauliAlgebra}, Vector{T}}} where T<:Integer","page":"Polynomials","title":"NCTSSoS.simplify","text":"simplify(::Type{PauliAlgebra}, word::Vector{T}) where {T<:Integer}\n\nSimplify a raw Pauli word into canonical form.\n\nThis is the primary entry point for Pauli simplification. Takes a raw word vector and returns a (word, phase) tuple.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#Base.iszero-Union{Tuple{NormalMonomial{FermionicAlgebra, T}}, Tuple{T}} where T","page":"Polynomials","title":"Base.iszero","text":"Base.iszero(m::NormalMonomial{FermionicAlgebra,T}) -> Bool\n\nCheck if a fermionic monomial is zero due to nilpotency.\n\nAlgorithm\n\nA fermionic monomial is zero if for any mode, the net surplus of operators (annihilation minus creation, or vice versa) is 2 or more. This is because:\n\na·µ¢ a·µ¢ = 0 (two annihilations with no creation to contract)\na·µ¢‚Ä† a·µ¢‚Ä† = 0 (two creations with no annihilation to contract)\n\nThe key insight is that anticommutation {a·µ¢, a‚±º} = 0 allows reordering, but if there's a net surplus of ‚â•2 same-type operators for any mode, they cannot all be contracted away and the result is zero.\n\nExamples\n\njulia> m = NormalMonomial{FermionicAlgebra}(Int32[1, 1]);  # a‚ÇÅ a‚ÇÅ = 0 (surplus 2)\n\njulia> iszero(m)\ntrue\n\njulia> m2 = NormalMonomial{FermionicAlgebra}(Int32[1, 2, 1]);  # a‚ÇÅ a‚ÇÇ a‚ÇÅ = -a‚ÇÅ a‚ÇÅ a‚ÇÇ = 0\n\njulia> iszero(m2)\ntrue\n\njulia> m3 = NormalMonomial{FermionicAlgebra}(Int32[1, 1, -1]);  # a‚ÇÅ a‚ÇÅ a‚ÇÅ‚Ä† (surplus 1, not zero yet)\n\njulia> iszero(m3)\nfalse\n\njulia> m4 = NormalMonomial{FermionicAlgebra}(Int32[1, -1, 1, -1]);  # a‚ÇÅ a‚ÇÅ‚Ä† a‚ÇÅ a‚ÇÅ‚Ä† ‚â† 0\n\njulia> iszero(m4)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._compute_normal_ordered_term-Union{Tuple{T}, Tuple{Vector{T}, Vector{Tuple{Int64, Int64}}}} where T","page":"Polynomials","title":"NCTSSoS._compute_normal_ordered_term","text":"_compute_normal_ordered_term(word::Vector{T}, contraction::Vector{Tuple{Int,Int}}) where T\n\nSteps 3-4 of Wick's algorithm: Form N-product and evaluate sign.\n\nFor a given contraction combination:\n\nRemove contracted operator pairs from the word\nNormal-order remaining operators (creators left, annihilators right, sorted by mode)\nCompute sign from the permutation required\nCheck for nilpotency (duplicate operators ‚Üí zero)\n\nReturns (coefficient, normalorderedword).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._contraction_sign-Union{Tuple{T}, Tuple{Vector{T}, Vector{Tuple{Int64, Int64}}}} where T","page":"Polynomials","title":"NCTSSoS._contraction_sign","text":"_contraction_sign(word::Vector{T}, contraction::Vector{Tuple{Int,Int}}) where T\n\nCompute the sign from bringing contracted pairs together.\n\nFor each contraction (i, j), we count the number of uncontracted operators between positions i and j. Each such operator requires a swap to bring the pair together, contributing a factor of -1.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._find_valid_contractions-Union{Tuple{Vector{T}}, Tuple{T}} where T","page":"Polynomials","title":"NCTSSoS._find_valid_contractions","text":"_find_valid_contractions(word::Vector{T}) -> Vector{Tuple{Int,Int}}\n\nStep 1 of Wick's algorithm: Identify all pairs with non-zero contractions.\n\nFor fermions, a contraction is non-zero only when:\n\nPosition i has annihilation operator (positive index)\nPosition j > i has creation operator (negative index)\nBoth have the same mode (|word[i]| == |word[j]|)\n\nThis represents a·µ¢ followed by a·µ¢‚Ä† where {a·µ¢, a·µ¢‚Ä†} = 1.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._generate_nonoverlapping_combinations-Tuple{Vector{Tuple{Int64, Int64}}}","page":"Polynomials","title":"NCTSSoS._generate_nonoverlapping_combinations","text":"_generate_nonoverlapping_combinations(contractions::Vector{Tuple{Int,Int}}) -> Vector{Vector{Tuple{Int,Int}}}\n\nStep 2 of Wick's algorithm: Generate all non-overlapping combinations.\n\nReturns all subsets of contractions where no two pairs share an index. Includes the empty set (no contractions).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._is_fermionic_nilpotent-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Signed","page":"Polynomials","title":"NCTSSoS._is_fermionic_nilpotent","text":"_is_fermionic_nilpotent(word::Vector{T}) where {T<:Signed} -> Bool\n\nCheck if a fermionic word contains repeated identical operators (nilpotent: a·µ¢¬≤ = 0 or (a‚Ä†·µ¢)¬≤ = 0).\n\nNote: a·µ¢ and a‚Ä†·µ¢ are DIFFERENT operators (indices 1 and -1 for mode 1), so [1, -1] is NOT nilpotent, but [1, 1] or [-1, -1] are.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._is_nilpotent_by_flux-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Signed","page":"Polynomials","title":"NCTSSoS._is_nilpotent_by_flux","text":"_is_nilpotent_by_flux(word::Vector{T}) where {T<:Signed} -> Bool\n\nCheck if a raw fermionic word is nilpotent using flux-based detection. A fermionic word is zero if any mode has net surplus >= 2 (same-type operators).\n\nThis is the Vector{T} version of iszero(::NormalMonomial{FermionicAlgebra}) for use before a NormalMonomial is constructed.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._permutation_parity-Tuple{VT} where VT<:(AbstractVector{<:Integer})","page":"Polynomials","title":"NCTSSoS._permutation_parity","text":"_permutation_parity(perm::AbstractVector{<:Integer}) -> Int\n\nCompute the parity (sign) of a permutation using the cycle counting algorithm.\n\nAlgorithm\n\nThe sign of a permutation equals (-1)^(n - c) where:\n\nn is the length of the permutation\nc is the number of disjoint cycles\n\nReturns\n\n1 for even permutations (even number of swaps)\n-1 for odd permutations (odd number of swaps)\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._simplify_fermionic_word!-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Integer","page":"Polynomials","title":"NCTSSoS._simplify_fermionic_word!","text":"_simplify_fermionic_word!(word::Vector{T}) where {T<:Integer} -> Vector{Tuple{Int,Vector{T}}}\n\nNormal-order a fermionic word using Generalized Wick's Theorem.\n\nReturns a vector of (coefficient, normalorderedword) pairs representing the sum:   Œ£ coeffs[i] * word[i]\n\nThis is the low-level function used by simplify(FermionicAlgebra, word). Integer coefficients are exact (from anticommutation signs).\n\nAlgorithm\n\nFind all valid contractions (a·µ¢...a·µ¢‚Ä† pairs with same mode)\nGenerate all non-overlapping contraction combinations\nFor each combination, compute the normal-ordered term with sign\nCombine like terms\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._validate_word-Union{Tuple{T}, Tuple{Type{FermionicAlgebra}, Vector{T}}} where T<:Signed","page":"Polynomials","title":"NCTSSoS._validate_word","text":"_validate_fermionic_word!(word::Vector{T}) where {T<:Signed}\n\nCheck that a fermionic word is in normal-ordered form. Throws ArgumentError if invalid.\n\nNormal order requirements:\n\nCreation operators (negative indices) come before annihilation operators (positive)\nCreators sorted by mode descending; annihilators sorted by mode ascending\n\nThis is used by NormalMonomial{FermionicAlgebra,T} constructor to enforce invariants.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.has_even_parity-Union{Tuple{NormalMonomial{FermionicAlgebra, T}}, Tuple{T}} where T","page":"Polynomials","title":"NCTSSoS.has_even_parity","text":"has_even_parity(m::NormalMonomial{FermionicAlgebra,T}) where T -> Bool\n\nCheck if a fermionic monomial has even parity (even number of operators).\n\nIn fermionic systems, parity superselection forbids observables with odd fermion number from having non-zero expectation values. Only operators with even parity (even number of creation/annihilation operators) can have non-zero physical expectation values.\n\nArguments\n\nm::NormalMonomial{FermionicAlgebra,T}: A fermionic monomial\n\nReturns\n\ntrue if the monomial has an even number of operators (including 0 for identity)\nfalse if the monomial has an odd number of operators\n\nExamples\n\njulia> using NCTSSoS\n\njulia> registry, (a, a_dag) = create_fermionic_variables(1:2);\n\njulia> has_even_parity(one(typeof(a[1])))  # Identity has 0 operators\ntrue\n\njulia> has_even_parity(a[1])  # Single annihilation: 1 operator (odd)\nfalse\n\njulia> has_even_parity(a_dag[1] * a[1])  # Number operator: 2 operators (even)\ntrue\n\nSee also: FermionicAlgebra, simplify\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.simplify!-Union{Tuple{T}, Tuple{Type{FermionicAlgebra}, Vector{T}}} where T<:Signed","page":"Polynomials","title":"NCTSSoS.simplify!","text":"simplify!(::Type{FermionicAlgebra}, word::Vector{T}) where {T<:Signed} -> Vector{Tuple{Int,Vector{T}}}\n\nLow-level in-place normal ordering of a fermionic word.\n\nReturns a vector of (coefficient, normal_ordered_word) pairs representing the PBW expansion as a sum. Each word in the result is unique (coefficients are accumulated for identical words). Modifies word in-place (filters zeros).\n\nThis is the internal workhorse; most users should call simplify(FermionicAlgebra, word).\n\nAlgorithm\n\nUses Generalized Wick's Theorem:\n\nFind all valid contractions (a·µ¢...a·µ¢‚Ä† pairs with same mode)\nGenerate all non-overlapping contraction combinations\nFor each combination, compute the normal-ordered term with sign\nCombine like terms\n\nThrows\n\nErrorException if simplification produces an empty result (should not happen for valid input)\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.simplify-Union{Tuple{T}, Tuple{Type{FermionicAlgebra}, Vector{T}}} where T<:Signed","page":"Polynomials","title":"NCTSSoS.simplify","text":"simplify(::Type{FermionicAlgebra}, word::Vector{T}) where {T<:Signed} -> Vector{Tuple{Int,Vector{T}}}\n\nSimplify a raw fermionic word into normal-ordered form.\n\nThis is the primary entry point for fermionic simplification. Takes a raw word vector and returns a vector of (coefficient, normal_ordered_word) pairs representing the canonical normal-ordered representation.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._validate_word-Union{Tuple{T}, Tuple{Type{BosonicAlgebra}, Vector{T}}} where T<:Signed","page":"Polynomials","title":"NCTSSoS._validate_word","text":"_validate_word(::Type{BosonicAlgebra}, word::Vector{T}) where {T<:Signed}\n\nValidate that a bosonic word is in normal-ordered form.\n\nThrows ArgumentError if the word violates normal ordering. Called by the NormalMonomial{BosonicAlgebra,T} constructor to enforce invariants.\n\nNormal order requirements:\n\nCreation operators (negative indices) before annihilation operators (positive)\nCreators sorted by mode descending; annihilators sorted by mode ascending\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.build_ferrers_board-Union{Tuple{V}, Tuple{T}} where {T, V<:AbstractVector{T}}","page":"Polynomials","title":"NCTSSoS.build_ferrers_board","text":"build_ferrers_board(ops::AbstractVector{T}) -> Vector{Int}\n\nBuild a Ferrers board from an operator sequence (single mode). Returns column heights where board[j] = number of creations AFTER annihilation j.\n\nThe board has n columns (one per annihilation) and m rows (one per creation). Cell (i, j) is included if creation i appears AFTER annihilation j in the word. This corresponds to pairs that need contraction (swapping a with a‚Ä†).\n\nExample\n\nops = Int32[1, -1]  # a a‚Ä† (annihilation at 1, creation at 2)\nboard = build_ferrers_board(ops)\n# Creation is AFTER annihilation ‚Üí contraction possible ‚Üí height 1\n# board = [1]\n\nops = Int32[-1, 1]  # a‚Ä† a (creation at 1, annihilation at 2)\nboard = build_ferrers_board(ops)\n# Creation is BEFORE annihilation ‚Üí no contraction ‚Üí height 0\n# board = [0]\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.compute_rook_numbers-Tuple{Vector{Int64}}","page":"Polynomials","title":"NCTSSoS.compute_rook_numbers","text":"compute_rook_numbers(board::Vector{Int}) -> Vector{Int}\n\nCompute rook numbers for a Ferrers board using dynamic programming. Returns rooknumbers where rooknumbers[k+1] = r‚Çñ(B) (1-indexed).\n\nr‚Çñ(B) = number of ways to place k non-attacking rooks on board B.\n\nExample\n\nboard = [1, 1]  # Two columns, each with height 1 (one row)\nrook = compute_rook_numbers(board)\n# r‚ÇÄ = 1 (one way to place 0 rooks)\n# r‚ÇÅ = 2 (two cells to place one rook)\n# r‚ÇÇ = 0 (can't place 2 rooks in 1 row, but we only track up to n_rows)\n# rook = [1, 2]\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.find_site_separation-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Signed","page":"Polynomials","title":"NCTSSoS.find_site_separation","text":"find_site_separation(word::Vector{T}) -> Vector{Int}\n\nFind mode boundaries in a pre-sorted word.\n\nAssumes word is already sorted by mode (via _stable_sort_by_site!). Returns separation indices [0, end_mode1, end_mode2, ...] where operators for mode i are at indices sep[i]+1:sep[i+1].\n\nExample\n\nword = Int32[1, -1, -2, 2]  # Already sorted: mode 1 ops, then mode 2 ops\nsep = find_site_separation(word)\n# sep = [0, 2, 4]\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.simplify!-Union{Tuple{T}, Tuple{Type{BosonicAlgebra}, Vector{T}}} where T<:Signed","page":"Polynomials","title":"NCTSSoS.simplify!","text":"simplify!(::Type{BosonicAlgebra}, word::Vector{T}) where {T<:Signed} -> Vector{Tuple{Int,Vector{T}}}\n\nLow-level in-place normal ordering of a bosonic word.\n\nReturns a vector of (coefficient, normal_ordered_word) pairs representing the PBW expansion as a sum. Each word in the result is unique (coefficients are accumulated for identical words). Modifies word in-place (filters zeros, sorts by mode).\n\nThis is the internal workhorse; most users should call simplify(BosonicAlgebra, word).\n\nAlgorithm\n\nUses rook numbers on Ferrers boards (arXiv:quant-ph/0507206):\n\nSort by mode (preserving relative order within each mode)\nFind mode boundaries\nCompute single-mode normal forms using rook number formula\nExpand Cartesian product across all modes\nCombine like terms by final word and construct result pairs\n\nThrows\n\nErrorException if simplification produces an empty result (should not happen for valid input)\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.simplify-Union{Tuple{T}, Tuple{Type{BosonicAlgebra}, Vector{T}}} where T<:Signed","page":"Polynomials","title":"NCTSSoS.simplify","text":"simplify(::Type{BosonicAlgebra}, word::Vector{T}) where {T<:Signed}\n\nSimplify a raw bosonic word into normal-ordered form.\n\nThis is the primary entry point for bosonic simplification. Takes a raw word vector and returns a vector of (coefficient, word) pairs representing the PBW expansion.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.single_mode_normal_form-Union{Tuple{V}, Tuple{T}} where {T<:Signed, V<:AbstractVector{T}}","page":"Polynomials","title":"NCTSSoS.single_mode_normal_form","text":"single_mode_normal_form(ops::AbstractVector{T}) -> Vector{Tuple{Int,Int,Int}}\n\nCompute the normal-ordered form of a single-mode operator sequence. Uses the rook number formula from Eq. 1.40 of arXiv:quant-ph/0507206.\n\nReturns vector of (coefficient, numcreations, numannihilations) tuples. Each tuple represents a term in the normal-ordered expansion.\n\nFormula\n\nFor word œâ with m creations and n annihilations:   œâ = Œ£‚Çñ r‚Çñ(Bœâ) (a‚Ä†)^{m-k} a^{n-k} where Bœâ is the Ferrers board and r‚Çñ is the k-th rook number.\n\nExample\n\nops = Int32[1, -1]  # a a‚Ä†\nresult = single_mode_normal_form(ops)\n# result = [(1, 1, 1), (1, 0, 0)]  # a‚Ä† a + 1\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._validate_word-Union{Tuple{T}, Tuple{Type{ProjectorAlgebra}, Vector{T}}} where T<:Unsigned","page":"Polynomials","title":"NCTSSoS._validate_word","text":"_validate_word(::Type{ProjectorAlgebra}, word::Vector{T}) where {T<:Unsigned}\n\nCheck that a projector word is in canonical form. Throws ArgumentError if invalid.\n\nCanonical form requirements:\n\nSites sorted in ascending order\nNo consecutive identical operators (no P¬≤ terms)\n\nThis is used by NormalMonomial{ProjectorAlgebra,T} constructor to enforce invariants.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.simplify!-Union{Tuple{T}, Tuple{Type{ProjectorAlgebra}, Vector{T}}} where T<:Unsigned","page":"Polynomials","title":"NCTSSoS.simplify!","text":"simplify!(::Type{ProjectorAlgebra}, word::Vector{T}) where {T<:Unsigned} -> Vector{T}\n\nIn-place site-aware simplification for projector algebra word vectors.\n\nOperators on different sites commute and are sorted by site (ascending). Within each site, idempotency applies: consecutive identical operators collapse (P¬≤ = P).\n\nReturns the simplified word vector (mutated in place).\n\nAlgorithm\n\nStable sort by site (using decode_site)\nRemove consecutive duplicates (idempotency)\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.simplify-Union{Tuple{T}, Tuple{Type{ProjectorAlgebra}, Vector{T}}} where T<:Unsigned","page":"Polynomials","title":"NCTSSoS.simplify","text":"simplify(::Type{ProjectorAlgebra}, w::Vector{T}) where {T<:Unsigned} -> Vector{T}\n\nSimplify a raw ProjectorAlgebra word into canonical form.\n\nThis is the primary entry point for ProjectorAlgebra simplification. Takes a raw word vector and returns a simplified copy (sorted by site, idempotency applied).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._validate_word-Union{Tuple{T}, Tuple{Type{UnipotentAlgebra}, Vector{T}}} where T<:Unsigned","page":"Polynomials","title":"NCTSSoS._validate_word","text":"_validate_word(::Type{UnipotentAlgebra}, word::Vector{T}) where {T<:Unsigned}\n\nCheck that a unipotent word is in canonical form. Throws ArgumentError if invalid.\n\nCanonical form requirements:\n\nSites sorted in ascending order\nNo consecutive identical operators (no U¬≤ terms - they should cancel to I)\n\nThis is used by NormalMonomial{UnipotentAlgebra,T} constructor to enforce invariants.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.simplify!-Union{Tuple{T}, Tuple{Type{UnipotentAlgebra}, Vector{T}}} where T<:Unsigned","page":"Polynomials","title":"NCTSSoS.simplify!","text":"simplify!(::Type{UnipotentAlgebra}, word::Vector{T}) where {T<:Unsigned} -> Vector{T}\n\nIn-place site-aware simplification for unipotent algebra word vectors.\n\nOperators on different sites commute and are sorted by site (ascending). Within each site, U¬≤=I applies: consecutive identical operators cancel (remove pairs).\n\nReturns the simplified word vector (mutated in place).\n\nAlgorithm\n\nStable sort by site (using decode_site)\nApply U¬≤=I via stack (remove consecutive pairs)\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.simplify-Union{Tuple{T}, Tuple{Type{UnipotentAlgebra}, Vector{T}}} where T<:Unsigned","page":"Polynomials","title":"NCTSSoS.simplify","text":"simplify(::Type{UnipotentAlgebra}, word::Vector{T}) where {T<:Unsigned} -> Vector{T}\n\nSimplify a raw UnipotentAlgebra word into canonical form.\n\nThis is the primary entry point for UnipotentAlgebra simplification. Takes a raw word vector and returns a simplified copy (sorted by site, U¬≤=I applied).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS._validate_word-Union{Tuple{T}, Tuple{Type{NonCommutativeAlgebra}, Vector{T}}} where T<:Unsigned","page":"Polynomials","title":"NCTSSoS._validate_word","text":"_validate_word(::Type{NonCommutativeAlgebra}, word::Vector{T}) where {T<:Unsigned}\n\nCheck that a noncommutative word is in canonical form. Throws ArgumentError if invalid.\n\nCanonical form requirements:\n\nSites sorted in ascending order (operators on different sites commute)\n\nThis is used by NormalMonomial{NonCommutativeAlgebra,T} constructor to enforce invariants.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.simplify!-Union{Tuple{T}, Tuple{Type{NonCommutativeAlgebra}, Vector{T}}} where T<:Unsigned","page":"Polynomials","title":"NCTSSoS.simplify!","text":"simplify!(::Type{NonCommutativeAlgebra}, word::Vector{T}) where {T<:Unsigned} -> Vector{T}\n\nIn-place site-aware simplification for non-commutative algebra word vectors.\n\nOperators on different sites commute and are sorted by site (ascending). Within each site, order is preserved exactly (no simplification rules apply).\n\nReturns the sorted word vector (mutated in place).\n\nAlgorithm\n\nFilter out zero indices\nStable sort by site (using decode_site)\nWithin each site: preserve order exactly\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.simplify-Union{Tuple{T}, Tuple{Type{NonCommutativeAlgebra}, Vector{T}}} where T<:Signed","page":"Polynomials","title":"NCTSSoS.simplify","text":"simplify(::Type{NonCommutativeAlgebra}, word::Vector{T}) where {T<:Signed}\n\nThrows ArgumentError. Signed indices are not supported for NonCommutativeAlgebra. Use encode_index with an unsigned integer type to construct site-encoded indices.\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.simplify-Union{Tuple{T}, Tuple{Type{NonCommutativeAlgebra}, Vector{T}}} where T<:Unsigned","page":"Polynomials","title":"NCTSSoS.simplify","text":"simplify(::Type{NonCommutativeAlgebra}, word::Vector{T}) where {T<:Unsigned} -> Vector{T}\n\nSimplify a raw NonCommutative word into canonical form.\n\nThis is the primary entry point for NonCommutative simplification. Takes a raw word vector and returns the simplified word vector (sorted by site).\n\n\n\n\n\n","category":"method"},{"location":"apis/polynomials/#NCTSSoS.get_ncbasis-Union{Tuple{T}, Tuple{A}, Tuple{VariableRegistry{A, T}, Int64}} where {A<:AlgebraType, T<:Integer}","page":"Polynomials","title":"NCTSSoS.get_ncbasis","text":"get_ncbasis(registry::VariableRegistry{A,T}, d::Int) where {A,T} -> Vector{NormalMonomial{A,T}}\n\nGenerate a basis of monomials up to degree d from the variables in registry.\n\nThis function enumerates all words of length 0 to d over the variable indices, applies algebra-specific simplification, and returns the unique simplified monomials in sorted order.\n\nArguments\n\nregistry: Variable registry containing the variable indices\nd: Maximum degree (inclusive)\n\nReturns\n\nA sorted vector of unique NormalMonomial{A,T} elements up to degree d.\n\nExamples\n\njulia> using NCTSSoS\n\njulia> reg, (x,) = create_noncommutative_variables([(\"x\", 1:2)]);\n\njulia> basis = get_ncbasis(reg, 2);\n\njulia> length(basis)  # 1 + 2 + 4 = 7 monomials\n7\n\njulia> degree.(basis)\n7-element Vector{Int64}:\n 0\n 1\n 1\n 2\n 2\n 2\n 2\n\nFor algebras with simplification (e.g., UnipotentAlgebra where x¬≤ = x):\n\njulia> using NCTSSoS\n\njulia> reg, (u,) = create_unipotent_variables([(\"u\", 1:2)]);\n\njulia> basis = get_ncbasis(reg, 2);\n\njulia> length(basis)  # Fewer due to x¬≤ = x simplification\n5\n\nSee also: get_state_basis, VariableRegistry\n\n\n\n\n\n","category":"method"},{"location":"apis/sparsities/#Sparsities","page":"Sparsities","title":"Sparsities","text":"","category":"section"},{"location":"apis/sparsities/#Eliminations","page":"Sparsities","title":"Eliminations","text":"","category":"section"},{"location":"apis/sparsities/#NCTSSoS.CorrelativeSparsity","page":"Sparsities","title":"NCTSSoS.CorrelativeSparsity","text":"CorrelativeSparsity{A<:AlgebraType, T<:Integer, P, M, ST}\n\nStructure representing the correlative sparsity pattern of a polynomial optimization problem.\n\nType Parameters\n\nA<:AlgebraType: The algebra type (PauliAlgebra, NonCommutativeAlgebra, etc.)\nT<:Integer: The index type used in the registry\nP: The polynomial type (Polynomial{A,T} or NCStatePolynomial)\nM: The monomial/basis type (NormalMonomial{A,T} or NCStateWord)\nST: State type - Nothing for regular polynomials, StateType subtype for state polynomials\n\nFields\n\ncliques::Vector{Vector{T}}: Groups of variable indices that form cliques in the sparsity graph\nregistry::VariableRegistry{A,T}: Variable registry for symbol lookups and sub-registry creation\ncons::Vector{P}: All constraints in the problem\nclq_cons::Vector{Vector{Int}}: Constraint indices assigned to each clique, regardless of equality or inequality\nglobal_cons::Vector{Int}: Constraint indices not captured by any single clique\nclq_mom_mtx_bases::Vector{Vector{M}}: NormalMonomial bases for moment matrices within each clique\nclq_localizing_mtx_bases::Vector{Vector{Vector{M}}}: NormalMonomial bases for localizing matrices within each clique\n\nNotes\n\nCliques store variable indices (type T), not symbols\nUse subregistry(cs.registry, cs.cliques[i]) to get a clique-local registry\nUse cs.registry[idx] to look up symbol names for indices\n\n\n\n\n\n","category":"type"},{"location":"apis/sparsities/#NCTSSoS.get_correlative_graph","page":"Sparsities","title":"NCTSSoS.get_correlative_graph","text":"get_correlative_graph(registry::VariableRegistry{A,T}, obj::P, cons::Vector{P}) where {A<:AlgebraType, T<:Integer, P<:Polynomial{A,T}}\n\nConstructs a correlative sparsity graph from polynomial optimization problem components.\n\nThe graph nodes are numbered 1 to N where N is the number of unique variable indices. A position-based mapping is used to convert variable indices to graph node positions.\n\nArguments\n\nregistry::VariableRegistry{A,T}: Variable registry containing all problem variables\nobj::P: Objective polynomial\ncons::Vector{P}: Constraint polynomials\n\nReturns\n\nTuple{SimpleGraph, Vector{T}, Dict{T,Int}}: Tuple containing:\nSimpleGraph: Graph representing variable correlations\nsorted_indices::Vector{T}: All unique indices in sorted order\nidx_to_node::Dict{T,Int}: Mapping from variable index to graph node position\n\nNotes\n\nUses variable_indices() to extract indices from polynomials\nGraph nodes are 1:N positions, not raw variable indices\nFor signed index types (Fermionic/Bosonic), uses abs(idx) for consistency\n\n\n\n\n\n","category":"function"},{"location":"apis/sparsities/#NCTSSoS.assign_constraint","page":"Sparsities","title":"NCTSSoS.assign_constraint","text":"assign_constraint(cliques::Vector{Vector{T}}, cons::Vector{P}, registry::VariableRegistry{A,T}) where {A<:AlgebraType, T<:Integer, C, P<:Polynomial{A,T,C}}\n\nAssigns constraints to cliques based on variable support (index-based).\n\nArguments\n\ncliques::Vector{Vector{T}}: Variable index cliques\ncons::Vector{P}: Constraint polynomials\nregistry::VariableRegistry{A,T}: Variable registry (for future extensions)\n\nReturns\n\nTuple{Vector{Vector{Int}}, Vector{Int}}: Tuple containing:\nConstraint indices for each clique\nGlobal constraint indices not captured by any single clique\n\nNotes\n\nUses variable_indices() to get indices from constraints\nA constraint is assigned to a clique if all its variable indices are in the clique\n\n\n\n\n\n","category":"function"},{"location":"apis/sparsities/#NCTSSoS.correlative_sparsity","page":"Sparsities","title":"NCTSSoS.correlative_sparsity","text":"correlative_sparsity(pop::OP, order::Int, elim_algo::EliminationAlgorithm) where {A<:AlgebraType, T, P<:Polynomial{A,T}, OP<:OptimizationProblem{A,P}}\n\nDecomposes a polynomial optimization problem into a correlative sparsity pattern by identifying variable cliques and assigning constraints to cliques, enabling block-structured semidefinite relaxations.\n\nArguments\n\npop::OptimizationProblem{A,P}: Polynomial optimization problem containing objective, constraints, and registry\norder::Int: Order of the moment relaxation\nelim_algo::EliminationAlgorithm: Algorithm for clique tree elimination\n\nReturns\n\nCorrelativeSparsity{A,T,P,M}: Structure containing:\ncliques: Groups of variable indices forming cliques\nregistry: Variable registry for symbol lookups\ncons: All constraints\nclq_cons: Constraint indices assigned to each clique\nglobal_cons: Constraint indices not captured by any single clique\nclq_mom_mtx_bases: NormalMonomial bases for moment matrices\nclq_localizing_mtx_bases: NormalMonomial bases for localizing matrices\n\nNotes\n\nUses subregistry() and get_ncbasis() for basis generation\nExtracts monomials from basis polynomials for matrix indexing\n\n\n\n\n\ncorrelative_sparsity(pop::PolyOpt, order, elim_algo) -> CorrelativeSparsity\n\nDecomposes a state polynomial optimization problem into a correlative sparsity pattern.\n\nArguments\n\npop::PolyOpt{A,T,P}: Polynomial optimization problem with NCStatePolynomial objective\norder::Int: Order of the moment relaxation\nelim_algo::EliminationAlgorithm: Algorithm for clique tree elimination\n\nReturns\n\nCorrelativeSparsity{A,T,P,M,ST}: Correlative sparsity structure for state polynomials\n\n\n\n\n\n","category":"function"},{"location":"apis/sparsities/#NCTSSoS.TermSparsity","page":"Sparsities","title":"NCTSSoS.TermSparsity","text":"TermSparsity{M}\n\nStructure representing term sparsity information for polynomial optimization.\n\nType Parameters\n\nM: NormalMonomial type\n\nFields\n\nterm_sparse_graph_supp::Vector{M}: Support of the term sparsity graph\nblock_bases::Vector{Vector{M}}: Bases of moment/localizing matrices in each block\n\n\n\n\n\n","category":"type"},{"location":"apis/sparsities/#NCTSSoS.term_sparsities","page":"Sparsities","title":"NCTSSoS.term_sparsities","text":"term_sparsities(initial_activated_supp::Vector{NormalMonomial{A,T}}, cons::Vector{P}, mom_mtx_bases::Vector{M}, localizing_mtx_bases::Vector{Vector{M}}, ts_algo::EliminationAlgorithm)\n\nComputes term sparsity structures for the moment matrix and all localizing matrices.\n\nArguments\n\ninitial_activated_supp::Vector{NormalMonomial}: Initial set of activated support NormalMonomials\ncons::Vector{P}: Vector of constraint polynomials\nmom_mtx_bases::Vector{M}: Basis NormalMonomials for the moment matrix\nlocalizing_mtx_bases::Vector{Vector{M}}: Basis Monomials for each localizing matrix corresponding to constraints\nts_algo::EliminationAlgorithm: Algorithm for clique tree elimination in term sparsity graphs\n\nReturns\n\nVector{TermSparsity{M}}: Vector containing term sparsity structures, with the first element corresponding to the moment matrix and subsequent elements corresponding to localizing matrices\n\n\n\n\n\nterm_sparsities(initial_activated_supp, cons, mom_mtx_bases, localizing_mtx_bases, ts_algo)\n\nComputes term sparsity structures for state polynomial optimization.\n\nArguments\n\ninitial_activated_supp::Vector{NCStateWord}: Initial activated support\ncons::Vector{NCStatePolynomial}: Constraint state polynomials\nmom_mtx_bases::Vector{NCStateWord}: Moment matrix basis NCStateWords\nlocalizing_mtx_bases::Vector{Vector{NCStateWord}}: Localizing matrix bases\nts_algo::EliminationAlgorithm: Algorithm for term sparsity graphs\n\nReturns\n\nVector{TermSparsity{NCStateWord}}: Term sparsity structures\n\n\n\n\n\n","category":"function"},{"location":"apis/sparsities/#NCTSSoS.get_term_sparsity_graph","page":"Sparsities","title":"NCTSSoS.get_term_sparsity_graph","text":"get_term_sparsity_graph(cons_support::Vector{NormalMonomial{A,T}}, activated_supp::Vector{NormalMonomial{A,T}}, bases::Vector{M}) where {A,T,M}\n\nConstructs a term sparsity graph for polynomial constraints.\n\nArguments\n\ncons_support::Vector{NormalMonomial}: Support NormalMonomials of constraints\nactivated_supp::Vector{NormalMonomial}: Support from previous iterations\nbases::Vector{M}: Basis Monomials used to index the moment matrix\n\nReturns\n\nSimpleGraph: Term sparsity graph where edges connect basis elements whose products have support in the activated support set\n\n\n\n\n\nget_term_sparsity_graph(cons_support, activated_supp, bases) for NCStateWord\n\nConstructs a term sparsity graph for state polynomial constraints.\n\nAn edge is added between basis elements i and j if the canonicalized product bi‚Ä† * supp * bj (for any supp in cons_support) is present in the activated support. The comparison uses expval to convert NCStateWords to StateWords, ensuring that structurally different NCStateWords with the same expectation value are treated as equal.\n\n\n\n\n\n","category":"function"},{"location":"apis/sparsities/#NCTSSoS.iterate_term_sparse_supp","page":"Sparsities","title":"NCTSSoS.iterate_term_sparse_supp","text":"iterate_term_sparse_supp(activated_supp::Vector{NormalMonomial{A,T}}, poly::P, basis::Vector{M}, elim_algo::EliminationAlgorithm) where {A,T,C,P,M}\n\nIteratively computes term sparsity support for a polynomial.\n\nArguments\n\nactivated_supp::Vector{NormalMonomial}: Currently activated support NormalMonomials\npoly::P: Input polynomial\nbasis::Vector{M}: Basis Monomials\nelim_algo::EliminationAlgorithm: Elimination algorithm for clique decomposition\n\nReturns\n\nTermSparsity{M}: Term sparsity structure containing graph support and block bases\n\n\n\n\n\niterate_term_sparse_supp(activated_supp, poly, basis, elim_algo) for NCStatePolynomial\n\nIteratively computes term sparsity support for a state polynomial.\n\n\n\n\n\n","category":"function"},{"location":"apis/sparsities/#NCTSSoS.term_sparsity_graph_supp","page":"Sparsities","title":"NCTSSoS.term_sparsity_graph_supp","text":"term_sparsity_graph_supp(G::SimpleGraph, basis::Vector{M}, g::P) where {A,T,C,P,M}\n\nComputes the support of a term sparsity graph for a given polynomial.\n\nImplements equation (10.4) from \"Sparse Polynomial Optimization: Theory and Practice\".\n\nArguments\n\nG::SimpleGraph: Term sparsity graph\nbasis::Vector{M}: Basis Monomials\ng::P: Input polynomial\n\nReturns\n\nVector{NormalMonomial{A,T}}: Support NormalMonomials for the term sparsity graph\n\n\n\n\n\nterm_sparsity_graph_supp(G, basis, g) for NCStatePolynomial\n\nComputes the support of a term sparsity graph for a state polynomial.\n\n\n\n\n\n","category":"function"},{"location":"apis/sparsities/#NCTSSoS.clique_decomp","page":"Sparsities","title":"NCTSSoS.clique_decomp","text":"clique_decomp(G::SimpleGraph, clique_alg::EliminationAlgorithm)\n\nDecomposes a graph into cliques using the specified elimination algorithm.\n\nArguments\n\nG::SimpleGraph: Input graph to decompose\nclique_alg::EliminationAlgorithm: Algorithm for clique tree elimination\n\nReturns\n\nVector{Vector{Int}}: Vector of cliques, each containing vertex indices\n\n\n\n\n\nclique_decomp(G::SimpleGraph, ::AsIsElimination)\n\nReturns maximal cliques of the graph without triangulation.\n\nwarning: Warning\nThis method assumes the graph is already chordal. If the graph is not chordal, the resulting cliques may not satisfy the Running Intersection Property (RIP), which could lead to invalid SOS relaxation bounds. Use MF() or MMD() for automatic chordal completion on non-chordal graphs.\n\n\n\n\n\n","category":"function"},{"location":"manual/polynomials/#polynomials","page":"Polynomials","title":"Polynomials in Non-Commutative Optimization","text":"NCTSSoS.jl is designed to solve optimization problems where the variables do not commute, a scenario that is the foundation of quantum mechanics. This page outlines the key polynomial types used in the package and their specific applications in many-body physics.\n\n(Image: Relation between different Polynomials)","category":"section"},{"location":"manual/polynomials/#non-commutative-polynomial","page":"Polynomials","title":"Non-Commutative Polynomials: The Language of Quantum Systems","text":"In quantum mechanics, the order of measurements matters. Non-commutative polynomials provide the natural language for this reality. They are the building blocks for constructing the Hamiltonian of a quantum system, which describes its total energy.","category":"section"},{"location":"manual/polynomials/#tracial-polynomial","page":"Polynomials","title":"Trace Polynomials: Probing Non-Local Correlations","text":"Trace polynomials are a specialized class of mathematical objects that consist of polynomials in noncommuting variables combined with traces of their products. Unlike ordinary commutative polynomials where variables can be freely rearranged (e.g., xy = yx), trace polynomials involve noncommutative variables where order matters, and they incorporate the trace operation‚Äîa fundamental concept from linear algebra and operator theory that computes the sum of diagonal elements of a matrix. These mathematical structures have gained significant attention due to their applications in quantum information theory, particularly in the context of optimizing quantum systems and analyzing violations of polynomial Bell inequalities. The optimization of trace polynomials subject to tracial constraints represents a natural extension of semidefinite programming techniques to the noncommutative setting, drawing from areas such as real algebraic geometry, operator theory, and noncommutative algebra to provide powerful tools for solving complex problems in quantum mechanics and related fields.","category":"section"},{"location":"manual/polynomials/#Mathematical-Framework","page":"Polynomials","title":"Mathematical Framework","text":"In the context of tracial polynomial optimization, we consider polynomials of the form:\n\np(X‚ÇÅ, X‚ÇÇ, ..., X‚Çô) = Œ£ c‚Çê tr(X‚Çê)\n\nwhere:\n\nX‚ÇÅ, X‚ÇÇ, ..., X‚Çô are noncommuting matrix variables\nc‚Çê are real coefficients\nX‚Çê represents monomials in the noncommuting variables\ntr(¬∑) denotes the trace operation\n\nThe key challenge in tracial polynomial optimization is to find the minimum or maximum value of such polynomials subject to tracial constraints, which may include:\n\nTrace normalization conditions\nPositivity constraints on trace polynomials\nAdditional structural constraints on the matrix variables","category":"section"},{"location":"manual/polynomials/#state-polynomial","page":"Polynomials","title":"State Polynomials","text":"State polynomials are functions of the expectation values themselves. This structure is essential for defining nonlinear Bell inequalities. These more complex inequalities provide powerful and subtle tests of quantum mechanics, allowing researchers to explore the boundary between the quantum and classical worlds in greater detail.","category":"section"},{"location":"manual/polynomials/#eigenvalue-polynomial","page":"Polynomials","title":"Eigenvalue Polynomials","text":"These polynomials are used to find the possible energy levels (eigenvalues) of a quantum Hamiltonian. A primary application is to find the ground state energy‚Äîthe lowest possible energy of a many-body system. This is a fundamental problem in condensed matter physics.","category":"section"},{"location":"#NCTSSoS","page":"Home","title":"NCTSSoS","text":"NCTSSoS.jl aims to provide a user-friendly and efficient tool for solving noncommutative polynomial optimization problems which is based on the structured moment-SOHS hierarchy.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Ergonomic API: Easy to use and intuitive interface for defining polynomial optimization problems!\nGeneral Objectives: Eigenvalue, State, Tracial Polynomial optimizations are supported!\nCorrelative and Term Sparsities: Plug-and-Play API for utilizing sparsities in reducing cost of solving optimization problems.\n\nwarning: Performance Issue\nVersion 0.1.0 has performance issues! We plan to release a new version with better performance in the near future. Stay tuned!","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"NCTSSoS.jl could be installed by running\n\nusing Pkg\nPkg.add(\"NCTSSoS\")\n\nTo make sure everything works, you can execute the test suite. See TESTING.md in the repository root.\n\nCan't wait to try NCTSSoS.jl in action? Hop to Quick Start.","category":"section"},{"location":"#Credits","page":"Home","title":"Credits","text":"The following people are involved in the development of NCTSSoS.jl:\n\nJie Wang, Academy of Mathematics and Systems Science, Chinese Academy of Sciences.\nJin-Guo Liu, Advanced Materials Thrust , The Hong Kong University of Science and Technology(Guangzhou).\nYusheng Zhao, Advanced Materials Thrust , The Hong Kong University of Science and Technology(Guangzhou).\nHuanhai Zhou, Advanced Materials Thrust , The Hong Kong University of Science and Technology(Guangzhou).\n\nIf this project is useful for your work please consider\n\nCiting NCTSSoS.jl\nLeave us a star on GitHub!!","category":"section"},{"location":"#License","page":"Home","title":"License","text":"NCTSSoS.jl is licensed under the MIT License.","category":"section"},{"location":"#Related-packages","page":"Home","title":"Related packages","text":"TSSOS: Commutative polynomial optimization\nChordalGraph: Chordal graphs and chordal extentions","category":"section"},{"location":"examples/generated/monoid_algebras_showcase/#Monoid-Algebra-Showcase-(NonCommutative-/-Projector-/-Unipotent)","page":"Monoid Algebra Showcase","title":"Monoid Algebra Showcase (NonCommutative / Projector / Unipotent)","text":"This page showcases the three MonoidAlgebra variants supported by NCTSSoS.jl. These algebras provide the building blocks for modeling noncommutative polynomial optimization problems that arise in quantum information and many-body physics.","category":"section"},{"location":"examples/generated/monoid_algebras_showcase/#Capabilities-Overview","page":"Monoid Algebra Showcase","title":"Capabilities Overview","text":"Each monoid algebra type provides automatic simplification of operator products according to its defining relations:\n\nAlgebra Type Simplification Rule Typical Use Case\nNonCommutativeAlgebra None (free words) General NC polynomial optimization\nProjectorAlgebra P¬≤ = P (idempotent) Projective measurements, NPA hierarchy\nUnipotentAlgebra U¬≤ = ùüô (involution) Pauli observables, Bell inequalities\n\nAll three algebras share a common feature: site-based commutation. Operators acting on different physical sites automatically commute during canonicalization, while the order of operators on the same site is preserved.","category":"section"},{"location":"examples/generated/monoid_algebras_showcase/#Key-Public-APIs","page":"Monoid Algebra Showcase","title":"Key Public APIs","text":"Variable creation is done through these functions:\n\ncreate_noncommutative_variables: Create free noncommutative generators\ncreate_projector_variables: Create idempotent (P¬≤ = P) generators\ncreate_unipotent_variables: Create involutory (U¬≤ = ùüô) generators\n\nEach function returns a (registry, variable_groups) tuple, where the registry manages symbol ‚Üî index mappings and the variable groups provide convenient access to the created monomials.","category":"section"},{"location":"examples/generated/monoid_algebras_showcase/#References-and-Applications","page":"Monoid Algebra Showcase","title":"References and Applications","text":"NonCommutativeAlgebra (free words): The standard modeling layer for noncommutative polynomial optimization and SDP hierarchies. See Burgdorf‚ÄìKlep‚ÄìPovh (Burgdorf et al., 2016), Wang‚ÄìMagron (Wang and Magron, 2021), and the comprehensive treatment in (Magron and Wang, 2023).\nProjectorAlgebra (P¬≤ = P): Projection operators and projective measurements. In device-independent quantum information, projective measurements appear naturally in the Navascu√©s‚ÄìPironio‚ÄìAc√≠n (NPA) SDP hierarchy for bounding quantum correlations (Navascu√©s et al., 2007), (Navascu√©s et al., 2008). In many-body physics, projectors enforce local constraints and define subspaces; see Sachdev (Sachdev, 2011).\nUnipotentAlgebra (U¬≤ = ùüô): Involutory (¬±1-valued) observables model self-adjoint unitaries like Pauli measurements. These are fundamental in quantum information (Nielsen and Chuang, 2010) and appear in Bell inequality optimization (Klep et al., 2024).","category":"section"},{"location":"examples/generated/monoid_algebras_showcase/#Setup","page":"Monoid Algebra Showcase","title":"Setup","text":"using NCTSSoS\nusing NCTSSoS: decode_site, decode_operator_id\n\nHelper: extract the single monomial from a single-term polynomial.\n\nmono1(p) = monomials(p)[1]\n\nPretty-print a NormalMonomial using the registry's symbols.\n\nrepr_with_registry(reg, m) = sprint(show, m; context=:registry => reg)","category":"section"},{"location":"examples/generated/monoid_algebras_showcase/#1)-NonCommutativeAlgebra:-Free-Noncommutative-Words","page":"Monoid Algebra Showcase","title":"1) NonCommutativeAlgebra: Free Noncommutative Words","text":"The NonCommutativeAlgebra represents free words with no algebraic relations other than site-based commutation. This is the most general monoid algebra type.","category":"section"},{"location":"examples/generated/monoid_algebras_showcase/#Creating-Variables","page":"Monoid Algebra Showcase","title":"Creating Variables","text":"Use create_noncommutative_variables with a vector of (prefix, subscripts) tuples. Each prefix group is assigned to a distinct site, enabling automatic commutation between groups.\n\nreg_nc, (x, y) = create_noncommutative_variables([(\"x\", 1:2), (\"y\", 1:2)])\n\nThis creates:\n\nVariables x[1], x[2] on site 1\nVariables y[1], y[2] on site 2\n\nA single generator is a NormalMonomial (immutable canonical form):\n\ntypeof(x[1])","category":"section"},{"location":"examples/generated/monoid_algebras_showcase/#Site-Based-Commutation","page":"Monoid Algebra Showcase","title":"Site-Based Commutation","text":"Operators on different sites commute automatically. The canonical form groups operators by site, preserving intra-site order:\n\nlhs = x[2] * y[1] * x[1] * y[2]\nrhs = x[2] * x[1] * y[1] * y[2]  # same canonical form\n\n@assert lhs == rhs  # true: sites are sorted\n\nrepr_with_registry(reg_nc, mono1(lhs))  # \"x‚ÇÇx‚ÇÅy‚ÇÅy‚ÇÇ\"","category":"section"},{"location":"examples/generated/monoid_algebras_showcase/#Intra-Site-Non-Commutativity","page":"Monoid Algebra Showcase","title":"Intra-Site Non-Commutativity","text":"Within a single site, operators do NOT commute (no relations are imposed):\n\n@assert x[1] * x[2] != x[2] * x[1]\n\nShow both representations to see they differ:\n\n(repr_with_registry(reg_nc, mono1(x[1] * x[2])),  # \"x‚ÇÅx‚ÇÇ\"\n repr_with_registry(reg_nc, mono1(x[2] * x[1])))  # \"x‚ÇÇx‚ÇÅ\"","category":"section"},{"location":"examples/generated/monoid_algebras_showcase/#Inspecting-the-Canonical-Word","page":"Monoid Algebra Showcase","title":"Inspecting the Canonical Word","text":"Each index encodes both operator identity and site. You can decode them:\n\nword = mono1(lhs).word\n\nword: the raw indices of the canonical monomial\n\nDecode each index as (operator_id, site):\n\noperator_id: which variable (1=x‚ÇÅ, 2=x‚ÇÇ, 3=y‚ÇÅ, 4=y‚ÇÇ)\nsite: which physical site (1 or 2)\n\n[(decode_operator_id(i), decode_site(i)) for i in word]\n\nOutput: [(2,1), (1,1), (3,2), (4,2)] means x‚ÇÇx‚ÇÅy‚ÇÅy‚ÇÇ with x's on site 1, y's on site 2","category":"section"},{"location":"examples/generated/monoid_algebras_showcase/#2)-ProjectorAlgebra:-Idempotent-Operators-(P-P)","page":"Monoid Algebra Showcase","title":"2) ProjectorAlgebra: Idempotent Operators (P¬≤ = P)","text":"The ProjectorAlgebra models projection operators (idempotents). Any repeated application of the same projector collapses to a single instance.\n\nQuantum Information Applications:\n\nProjective measurements (PVM elements) in the NPA hierarchy (Navascu√©s et al., 2007), (Navascu√©s et al., 2008)\nLocal projectors like |0‚ü©‚ü®0| and |1‚ü©‚ü®1| for qubit measurements\n\nMany-Body Physics Applications:\n\nLocal constraint projectors (e.g., Gutzwiller projectors)\nSubspace projections in variational methods (Sachdev, 2011)","category":"section"},{"location":"examples/generated/monoid_algebras_showcase/#Creating-Projector-Variables","page":"Monoid Algebra Showcase","title":"Creating Projector Variables","text":"reg_proj, (P, Q) = create_projector_variables([(\"P\", 1:2), (\"Q\", 1:2)])\n\nP[1], P[2] on site 1 (with P¬≤ = P)\nQ[1], Q[2] on site 2 (with Q¬≤ = Q)","category":"section"},{"location":"examples/generated/monoid_algebras_showcase/#Idempotency-Simplification","page":"Monoid Algebra Showcase","title":"Idempotency Simplification","text":"Repeated projectors automatically collapse:\n\n@assert monomials(P[1] * P[1]) == [P[1]]        # P¬≤ = P\n@assert monomials(P[1] * P[1] * P[1]) == [P[1]] # P¬≥ = P","category":"section"},{"location":"examples/generated/monoid_algebras_showcase/#Site-Commutation-with-Idempotency","page":"Monoid Algebra Showcase","title":"Site Commutation with Idempotency","text":"Cross-site operators commute, and idempotency is applied after canonicalization:\n\n@assert monomials(Q[2] * P[1]) == monomials(P[1] * Q[2])  # site commutation\n\nMore complex example: commutation brings same-site operators together, then idempotency collapses repeated factors:\n\nresult = mono1(Q[1] * P[1] * Q[1] * P[1])\nrepr_with_registry(reg_proj, result)  # \"P‚ÇÅQ‚ÇÅ\" (both collapse)","category":"section"},{"location":"examples/generated/monoid_algebras_showcase/#3)-UnipotentAlgebra:-Involutory-Operators-(U-ùüô)","page":"Monoid Algebra Showcase","title":"3) UnipotentAlgebra: Involutory Operators (U¬≤ = ùüô)","text":"The UnipotentAlgebra models operators that square to the identity, such as Pauli matrices œÉ‚Çì, œÉ·µß, œÉ·µ§. This is the natural algebra for ¬±1-valued observables.\n\nQuantum Information Applications:\n\nPauli observables in quantum computation (Nielsen and Chuang, 2010)\nCHSH and other Bell inequalities with dichotomic measurements (Klep et al., 2024)\nStabilizer formalism and error correction\n\nMany-Body Physics Applications:\n\nSpin-¬Ω systems with Pauli operators\nIsing model interactions","category":"section"},{"location":"examples/generated/monoid_algebras_showcase/#Creating-Unipotent-Variables","page":"Monoid Algebra Showcase","title":"Creating Unipotent Variables","text":"reg_unip, (U, V) = create_unipotent_variables([(\"U\", 1:2), (\"V\", 1:2)])\nconst ID_UNIP = one(NormalMonomial{UnipotentAlgebra, eltype(indices(reg_unip))})\n\nU[1], U[2] on site 1 (with U¬≤ = ùüô)\nV[1], V[2] on site 2 (with V¬≤ = ùüô)","category":"section"},{"location":"examples/generated/monoid_algebras_showcase/#Involution-Simplification","page":"Monoid Algebra Showcase","title":"Involution Simplification","text":"Squared operators simplify to the identity:\n\n@assert monomials(U[1] * U[1]) == [ID_UNIP]     # U¬≤ = ùüô\n@assert monomials(U[1] * U[1] * U[1]) == [U[1]] # U¬≥ = U","category":"section"},{"location":"examples/generated/monoid_algebras_showcase/#Site-Commutation-with-Involution","page":"Monoid Algebra Showcase","title":"Site Commutation with Involution","text":"Cross-site commutation works as expected:\n\n@assert monomials(V[2] * U[1]) == monomials(U[1] * V[2])","category":"section"},{"location":"examples/generated/monoid_algebras_showcase/#Cancellation-After-Canonicalization","page":"Monoid Algebra Showcase","title":"Cancellation After Canonicalization","text":"Site-based canonicalization can bring paired operators together, enabling cancellation:\n\nV‚ÇÅ U‚ÇÅ V‚ÇÅ U‚ÇÅ ‚Üí (after site sort) ‚Üí V‚ÇÅ V‚ÇÅ U‚ÇÅ U‚ÇÅ = ùüô\n\n@assert monomials(V[1] * U[1] * V[1] * U[1]) == [ID_UNIP]\n\nSimpler case: U‚ÇÅ¬≤ U‚ÇÇ = U‚ÇÇ\n\n@assert monomials(U[1] * U[1] * U[2]) == monomials(U[2])","category":"section"},{"location":"examples/generated/monoid_algebras_showcase/#4)-Generating-Monomial-Bases","page":"Monoid Algebra Showcase","title":"4) Generating Monomial Bases","text":"The function get_ncbasis(registry, degree) returns all distinct monomials up to the specified degree. This is useful for constructing moment matrices in SDP relaxations.\n\nbasis_d1 = get_ncbasis(reg_nc, 1)\n\nbasis_d1: all monomials up to degree 1\n\nPretty-print the basis using the registry:\n\n[repr_with_registry(reg_nc, m) for m in basis_d1]\n\nbasis_d2 = get_ncbasis(reg_nc, 2)\n\nbasis_d2: all monomials up to degree 2\n\nShow count and a few examples:\n\nlength(basis_d2)  # total count\n\nPretty-print all degree-2 basis elements:\n\n[repr_with_registry(reg_nc, m) for m in basis_d2]","category":"section"},{"location":"examples/generated/monoid_algebras_showcase/#5)-Practical-Example:-Building-Polynomials","page":"Monoid Algebra Showcase","title":"5) Practical Example: Building Polynomials","text":"Monomial algebras integrate seamlessly with NCTSSoS.jl's polynomial optimization pipeline. Here's a simple example of building a polynomial objective:\n\nCoefficients create polynomials from monomials\n\npoly = 1.0 * x[1] * x[2] + 2.0 * y[1] - 3.0 * x[1] * y[1]\n\nSite commutation is automatic in polynomial arithmetic:\n\npoly2 = 1.0 * y[1] * x[1] - 3.0 * x[1] * y[1]  # y‚ÇÅ and x‚ÇÅ commute!\nmonomials(poly2)  # simplified: terms combine if they have the same canonical form","category":"section"},{"location":"examples/generated/monoid_algebras_showcase/#Summary:-Choosing-the-Right-Algebra","page":"Monoid Algebra Showcase","title":"Summary: Choosing the Right Algebra","text":"Your operators satisfy... Use this algebra Creation function\nNo relations (free) NonCommutativeAlgebra create_noncommutative_variables\nP¬≤ = P (projectors) ProjectorAlgebra create_projector_variables\nU¬≤ = ùüô (involutions) UnipotentAlgebra create_unipotent_variables\n\nAll three provide:\n\nAutomatic site-based commutation for operators on different sites\nCanonical forms via NormalMonomial for efficient comparison and storage\nRegistry-based pretty printing for human-readable output\nSeamless integration with polyopt and cs_nctssos for optimization\n\nFor more advanced use cases including Pauli algebra (with cyclic products) and fermionic/bosonic algebras, see the other examples in this documentation.\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
