<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>GNS Construction for Pauli Operators · NCTSSoS.jl</title><meta name="title" content="GNS Construction for Pauli Operators · NCTSSoS.jl"/><meta property="og:title" content="GNS Construction for Pauli Operators · NCTSSoS.jl"/><meta property="twitter:title" content="GNS Construction for Pauli Operators · NCTSSoS.jl"/><meta name="description" content="Documentation for NCTSSoS.jl."/><meta property="og:description" content="Documentation for NCTSSoS.jl."/><meta property="twitter:description" content="Documentation for NCTSSoS.jl."/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">NCTSSoS.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><a class="tocitem" href="../../../quick_start/">Quick Start</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../../manual/polynomials/">Polynomials</a></li><li><a class="tocitem" href="../../../manual/monomials/">Monomials</a></li><li><a class="tocitem" href="../../../manual/polynomial_optimization/">Polynomial Optimization</a></li><li><a class="tocitem" href="../../../manual/sparsities/">Sparsities</a></li><li><a class="tocitem" href="../../../manual/sdp_relaxation/">SDP Relaxation</a></li><li><a class="tocitem" href="../../../manual/optimizers/">Optimizers</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../bell/">Bell inequalities</a></li><li><a class="tocitem" href="../trace_poly/">Trace Polynomial</a></li><li><a class="tocitem" href="../ground_state_energy/">Ground State Energy</a></li><li><a class="tocitem" href="../pauli_algebra_interface/">Pauli Algebra Interface</a></li><li><a class="tocitem" href="../certify_ground_state_property/">Certifying Ground State Property</a></li><li class="is-active"><a class="tocitem" href>GNS Construction for Pauli Operators</a><ul class="internal"><li><a class="tocitem" href="#Background:-From-Expectation-Values-to-Matrix-Representations"><span>Background: From Expectation Values to Matrix Representations</span></a></li><li><a class="tocitem" href="#Pauli-Operators:-A-Simple-Quantum-System"><span>Pauli Operators: A Simple Quantum System</span></a></li><li><a class="tocitem" href="#Step-1:-Define-Non-commuting-Variables"><span>Step 1: Define Non-commuting Variables</span></a></li><li><a class="tocitem" href="#Step-2:-Choose-a-Quantum-State"><span>Step 2: Choose a Quantum State</span></a></li><li><a class="tocitem" href="#Step-3:-Compute-Expectation-Values"><span>Step 3: Compute Expectation Values</span></a></li><li><a class="tocitem" href="#Step-4:-Build-the-Moment-(Hankel)-Matrix"><span>Step 4: Build the Moment (Hankel) Matrix</span></a></li><li><a class="tocitem" href="#Step-5:-GNS-Reconstruction"><span>Step 5: GNS Reconstruction</span></a></li><li><a class="tocitem" href="#Step-6:-Verify-Pauli-Algebra"><span>Step 6: Verify Pauli Algebra</span></a></li><li><a class="tocitem" href="#Understanding-Unitary-Freedom-in-GNS-Reconstruction"><span>Understanding Unitary Freedom in GNS Reconstruction</span></a></li><li><a class="tocitem" href="#Example-2:-Random-Pure-State"><span>Example 2: Random Pure State</span></a></li><li><a class="tocitem" href="#Second-Unitary-Transformation-to-Fix-X-and-Y"><span>Second Unitary Transformation to Fix X and Y</span></a></li><li><a class="tocitem" href="#Systematic-Approach:-Determine-U-from-X_transformed"><span>Systematic Approach: Determine U₂ from X_transformed</span></a></li><li><a class="tocitem" href="#Example-3:-Mixed-State-with-Higher-Rank"><span>Example 3: Mixed State with Higher Rank</span></a></li><li><a class="tocitem" href="#Understanding-the-Flat-Extension-Property"><span>Understanding the Flat Extension Property</span></a></li><li><a class="tocitem" href="#Summary"><span>Summary</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../../reference/">References</a></li><li><span class="tocitem">APIs</span><ul><li><a class="tocitem" href="../../../apis/interface/">User interface</a></li><li><a class="tocitem" href="../../../apis/polynomials/">Polynomials</a></li><li><a class="tocitem" href="../../../apis/sparsities/">Sparsities</a></li><li><a class="tocitem" href="../../../apis/relaxations/">SDP Relaxation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>GNS Construction for Pauli Operators</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>GNS Construction for Pauli Operators</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumSOS/NCTSSoS.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumSOS/NCTSSoS.jl/blob/main/docs/src/examples/generated/pauli_gns_construction.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><p>&lt;!– nctssos-literate-source: pauli<em>gns</em>construction.jl sha256: 2ae77edfb12c32e290ccb8e94a1b928cf80d658f03568ad4fa8ab67591a10405 –&gt;</p><h1 id="GNS-Construction-for-Pauli-Operator-Reconstruction"><a class="docs-heading-anchor" href="#GNS-Construction-for-Pauli-Operator-Reconstruction">GNS Construction for Pauli Operator Reconstruction</a><a id="GNS-Construction-for-Pauli-Operator-Reconstruction-1"></a><a class="docs-heading-anchor-permalink" href="#GNS-Construction-for-Pauli-Operator-Reconstruction" title="Permalink"></a></h1><p>The Gelfand-Naimark-Segal (GNS) construction is a fundamental mathematical tool in quantum mechanics that allows us to represent abstract quantum states and operators as concrete matrices acting on a Hilbert space. For physicists, this provides a systematic way to reconstruct operator representations from expectation values (moments).</p><h2 id="Background:-From-Expectation-Values-to-Matrix-Representations"><a class="docs-heading-anchor" href="#Background:-From-Expectation-Values-to-Matrix-Representations">Background: From Expectation Values to Matrix Representations</a><a id="Background:-From-Expectation-Values-to-Matrix-Representations-1"></a><a class="docs-heading-anchor-permalink" href="#Background:-From-Expectation-Values-to-Matrix-Representations" title="Permalink"></a></h2><p>In quantum mechanics, we often know the expectation values of operators in a given state:</p><p class="math-container">\[\langle A  \rangle = \text{Tr}(\rho A)\]</p><p>where <span>$\rho$</span> is the density matrix and <span>$A$</span> is an operator.</p><p>The GNS construction answers the question: <strong>Can we reconstruct the actual matrices representing operators from just these expectation values?</strong></p><p>The key insight is that the collection of all expectation values defines a <strong>moment matrix</strong> (also called a Hankel matrix in the context of polynomial optimization):</p><p class="math-container">\[H_{ij} = \langle b_i^\dagger b_j \rangle\]</p><p>where <span>$\{b_i\}$</span> is a basis of operators (monomials in our variables).</p><h2 id="Pauli-Operators:-A-Simple-Quantum-System"><a class="docs-heading-anchor" href="#Pauli-Operators:-A-Simple-Quantum-System">Pauli Operators: A Simple Quantum System</a><a id="Pauli-Operators:-A-Simple-Quantum-System-1"></a><a class="docs-heading-anchor-permalink" href="#Pauli-Operators:-A-Simple-Quantum-System" title="Permalink"></a></h2><p>Let&#39;s start with the simplest non-trivial quantum system: a single qubit with Pauli operators. The Pauli matrices are:</p><ul><li><span>$\sigma_x = \begin{pmatrix} 0 &amp; 1 \\ 1 &amp; 0  \end{pmatrix}$</span></li><li><span>$\sigma_y = \begin{pmatrix} 0 &amp; -i \\ i &amp; 0 \end{pmatrix}$</span></li><li><span>$\sigma_z = \begin{pmatrix} 1 &amp; 0 \\ 0 &amp; -1 \end{pmatrix}$</span>`</li></ul><p>These satisfy the fundamental Pauli algebra:</p><ol><li><span>$\sigma_x^2 = \sigma_y^2 = \sigma_z^2 = I$</span> (squares equal identity)</li><li><span>$\{\sigma_i, \sigma_j\} = 0$</span> for <span>$i \neq j$</span> (anti-commutation)</li><li><span>$[\sigma_i, \sigma_j] = 2i\epsilon_{ijk}\sigma_k$</span> (commutation relations)</li></ol><h2 id="Step-1:-Define-Non-commuting-Variables"><a class="docs-heading-anchor" href="#Step-1:-Define-Non-commuting-Variables">Step 1: Define Non-commuting Variables</a><a id="Step-1:-Define-Non-commuting-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Define-Non-commuting-Variables" title="Permalink"></a></h2><pre><code class="language-julia hljs">using NCTSSoS
using LinearAlgebra
using LinearAlgebra: tr</code></pre><p>In <code>NCTSSoS.jl</code>, we represent Pauli operators as non-commuting polynomial variables: Create non-commuting variables using the typed algebra system</p><pre><code class="language-julia hljs">registry, (x, y, z) = create_noncommutative_variables([(&quot;x&quot;, 1:1), (&quot;y&quot;, 1:1), (&quot;z&quot;, 1:1)])</code></pre><p>Extract single variables from arrays</p><pre><code class="language-julia hljs">x, y, z = x[1], y[1], z[1]</code></pre><p>These variables x, y, z will represent σₓ, σᵧ, σ_z respectively</p><pre><code class="language-julia hljs">vars = [x, y, z];</code></pre><h2 id="Step-2:-Choose-a-Quantum-State"><a class="docs-heading-anchor" href="#Step-2:-Choose-a-Quantum-State">Step 2: Choose a Quantum State</a><a id="Step-2:-Choose-a-Quantum-State-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Choose-a-Quantum-State" title="Permalink"></a></h2><pre><code class="language-julia hljs">zero_state = ComplexF64[1; 0];    # |0⟩
one_state = ComplexF64[0; 1];</code></pre><p>Define quantum states for testing For clear reconstruction, use a pure state</p><pre><code class="language-julia hljs">ρ =  zero_state * zero_state&#39;</code></pre><h2 id="Step-3:-Compute-Expectation-Values"><a class="docs-heading-anchor" href="#Step-3:-Compute-Expectation-Values">Step 3: Compute Expectation Values</a><a id="Step-3:-Compute-Expectation-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Compute-Expectation-Values" title="Permalink"></a></h2><p>We need a function to compute the expectation value of any monomial in our variables:</p><pre><code class="language-julia hljs">function expval_pauli(mono::Monomial, ρ::Matrix)
    if isone(mono)
        return 1.0 + 0.0im  # ⟨I⟩ = 1 for normalized states
    end

    # Start with identity matrix
    mat = Matrix{ComplexF64}(I, 2, 2)

    # Multiply the appropriate Pauli matrices
    for (var, exp) in zip(mono.vars, mono.z)
        pauli_mat = if var == x
            ComplexF64[0 1; 1 0]      # σₓ
        elseif var == y
            ComplexF64[0 -im; im 0]   # σᵧ
        elseif var == z
            ComplexF64[1 0; 0 -1]     # σ_z
        else
            error(&quot;Unknown variable: $var&quot;)
        end

        # Raise to the appropriate power
        for _ in 1:exp
            mat = mat * pauli_mat
        end
    end

    # Compute Tr(ρ * mat)
    return tr(ρ * mat)
end</code></pre><h2 id="Step-4:-Build-the-Moment-(Hankel)-Matrix"><a class="docs-heading-anchor" href="#Step-4:-Build-the-Moment-(Hankel)-Matrix">Step 4: Build the Moment (Hankel) Matrix</a><a id="Step-4:-Build-the-Moment-(Hankel)-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-Build-the-Moment-(Hankel)-Matrix" title="Permalink"></a></h2><p>The moment matrix encodes all expectation values of products of our basis operators:</p><p>Choose the degree of our polynomial basis</p><pre><code class="language-julia hljs">degree = 4;</code></pre><p>Generate the basis of monomials up to the specified degree</p><pre><code class="language-julia hljs">basis = NCTSSoS.get_basis(vars, degree)

println(&quot;Basis operators (monomials):&quot;)
for (i, b) in enumerate(basis)
    println(&quot;$i: $b&quot;)
end</code></pre><p>Build the moment matrix H where H[i,j] = ⟨b<em>i† * b</em>j⟩</p><pre><code class="language-julia hljs">n = length(basis)
H = zeros(ComplexF64, n, n)

for i in 1:n
    for j in 1:n
        mono_i = basis[i]
        mono_j = basis[j]

        # Compute the product monomial
        product = NCTSSoS.neat_dot(mono_i, mono_j)

        # Get the expectation value
        H[i, j] = expval_pauli(product, ρ)
    end
end</code></pre><p>Verify that H is Hermitian (as required by quantum mechanics)</p><pre><code class="language-julia hljs">println(&quot;Moment matrix H is Hermitian: &quot;, H ≈ H&#39;)</code></pre><h2 id="Step-5:-GNS-Reconstruction"><a class="docs-heading-anchor" href="#Step-5:-GNS-Reconstruction">Step 5: GNS Reconstruction</a><a id="Step-5:-GNS-Reconstruction-1"></a><a class="docs-heading-anchor-permalink" href="#Step-5:-GNS-Reconstruction" title="Permalink"></a></h2><p>Now we use the <code>reconstruct</code> function to perform the GNS construction and obtain concrete matrix representations of our abstract operators:</p><pre><code class="language-julia hljs">X_recon, Y_recon, Z_recon = reconstruct(H, vars, degree; atol=0.001)</code></pre><pre><code class="language-julia hljs">println(&quot;Reconstructed Pauli operators:&quot;)
println(&quot;σₓ (reconstructed):&quot;)
round.(X_recon, digits=6)</code></pre><pre><code class="language-julia hljs">println(&quot;σᵧ (reconstructed):&quot;)
round.(Y_recon, digits=6)</code></pre><pre><code class="language-julia hljs">println(&quot;σ_z (reconstructed):&quot;)
round.(Z_recon, digits=6)</code></pre><h2 id="Step-6:-Verify-Pauli-Algebra"><a class="docs-heading-anchor" href="#Step-6:-Verify-Pauli-Algebra">Step 6: Verify Pauli Algebra</a><a id="Step-6:-Verify-Pauli-Algebra-1"></a><a class="docs-heading-anchor-permalink" href="#Step-6:-Verify-Pauli-Algebra" title="Permalink"></a></h2><p>The true test of our reconstruction is whether the recovered operators satisfy the Pauli algebra relations:</p><h3 id="Test-1:-Squares-should-equal-identity-(X-Y-Z-I)"><a class="docs-heading-anchor" href="#Test-1:-Squares-should-equal-identity-(X-Y-Z-I)">Test 1: Squares should equal identity (X² = Y² = Z² = I)</a><a id="Test-1:-Squares-should-equal-identity-(X-Y-Z-I)-1"></a><a class="docs-heading-anchor-permalink" href="#Test-1:-Squares-should-equal-identity-(X-Y-Z-I)" title="Permalink"></a></h3><pre><code class="language-julia hljs">X2 = X_recon * X_recon
Y2 = Y_recon * Y_recon
Z2 = Z_recon * Z_recon

println(&quot;   ||X² - I|| = $(norm(X2 - I))&quot;)
println(&quot;   ||Y² - I|| = $(norm(Y2 - I))&quot;)
println(&quot;   ||Z² - I|| = $(norm(Z2 - I))&quot;)</code></pre><h3 id="Test-2:-Anti-commutation-relations-({σᵢ,-σⱼ}-0-for-i-j)"><a class="docs-heading-anchor" href="#Test-2:-Anti-commutation-relations-({σᵢ,-σⱼ}-0-for-i-j)">Test 2: Anti-commutation relations ({σᵢ, σⱼ} = 0 for i ≠ j)</a><a id="Test-2:-Anti-commutation-relations-({σᵢ,-σⱼ}-0-for-i-j)-1"></a><a class="docs-heading-anchor-permalink" href="#Test-2:-Anti-commutation-relations-({σᵢ,-σⱼ}-0-for-i-j)" title="Permalink"></a></h3><pre><code class="language-julia hljs">anticomm_XY = X_recon * Y_recon + Y_recon * X_recon
anticomm_YZ = Y_recon * Z_recon + Z_recon * Y_recon
anticomm_ZX = Z_recon * X_recon + X_recon * Z_recon

println(&quot;||{X,Y}|| = $(norm(anticomm_XY))&quot;)
println(&quot;||{Y,Z}|| = $(norm(anticomm_YZ))&quot;)
println(&quot;||{Z,X}|| = $(norm(anticomm_ZX))&quot;)</code></pre><h3 id="Test-3:-Commutation-relations-([σᵢ,-σⱼ]-2iε_ijkσₖ)"><a class="docs-heading-anchor" href="#Test-3:-Commutation-relations-([σᵢ,-σⱼ]-2iε_ijkσₖ)">Test 3: Commutation relations ([σᵢ, σⱼ] = 2iε_ijkσₖ)</a><a id="Test-3:-Commutation-relations-([σᵢ,-σⱼ]-2iε_ijkσₖ)-1"></a><a class="docs-heading-anchor-permalink" href="#Test-3:-Commutation-relations-([σᵢ,-σⱼ]-2iε_ijkσₖ)" title="Permalink"></a></h3><pre><code class="language-julia hljs">comm_XY = X_recon * Y_recon - Y_recon * X_recon
comm_YZ = Y_recon * Z_recon - Z_recon * Y_recon
comm_ZX = Z_recon * X_recon - X_recon * Z_recon

println(&quot;||[X,Y] - 2iZ|| = $(norm(comm_XY - 2im * Z_recon))&quot;)
println(&quot;||[Y,Z] - 2iX|| = $(norm(comm_YZ - 2im * X_recon))&quot;)
println(&quot;||[Z,X] - 2iY|| = $(norm(comm_ZX - 2im * Y_recon))&quot;)</code></pre><h2 id="Understanding-Unitary-Freedom-in-GNS-Reconstruction"><a class="docs-heading-anchor" href="#Understanding-Unitary-Freedom-in-GNS-Reconstruction">Understanding Unitary Freedom in GNS Reconstruction</a><a id="Understanding-Unitary-Freedom-in-GNS-Reconstruction-1"></a><a class="docs-heading-anchor-permalink" href="#Understanding-Unitary-Freedom-in-GNS-Reconstruction" title="Permalink"></a></h2><p><strong>Important observation</strong>: Looking at the reconstructed matrices above, you may notice that the reconstructed X looks like the usual Pauli Y matrix (with an overall negative sign), and the reconstructed Y looks like the usual Pauli X matrix. This might seem surprising, but it&#39;s completely fine! Here&#39;s why:</p><ol><li><p><strong>The Pauli algebra is still satisfied</strong>: Even though <code>X_recon</code> ≈ -σ_y (negative Pauli-Y), it still satisfies all the required algebraic relations:</p><ul><li>X² = I (since (-σ<em>y)² = σ</em>y² = I)</li><li>{X, Y} = 0 (anticommutation still holds)</li><li>[X, Y] = 2iZ (commutation relations preserved)</li></ul></li><li><p><strong>Unitary equivalence</strong>: The reconstructed matrices differ from standard Pauli matrices by a unitary transformation. This is fundamental to GNS construction - it only guarantees reconstruction <strong>up to unitary equivalence</strong>, not exact reconstruction of a specific matrix representation.</p></li></ol><h2 id="Example-2:-Random-Pure-State"><a class="docs-heading-anchor" href="#Example-2:-Random-Pure-State">Example 2: Random Pure State</a><a id="Example-2:-Random-Pure-State-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-Random-Pure-State" title="Permalink"></a></h2><p>Let&#39;s verify that GNS reconstruction works for an arbitrary pure state:</p><p>Create a random normalized pure state (not aligned with computational basis)</p><pre><code class="language-julia hljs">using Random  # For reproducibility in random state example
Random.seed!(42)  # For reproducibility
ψ_random = normalize(randn(ComplexF64, 2))
ρ_random = ψ_random * ψ_random&#39;

@show ψ_random;</code></pre><p>Build moment matrix and reconstruct</p><pre><code class="language-julia hljs">H_random = zeros(ComplexF64, n, n)
for i in 1:n, j in 1:n
    product = NCTSSoS.neat_dot(basis[i], basis[j])
    H_random[i, j] = expval_pauli(product, ρ_random)
end

X_rand, Y_rand, Z_rand = reconstruct(H_random, vars, degree; atol=0.001)

@show rank(H_random, atol=1e-6);
@show size(X_rand);</code></pre><p>The reconstructed operators look very different from standard Pauli matrices:</p><pre><code class="language-julia hljs">X_rand</code></pre><pre><code class="language-julia hljs">Y_rand</code></pre><pre><code class="language-julia hljs">Z_rand</code></pre><p>The reconstructed operators are not in the familar form but still satisfy the Pauli algebra:</p><pre><code class="language-julia hljs">@show norm(X_rand * X_rand - I);
@show norm(X_rand * Y_rand + Y_rand * X_rand);
@show norm((X_rand * Y_rand - Y_rand * X_rand) - 2im * Z_rand);</code></pre><p>Now, let&#39;s diagonalize Z_rand and use its eigenvectors to transform all three operators:</p><h3 id="Transforming-to-Eigenbasis-of-Z"><a class="docs-heading-anchor" href="#Transforming-to-Eigenbasis-of-Z">Transforming to Eigenbasis of Z</a><a id="Transforming-to-Eigenbasis-of-Z-1"></a><a class="docs-heading-anchor-permalink" href="#Transforming-to-Eigenbasis-of-Z" title="Permalink"></a></h3><p>The key insight: If we diagonalize Z_rand, the resulting unitary transformation will bring X, Y, and Z into the standard Pauli matrix form (up to ordering and phases).</p><pre><code class="language-julia hljs">F_rand = eigen(Z_rand)  # Diagonalize Z, not Y!

@show F_rand.values;</code></pre><p>Important: eigen() may return eigenvectors in any order. The standard Pauli Z matrix is σ_z = diag(1, -1), so we want eigenvalue +1 first and -1 second.</p><pre><code class="language-julia hljs">if real(F_rand.values[1]) &lt; real(F_rand.values[2])
    # Need to swap eigenvectors to get correct ordering (eigenvalue +1 first)
    U_rand = F_rand.vectors[:, [2, 1]]
    @info &quot;Reordered eigenvectors to match σ_z = diag(1, -1) convention&quot;
else
    U_rand = F_rand.vectors
end</code></pre><p>Apply the unitary transformation U<em>rand† · (operator) · U</em>rand to all three operators:</p><pre><code class="language-julia hljs">Z_transformed = U_rand&#39; * Z_rand * U_rand;
X_transformed = U_rand&#39; * X_rand * U_rand;
Y_transformed = U_rand&#39; * Y_rand * U_rand;</code></pre><p>Display the transformed operators:</p><pre><code class="language-julia hljs">println(&quot;\nZ after transformation (should be diagonal):&quot;)
round.(Z_transformed, digits=4)</code></pre><pre><code class="language-julia hljs">println(&quot;\nX after transformation:&quot;)
round.(X_transformed, digits=4)</code></pre><pre><code class="language-julia hljs">println(&quot;\nY after transformation:&quot;)
round.(Y_transformed, digits=4)</code></pre><h2 id="Second-Unitary-Transformation-to-Fix-X-and-Y"><a class="docs-heading-anchor" href="#Second-Unitary-Transformation-to-Fix-X-and-Y">Second Unitary Transformation to Fix X and Y</a><a id="Second-Unitary-Transformation-to-Fix-X-and-Y-1"></a><a class="docs-heading-anchor-permalink" href="#Second-Unitary-Transformation-to-Fix-X-and-Y" title="Permalink"></a></h2><p>The first transformation (diagonalizing Z) gave us a diagonal Z, but X and Y might still differ from standard Pauli matrices by permutations or sign flips. We need a second unitary transformation that:</p><ol><li>Preserves the diagonal form of Z (must be diagonal in the Z eigenbasis)</li><li>Brings X and Y to their standard forms</li></ol><p>The most general unitary that preserves a diagonal matrix is another diagonal unitary (phase matrix) or a permutation followed by phases. Let&#39;s construct this explicitly:</p><h2 id="Systematic-Approach:-Determine-U-from-X_transformed"><a class="docs-heading-anchor" href="#Systematic-Approach:-Determine-U-from-X_transformed">Systematic Approach: Determine U₂ from X_transformed</a><a id="Systematic-Approach:-Determine-U-from-X_transformed-1"></a><a class="docs-heading-anchor-permalink" href="#Systematic-Approach:-Determine-U-from-X_transformed" title="Permalink"></a></h2><p><strong>Goal</strong>: Find U₂ such that:</p><ol><li>U₂† · X<em>transformed · U₂ = σ</em>x = <code>[0 1; 1 0]</code></li><li>U₂† · Z<em>transformed · U₂ = Z</em>transformed (preserve Z&#39;s diagonal form)</li><li>U₂† · Y<em>transformed · U₂ = σ</em>y = <code>[0 -im; im 0]</code> (automatically satisfied if 1 &amp; 2 hold)</li></ol><p><strong>Key insight</strong>: Since Z is diagonal, any unitary that preserves Z must be diagonal: U₂ = diag(e^(iα), e^(iβ))</p><p>If <code>X_transformed</code> = <code>[0  a; b  0]</code>, we want: U₂† · <code>X_transformed</code> · U₂ = <code>[0  e^(-iα)·a·e^(iβ); e^(-iβ)·b·e^(iα)  0]</code> = <code>[0  1; 1  0]</code></p><p>This requires: e^(i(β-α))·a = 1, so β - α = -arg(a) And for Hermiticity (b = a<em>): e^(i(α-β))·a</em> = 1, which is automatically satisfied</p><p>We can choose α = 0, then β = -arg(a)</p><p>Let&#39;s compute this systematically:</p><pre><code class="language-julia hljs">σ_x = ComplexF64[0 1; 1 0]
σ_y = ComplexF64[0 -im; im 0]
σ_z = ComplexF64[1 0; 0 -1]
if abs(Z_transformed[1,1] - 1) &lt; 0.1 || abs(Z_transformed[1,1] + 1) &lt; 0.1  # Z is diagonal
    # Extract the off-diagonal elements of X_transformed
    # X should have form [0  a; a*  0] for Hermitian matrix
    a = X_transformed[1, 2]

    # We want U₂† [0 a; a* 0] U₂ = [0 1; 1 0]
    # With U₂ = diag(e^(iα), e^(iβ)), this gives:
    # [0  e^(-iα)ae^(iβ); e^(-iβ)a*e^(iα)  0] = [0 1; 1 0]
    # So we need: e^(i(β-α)) = 1/a, or β - α = -arg(a)

    # Choose α = 0, then β = -arg(a)
    α = 0.0
    β = -angle(a)

    # Construct U₂
    U2_systematic = diagm([exp(im*α), exp(im*β)])

    println(&quot;\nPhases determined: α = $α, β = $β&quot;)
    println(&quot;This should make X_transformed[1,2] real and positive: $(exp(im*(β-α)) * a)&quot;)

    # Apply the systematic transformation
    Z_corrected = U2_systematic&#39; * Z_transformed * U2_systematic
    X_corrected = U2_systematic&#39; * X_transformed * U2_systematic
    Y_corrected = U2_systematic&#39; * Y_transformed * U2_systematic

    println(&quot;\n=== After Systematic Phase Correction ===&quot;)

    println(&quot;\nZ (should remain unchanged since U₂ is diagonal):&quot;)
    println(round.(Z_corrected, digits=6))
    println(&quot;Verification: ||Z_corrected - Z_transformed|| = $(norm(Z_corrected - Z_transformed))&quot;)

    println(&quot;\nX (should now match σ_x):&quot;)
    println(round.(X_corrected, digits=6))

    println(&quot;\nY (should now match σ_y):&quot;)
    println(round.(Y_corrected, digits=6))

    println(&quot;\n=== Final Verification ===&quot;)
    println(&quot;Distance from standard Pauli matrices:&quot;)
    println(&quot;||Z_corrected - σ_z|| = $(norm(Z_corrected - σ_z))&quot;)
    println(&quot;||X_corrected - σ_x|| = $(norm(X_corrected - σ_x))&quot;)
    println(&quot;||Y_corrected - σ_y|| = $(norm(Y_corrected - σ_y))&quot;)

    # If still not perfect, check for permutations
    if norm(X_corrected - σ_x) &gt; 0.01
        println(&quot;\nChecking if X and Y are swapped:&quot;)
        println(&quot;||X_corrected - σ_y|| = $(norm(X_corrected - σ_y))&quot;)
        println(&quot;||Y_corrected - σ_x|| = $(norm(Y_corrected - σ_x))&quot;)
    end

    # Verify Pauli algebra is still satisfied
    println(&quot;\n=== Verify Pauli Algebra Still Holds ===&quot;)
    println(&quot;||X² - I|| = $(norm(X_corrected * X_corrected - I))&quot;)
    println(&quot;||Y² - I|| = $(norm(Y_corrected * Y_corrected - I))&quot;)
    println(&quot;||Z² - I|| = $(norm(Z_corrected * Z_corrected - I))&quot;)
    println(&quot;||[X,Y] - 2iZ|| = $(norm((X_corrected * Y_corrected - Y_corrected * X_corrected) - 2im * Z_corrected))&quot;)
end</code></pre><h2 id="Example-3:-Mixed-State-with-Higher-Rank"><a class="docs-heading-anchor" href="#Example-3:-Mixed-State-with-Higher-Rank">Example 3: Mixed State with Higher Rank</a><a id="Example-3:-Mixed-State-with-Higher-Rank-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-Mixed-State-with-Higher-Rank" title="Permalink"></a></h2><p>Now let&#39;s see what happens with a mixed state that is not a pure state. Mixed state: ½|0⟩⟨0| + ½|+⟩⟨+| where |+⟩ = (|0⟩ + |1⟩)/√2</p><pre><code class="language-julia hljs">plus_state = normalize(ComplexF64[1; 1])
ρ_mixed = 0.5 * (zero_state * zero_state&#39;) + 0.5 * (plus_state * plus_state&#39;)</code></pre><p>Build moment matrix and reconstruct</p><pre><code class="language-julia hljs">H_mixed = zeros(ComplexF64, n, n)
for i in 1:n, j in 1:n
    product = NCTSSoS.neat_dot(basis[i], basis[j])
    H_mixed[i, j] = expval_pauli(product, ρ_mixed)
end

X_mixed, Y_mixed, Z_mixed = reconstruct(H_mixed, vars, degree; atol=0.001)

@show rank(H_mixed, atol=1e-6);
@show size(X_mixed);</code></pre><p>For a mixed state, the rank can be higher! The reconstructed operators now act on a <strong>direct sum</strong> of smaller Hilbert spaces. But remarkably, they still satisfy the Pauli algebra:</p><h3 id="Complete-Pauli-Algebra-Verification"><a class="docs-heading-anchor" href="#Complete-Pauli-Algebra-Verification">Complete Pauli Algebra Verification</a><a id="Complete-Pauli-Algebra-Verification-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-Pauli-Algebra-Verification" title="Permalink"></a></h3><pre><code class="language-julia hljs">dim_mixed = size(X_mixed, 1)</code></pre><p><strong>Test 1: Squares should equal identity (σᵢ² = I)</strong></p><pre><code class="language-julia hljs">println(&quot;||X² - I|| = $(norm(X_mixed * X_mixed - I(dim_mixed)))&quot;)
println(&quot;||Y² - I|| = $(norm(Y_mixed * Y_mixed - I(dim_mixed)))&quot;)
println(&quot;||Z² - I|| = $(norm(Z_mixed * Z_mixed - I(dim_mixed)))&quot;)</code></pre><p><strong>Test 2: Anti-commutation relations ({σᵢ, σⱼ} = 0 for i ≠ j)</strong></p><pre><code class="language-julia hljs">anticomm_XY_mixed = X_mixed * Y_mixed + Y_mixed * X_mixed
anticomm_YZ_mixed = Y_mixed * Z_mixed + Z_mixed * Y_mixed
anticomm_ZX_mixed = Z_mixed * X_mixed + X_mixed * Z_mixed

println(&quot;||{X,Y}|| = $(norm(anticomm_XY_mixed))&quot;)
println(&quot;||{Y,Z}|| = $(norm(anticomm_YZ_mixed))&quot;)
println(&quot;||{Z,X}|| = $(norm(anticomm_ZX_mixed))&quot;)</code></pre><p><strong>Test 3: Commutation relations ([σᵢ, σⱼ] = 2iε_ijkσₖ)</strong></p><pre><code class="language-julia hljs">comm_XY_mixed = X_mixed * Y_mixed - Y_mixed * X_mixed
comm_YZ_mixed = Y_mixed * Z_mixed - Z_mixed * Y_mixed
comm_ZX_mixed = Z_mixed * X_mixed - X_mixed * Z_mixed

println(&quot;||[X,Y] - 2iZ|| = $(norm(comm_XY_mixed - 2im * Z_mixed))&quot;)
println(&quot;||[Y,Z] - 2iX|| = $(norm(comm_YZ_mixed - 2im * X_mixed))&quot;)
println(&quot;||[Z,X] - 2iY|| = $(norm(comm_ZX_mixed - 2im * Y_mixed))&quot;)</code></pre><p>This demonstrates that GNS reconstruction can handle both pure and mixed states, automatically determining the appropriate Hilbert space dimension!</p><h2 id="Understanding-the-Flat-Extension-Property"><a class="docs-heading-anchor" href="#Understanding-the-Flat-Extension-Property">Understanding the Flat Extension Property</a><a id="Understanding-the-Flat-Extension-Property-1"></a><a class="docs-heading-anchor-permalink" href="#Understanding-the-Flat-Extension-Property" title="Permalink"></a></h2><p>A crucial condition for successful GNS reconstruction is the <strong>flat extension property</strong>. This requires that the rank of the full moment matrix equals the rank of its principal submatrix (the Hankel block).</p><p>The <code>reconstruct</code> function automatically checks this condition and will issue a warning if it&#39;s not satisfied. When the flatness condition holds, we can be confident that our reconstruction is valid and complete.</p><h2 id="Summary"><a class="docs-heading-anchor" href="#Summary">Summary</a><a id="Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Summary" title="Permalink"></a></h2><p>✓ GNS reconstruction successfully extracts operator representations from moments</p><p>✓ Reconstructed operators satisfy the correct algebraic relations</p><p>✓ Works for both pure states (low rank) and mixed states (higher rank)</p><p>✓ Operators are unique up to unitary transformations</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../certify_ground_state_property/">« Certifying Ground State Property</a><a class="docs-footer-nextpage" href="../../../reference/">References »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 13 January 2026 14:39">Tuesday 13 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
